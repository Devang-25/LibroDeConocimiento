---------------------------------------------------------------------------

# List Comprehensions
# Let's learn about list comprehensions! You are given three integers X, Y and Z representing the dimensions of a cuboid along with an integer N. You have to print a list of all possible coordinates given by (i, j, k) on a 3D grid where the sum of i+j+k is not equal to N. Here, 0<=i<=X; 0<=j<=Y; 0<=k<=Z;
# Sample Input 0
# 1
# 1
# 1
# 2
# Sample Output 0
# [[0, 0, 0], [0, 0, 1], [0, 1, 0], [1, 0, 0], [1, 1, 1]]
# Sample Input 1
# 2
# 2
# 2
# 2
# Sample Output 1
# [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 1, 2], [0, 2, 1], [0, 2, 2], [1, 0, 0], [1, 0, 2], [1, 1, 1], [1, 1, 2], [1, 2, 0], [1, 2, 1], [1, 2, 2], [2, 0, 1], [2, 0, 2], [2, 1, 0], [2, 1, 1], [2, 1, 2], [2, 2, 0], [2, 2, 1], [2, 2, 2]]

if __name__ == '__main__':
    x = int(input())
    y = int(input())
    z = int(input())
    n = int(input())

# coordinatesX = [i for i in range(x+1)]
# coordinatesY = [j for j in range(y+1)]
# coordinatesZ = [k for k in range(z+1)]
# coordinatesXYZ = []
# for elementX in coordinatesX:
#     for elementY in coordinatesY:
#         for elementZ in coordinatesZ:
#             if not elementX + elementY + elementZ == n:
#                 coordinatesXYZ.append([elementX, elementY, elementZ])
# print(coordinatesXYZ)

coordinates = [[i, j, k] for i in range(x+1) for j in range(y+1) for k in range(z+1) if i+j+k != n]
print(coordinates)

---------------------------------------------------------------------------

# Write a function
# We add a Leap Day on February 29, almost every four years. The leap day is an extra, or intercalary day and we add it to the shortest month of the year, February.
# In the Gregorian calendar three criteria must be taken into account to identify leap years:
# The year can be evenly divided by 4, is a leap year, unless:
#     The year can be evenly divided by 100, it is NOT a leap year, unless:
#         The year is also evenly divisible by 400. Then it is a leap year.

def is_leap(year):
    leap = False

    if year % 4 == 0:
        if year % 400 == 0:
            leap = True
        elif year % 100 == 0:
            leap = False
        else:
            leap = True

    return leap

year = int(raw_input())
print is_leap(year)

---------------------------------------------------------------------------

# Find the Runner-Up Score!
# Given the participants' score sheet for your University Sports Day, you are required to find the runner-up score. You are given n scores. Store them in a list and find the score of the runner-up.
# Sample Input 0
# 5
# 2 3 6 6 5
# Sample Output 0
# 5

if __name__ == '__main__':
    n = int(raw_input())
    arr = list(map(int, raw_input().split()))

if not arr:
    exit

# Solution 1
# arr.sort(reverse = True)
# arrSet = sorted(set(arr), reverse = True)
# if len(arrSet) > 1:
#     print(arrSet[1])

# Solution 2
# maxElement = max(arr)
# while maxElement in arr:
#     arr.remove(maxElement)
# if len(arr) > 0:
#     print(max(arr))

# Solution 3
arr.sort(reverse = True)
for index in range (1, len(arr)):
    if arr[index] != arr[index-1]:
        print(arr[index])
        break

---------------------------------------------------------------------------

# Nested Lists
# Given the names and grades for each student in a Physics class of N students, store them in a nested list and print the name(s) of any student(s) having the second lowest grade.
# Note: If there are multiple students with the same grade, order their names alphabetically and print each name on a new line.
# Sample Input 0
# 5
# Harry
# 37.21
# Berry
# 37.21
# Tina
# 37.2
# Akriti
# 41
# Harsh
# 39
# Sample Output 0
# Berry
# Harry


# Solution 1
# nameAndScoreList = []

# Solution 2
scoreAndNamesDict = {}

if __name__ == '__main__':
    for _ in range(int(input())):
        name = input()
        score = float(input())

        # Solution 1
        # nameAndScoreList.append({"name" : name, "score" : score})

        # Solution 2
        if scoreAndNamesDict.get(score):
            scoreAndNamesDict[score].append(name)
        else:
            scoreAndNamesDict[score] = [name]

# Solution 1
# if not nameAndScoreList:
#     exit

# def getScore(nameAndScoreDict):
#     return nameAndScoreDict["score"]

# nameAndScoreList.sort(key = getScore)

# secondLowestScore = None
# secondLowestScorers = []

# index = 1
# while index < len(nameAndScoreList):
#     if nameAndScoreList[index]["score"] != nameAndScoreList[index-1]["score"]:
#         secondLowestScore = nameAndScoreList[index]["score"]
#         break
# while secondLowestScore == nameAndScoreList[index]["score"]:
#     secondLowestScorers.append(nameAndScoreList[index]["name"])
#     index += 1

# for scorer in sorted(secondLowestScorers):
#     print(scorer)


# Solution 2
if len(scoreAndNamesDict) <= 1:
    exit

secondLowestScorers = sorted(scoreAndNamesDict.items())[1][1]
for name in sorted(secondLowestScorers):
    print(name)

---------------------------------------------------------------------------

# Lists
# Consider a list (list = []). You can perform the following commands:
# 1. insert i e: Insert integer e at position i.
# 2. print: Print the list.
# 3. remove e: Delete the first occurrence of integer e.
# 4. append e: Insert integer e at the end of the list.
# 5. sort: Sort the list.
# 6. pop: Pop the last element from the list.
# 7. reverse: Reverse the list.
# Initialize your list and read in the value of n followed by n lines of commands where each command will be of the 7 types listed above. Iterate through each command in order and perform the corresponding operation on your list.
# Sample Input 0
# 12
# insert 0 5
# insert 1 10
# insert 0 6
# print
# remove 6
# append 9
# append 1
# sort
# print
# pop
# reverse
# print
# Sample Output 0
# [6, 5, 10]
# [1, 5, 9, 10]
# [9, 5, 1]

if __name__ == '__main__':
    N = int(input())

listToProcess = list()
listToProcessName = "listToProcess"

for ctr in range(N):
    inputText = input().split(" ")
    inputCommand = inputText[0]
    inputArgs = inputText[1:]

    if inputCommand == "print":
        command = inputCommand + "(" + listToProcessName + ")"
    else:
        command = listToProcessName + "." + inputCommand + "(" + ", ".join(inputArgs) + ")"

    eval(command)

---------------------------------------------------------------------------

# Tuples
# Given an integer, n, and n space-separated integers as input, create a tuple, t, of those n integers. Then compute and print the result of hash(t).
# Note: hash() is one of the functions in the __builtins__ module, so it need not be imported.
# Sample Input 0
# 2
# 1 2
# Sample Output 0
# 3713081631934410656

if __name__ == '__main__':
    n = int(input())
    integer_list = map(int, input().split())

tupleVar = tuple(integer_list)
print(hash(tupleVar))

---------------------------------------------------------------------------

# Finding the percentage
# You have a record of N students. Each record contains the student's name, and their percent marks in Maths, Physics and Chemistry. The marks can be floating values. The user enters some integer N followed by the names and marks for N students. You are required to save the record in a dictionary data type. The user then enters a student's name. Output the average percentage marks obtained by that student, correct to two decimal places.
# Sample Input 0
# 3
# Krishna 67 68 69
# Arjun 70 98 63
# Malika 52 56 60
# Malika
# Sample Output 0
# 56.00

def average(numbersList):
    return sum(numbersList) / len(numbersList)

if __name__ == '__main__':
    n = int(input())
    student_marks = {}
    for _ in range(n):
        name, *line = input().split()
        scores = list(map(float, line))
        student_marks[name] = scores
    query_name = input()
    averageForQuery = average(student_marks[query_name])
    # print(round(averageForQuery, 2))
    # print("%.2f" % averageForQuery, " %.4f" % averageForQuery)
    # print("%.2f %.4f" % (averageForQuery, averageForQuery))
    print("%.2f" % averageForQuery)

# Solution from editorial
# d={}
# for i in range(int(raw_input())):
#     line=raw_input().split()
#     d[line[0]]=sum(map(float,line[1:]))/3

# print '%.2f' % d[raw_input()]

---------------------------------------------------------------------------

# sWAP cASE
# You are given a string and your task is to swap cases. In other words, convert all lowercase letters to uppercase letters and vice versa.
# For Example:
# Www.HackerRank.com → wWW.hACKERrANK.COM
# Pythonist 2 → pYTHONIST 2

def swap_case(s):
    swapped = str()
    for char in s:
        if char.isupper(): swapped += char.lower()
        else:              swapped += char.upper()
    return swapped

if __name__ == '__main__':
    s = input()
    result = swap_case(s)
    print(result)

# Solution from editorial
# import string
# print string.swapcase(raw_input())

---------------------------------------------------------------------------

# String Split and Join
# You are given a string. Split the string on a " " (space) delimiter and join using a - hyphen.
# Sample Input
# this is a string
# Sample Output
# this-is-a-string

def split_and_join(line):
    # write your code here
    listOfStrings = line.split(" ")
    listOfStringsJoined = "-".join(listOfStrings)
    return listOfStringsJoined

if __name__ == '__main__':
    line = input()
    result = split_and_join(line)
    print(result)

# Solution from editorial
# print "-".join(raw_input().split())

---------------------------------------------------------------------------

# Mutations
# Read a given string, change the character at a given index and then print the modified string.
# Sample Input
# abracadabra
# 5 k
# Sample Output
# abrackdabra

def mutate_string(string, position, character):
    # Solution 1
    # stringInList = list(string)
    # stringInList[position] = character
    # return "".join(stringInList)
    modifiedString = string[:position] + character + string[position+1:]
    return modifiedString

if __name__ == '__main__':
    s = input()
    i, c = input().split()
    s_new = mutate_string(s, int(i), c)
    print(s_new)

---------------------------------------------------------------------------

# String Validators
# You are given a string S.
# Your task is to find out if the string S contains: alphanumeric characters, alphabetical characters, digits, lowercase and uppercase characters.
# In the first line, print True if S has any alphanumeric characters. Otherwise, print False.
# In the second line, print True if S has any alphabetical characters. Otherwise, print False.
# In the third line, print True if S has any digits. Otherwise, print False.
# In the fourth line, print True if S has any lowercase characters. Otherwise, print False.
# In the fifth line, print True if S has any uppercase characters. Otherwise, print False.
# Sample Input
# qA2
# Sample Output
# True
# True
# True
# True
# True

if __name__ == '__main__':
    s = input()

# Solution 1
# stringValidationState = {
#     "hasAnyAlphaNumeric" : False,
#     "hasAnyAlphabetical" : False,
#     "hasAnyDigits" : False,
#     "hasAnyLowercase" : False,
#     "hasAnyUppercase" : False
# }

# for char in s:
#     if char.isalnum():
#         stringValidationState["hasAnyAlphaNumeric"] = True
#     if char.isalpha():
#         stringValidationState["hasAnyAlphabetical"] = True
#     if char.isdigit():
#         stringValidationState["hasAnyDigits"] = True
#     if char.islower():
#         stringValidationState["hasAnyLowercase"] = True
#     if char.isupper():
#         stringValidationState["hasAnyUppercase"] = True

# stringValidationStateList = [str(value) for value in stringValidationState.values()]
# print("\n".join(stringValidationStateList))

# Solution 2
hasAnyAlphabetical = any([char.isalpha() for char in s])
hasAnyDigits = any([char.isdigit() for char in s])
hasAnyLowercase = any([char.islower() for char in s])
hasAnyUppercase = any([char.isupper() for char in s])

print(hasAnyAlphabetical or hasAnyDigits)
print(hasAnyAlphabetical)
print(hasAnyDigits)
print(hasAnyLowercase)
print(hasAnyUppercase)

---------------------------------------------------------------------------

# Text Alignment
# You are given a partial code that is used for generating the HackerRank Logo of variable thickness.
# Your task is to replace the blank (______) with rjust, ljust or center.
# Sample Input

# 5
# Sample Output

#     H    
#    HHH   
#   HHHHH  
#  HHHHHHH 
# HHHHHHHHH
#   HHHHH               HHHHH             
#   HHHHH               HHHHH             
#   HHHHH               HHHHH             
#   HHHHH               HHHHH             
#   HHHHH               HHHHH             
#   HHHHH               HHHHH             
#   HHHHHHHHHHHHHHHHHHHHHHHHH   
#   HHHHHHHHHHHHHHHHHHHHHHHHH   
#   HHHHHHHHHHHHHHHHHHHHHHHHH   
#   HHHHH               HHHHH             
#   HHHHH               HHHHH             
#   HHHHH               HHHHH             
#   HHHHH               HHHHH             
#   HHHHH               HHHHH             
#   HHHHH               HHHHH             
#                     HHHHHHHHH 
#                      HHHHHHH  
#                       HHHHH   
#                        HHH    
#                         H 

#Replace all ______ with rjust, ljust or center.

thickness = int(input()) #This must be an odd number
c = 'H'

#Top Cone
for i in range(thickness):
    print((c*i).rjust(thickness-1)+c+(c*i).ljust(thickness-1))

#Top Pillars
for i in range(thickness+1):
    print((c*thickness).center(thickness*2)+(c*thickness).center(thickness*6))

# #Middle Belt
for i in range((thickness+1)//2):
    print((c*thickness*5).center(thickness*6))

# #Bottom Pillars
for i in range(thickness+1):
    print((c*thickness).center(thickness*2)+(c*thickness).center(thickness*6))

# #Bottom Cone
for i in range(thickness):
    print(((c*(thickness-i-1)).rjust(thickness)+c+(c*(thickness-i-1)).ljust(thickness)).rjust(thickness*6))

---------------------------------------------------------------------------

import textwrap

# Text Wrap
# You are given a string s and width w.
# Your task is to wrap the string into a paragraph of width w.
# Sample Input 0
# ABCDEFGHIJKLIMNOQRSTUVWXYZ
# 4
# Sample Output 0
# ABCD
# EFGH
# IJKL
# IMNO
# QRST
# UVWX
# YZ

# Solution 1
# import math
# def wrap(string, max_width):
#     # ceiling 1
#     # rows = len(string) // max_width
#     # if len(string) % max_width != 0:
#     #     rows += 1

#     # ceiling 2
#     rows = math.ceil(len(string) / max_width)

#     dividedString = [string[max_width*ctr:max_width*(ctr+1)] for ctr in range(rows+1)]
#      # dividedString = [string[i:i+max_width] for i in range(0, len(string), max_width)]
#     return "\n".join(dividedString)

# Solution 2
def wrap(string, max_width):
    # wrappedStringList = textwrap.wrap(string, max_width)
    return textwrap.fill(string, max_width)

if __name__ == '__main__':
    string, max_width = input(), int(input())
    result = wrap(string, max_width)
    print(result)

---------------------------------------------------------------------------

# Find a string
# In this challenge, the user enters a string and a substring. You have to print the number of times that the substring occurs in the given string. String traversal will take place from left to right, not from right to left.
# Sample Input
# ABCDCDC
# CDC
# Sample Output
# 2

def count_substring(string, sub_string):
    lastIndexPlusOne = len(string)
    startIndex = string.find(sub_string, 0, lastIndexPlusOne)

    totalCount = 0
    while startIndex != -1:
        totalCount += 1
        startIndex = string.find(sub_string, startIndex+1, lastIndexPlusOne)

    return totalCount

# From editorial, using regex
# import re
# a = raw_input()
# b = raw_input()
# match = re.findall('(?='+b+')',a)
# print len(match)

if __name__ == '__main__':
    string = input().strip()
    sub_string = input().strip()

    count = count_substring(string, sub_string)
    print(count)

---------------------------------------------------------------------------

# Enter your code here. Read input from STDIN. Print output to STDOUT

# Designer Door Mat
# Mr. Vincent works in a door mat manufacturing company. One day, he designed a new door mat with the following specifications:
#     Mat size must be N X M. (N is an odd natural number, and M is 3 times N.)
#     The design should have 'WELCOME' written in the center.
#     The design pattern should only use | . and - characters.
# Sample Designs
#     Size: 7 x 21
#     ---------.|.---------
#     ------.|..|..|.------
#     ---.|..|..|..|..|.---
#     -------WELCOME-------
#     ---.|..|..|..|..|.---
#     ------.|..|..|.------
#     ---------.|.---------
#     Size: 11 x 33
#     ---------------.|.---------------
#     ------------.|..|..|.------------
#     ---------.|..|..|..|..|.---------
#     ------.|..|..|..|..|..|..|.------
#     ---.|..|..|..|..|..|..|..|..|.---
#     -------------WELCOME-------------
#     ---.|..|..|..|..|..|..|..|..|.---
#     ------.|..|..|..|..|..|..|.------
#     ---------.|..|..|..|..|.---------
#     ------------.|..|..|.------------
#     ---------------.|.---------------

fillerChar = "-"
designChar = ".|."
welcomeChar = "WELCOME"

n, m = map(int, input().split())
rowsHalf = n // 2

# Solution 1

# designCharCount = 1
# for row in range(rowsHalf):
#     print((designChar * designCharCount).center(m, fillerChar))
#     designCharCount += 2

# print(welcomeChar.center(m, fillerChar))

# designCharCount -= 2
# for row in range(rowsHalf):
#     print((designChar * designCharCount).center(m, fillerChar))
#     designCharCount -= 2

# Solution 2
for row in range(rowsHalf):
    designCharToPrintInRow = designChar + (2 * (designChar * row))
    print(designCharToPrintInRow.center(m, fillerChar))

print(welcomeChar.center(m, fillerChar))

for row in range(rowsHalf):
    designCharToPrintInRow = designChar + (2 * (designChar * (rowsHalf - 1 - row)))
    print(designCharToPrintInRow.center(m, fillerChar))

# Solution 3
# sideCount = (m - len(designChar)) // 2

# for row in range(rowsHalf):
#     print((designChar * row).rjust(sideCount, fillerChar) +
#             designChar +
#             (designChar * row).ljust(sideCount, fillerChar))

# print(welcomeChar.center(m, fillerChar))

# for row in range(rowsHalf):
#     print((designChar * (rowsHalf - 1 - row)).rjust(sideCount, fillerChar) +
#             designChar +
#             (designChar * (rowsHalf - 1 - row)).ljust(sideCount, fillerChar))

---------------------------------------------------------------------------

#!/bin/python3

import math
import os
import random
import re
import sys

# Capitalize!
# You are asked to ensure that the first and last names of people begin with a capital letter in their passports. For example, alison heck should be capitalised correctly as Alison Heck.
# Sample Input
# chris alan
# Sample Output
# Chris Alan

# Complete the solve function below.
def solve(s):
    # Solution 1 - this is wrong for cases such as 12abc since it should still be 12abc but would be 12Abc here
    # return s.title()

    # Solution 2
    # if not s: return str()

    # sList = list(s)
    # sList[0] = sList[0].upper()
    # for ctr in range(1, len(sList)):
    #     if sList[ctr-1] == " ":
    #         sList[ctr] = sList[ctr].upper()
    # return "".join(sList)

    # Solution 3
    sList = s.split(" ")
    sListCapitalized = [word.capitalize() for word in sList]
    return " ".join(sListCapitalized)

if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    s = input()

    result = solve(s)

    fptr.write(result + '\n')

    fptr.close()

---------------------------------------------------------------------------

# Alphabet Rangoli
# You are given an integer, N. Your task is to print an alphabet rangoli of size N. (Rangoli is a form of Indian folk art based on creation of patterns.)
# Different sizes of alphabet rangoli are shown below:
# #size 3
# ----c----
# --c-b-c--
# c-b-a-b-c
# --c-b-c--
# ----c----
# #size 5
# --------e--------
# ------e-d-e------
# ----e-d-c-d-e----
# --e-d-c-b-c-d-e--
# e-d-c-b-a-b-c-d-e
# --e-d-c-b-c-d-e--
# ----e-d-c-d-e----
# ------e-d-e------
# --------e--------

def print_rangoli(size):
    maxChar = chr(size + 96)
    width = (4 * size) - 3 # from n + (n - 1) + (n + (n - 1) - 1)

    # Solution 1
    # for row in range(1, size + 1):
    #     chars = list()
    #     currentChar = maxChar
    #     for ctr in range(row):
    #         chars.append(currentChar)
    #         currentChar = chr(ord(currentChar) - 1)
    #     charsReverse = chars[:]
    #     charsReverse.reverse()
    #     charsReverse.pop(0)
    #     chars += charsReverse
    #     print("-".join(chars).center(width, "-"))
    # for row in range(1, size):
    #     chars = list()
    #     currentChar = maxChar
    #     for ctr in range(size - row):
    #         chars.append(currentChar)
    #         currentChar = chr(ord(currentChar) - 1)
    #     charsReverse = chars[:]
    #     charsReverse.reverse()
    #     charsReverse.pop(0)
    #     chars += charsReverse
    #     print("-".join(chars).center(width, "-"))

    # Solution 2
    for row in range(size):
        chars = list()
        currentChar = maxChar
        for ctr in range(row):
            chars.append(currentChar)
            currentChar = chr(ord(currentChar) - 1)
        chars += [currentChar] + chars[::-1]
        print("-".join(chars).center(width, "-"))
    for row in range(size - 1):
        chars = list()
        currentChar = maxChar
        for ctr in range(size - row - 2):
            chars.append(currentChar)
            currentChar = chr(ord(currentChar) - 1)
        chars += [currentChar] + chars[::-1]
        print("-".join(chars).center(width, "-"))

# Solution from editorial
# n = int(raw_input())
# for i in range(n):
#     s = "-".join(chr(ord('a')+n-j-1) for j in range(i+1))
#     print((s+s[::-1][1:]).center(n*4-3, '-'))

# for i in range(n-1):
#     s = "-".join(chr(ord('a')+n-j-1) for j in range(n-i-1))
#     print((s+s[::-1][1:]).center(n*4-3, '-'))

if __name__ == '__main__':
    n = int(input())
    print_rangoli(n)

---------------------------------------------------------------------------

# String Formatting
# Given an integer, n, print the following values for each integer i from 1 to n:
# 1. Decimal
# 2. Octal
# 3. Hexadecimal (capitalized)
# 4. Binary
# The four values must be printed on a single line in the order specified above for each i from 1 to n. Each value should be space-padded to match the width of the binary value of n.
# Sample Input
# 17
# Sample Output
#     1     1     1     1
#     2     2     2    10
#     3     3     3    11
#     4     4     4   100
#     5     5     5   101
#     6     6     6   110
#     7     7     7   111
#     8    10     8  1000
#     9    11     9  1001
#    10    12     A  1010
#    11    13     B  1011
#    12    14     C  1100
#    13    15     D  1101
#    14    16     E  1110
#    15    17     F  1111
#    16    20    10 10000
#    17    21    11 10001

def print_formatted(number):
    # your code goes here
    width = len(bin(number)[2:])

    for ctr in range(1, number + 1):
        octal = oct(ctr)[2:]
        hexadecimal = hex(ctr)[2:].upper()
        binary = bin(ctr)[2:]

        print(str(ctr).rjust(width),
                octal.rjust(width),
                hexadecimal.rjust(width),
                binary.rjust(width))

if __name__ == '__main__':
    n = int(input())
    print_formatted(n)

---------------------------------------------------------------------------

# Merge the Tools!
# Consider the following:
# - A string, s, of length n where s = c0c1...cn-1.
# - An integer, k, where k is a factor of n.
# We can split s into n/k subsegments where each subsegment, ti, consists of a contiguous block of k characters in s. Then, use each ti to create string ui such that:
# - The characters in ui are a subsequence of the characters in ti.
# - Any repeat occurrence of a character is removed from the string such that each character in ui occurs exactly once. In other words, if the character at some index j in ti occurs at a previous index <j in ti, then do not include the character in string ui.
# Given s and k, print n/k lines where each line i denotes string ui.
# Sample Input
# AABCAAADA
# 3
# Sample Output
# AB
# CA
# AD

import textwrap
from collections import OrderedDict

def merge_the_tools(string, k):
    # your code goes here
    tList = textwrap.wrap(string, k)
    uList = list()
    for t in tList:
        uniqueOrderedString = OrderedDict()
        for char in t:
            uniqueOrderedString[char] = None
        uList.append("".join(uniqueOrderedString.keys()))
    print("\n".join(uList))

if __name__ == '__main__':
    string, k = input(), int(input())
    merge_the_tools(string, k)

---------------------------------------------------------------------------

# The Minion Game
# Kevin and Stuart want to play the 'The Minion Game'.
# Game Rules
# Both players are given the same string, S.
# Both players have to make substrings using the letters of the string S.
# Stuart has to make words starting with consonants.
# Kevin has to make words starting with vowels.
# The game ends when both players have made all possible substrings.
# Scoring
# A player gets +1 point for each occurrence of the substring in the string S.
# Ex.
# S = BANANA
# Stuart
# {
#     'B': 1,
#     'BA': 1,
#     'BAN': 1,
#     'BANA': 1,
#     'BANAN': 1,
#     'BANANA': 1,
#     'N': 2,
#     'NA': 2,
#     'NAN': 1,
#     'NANA': 1
# }
# Total = 12

# Kevin
# {
#     'A': 3,
#     'AN': 2,
#     'ANA': 2,
#     'ANAN': 1,
#     'ANANA': 1
# }
# Total = 9

# Note :
# Vowels are only defined as AEIOU. In this problem, Y is not considered a vowel.
# WHAT THE HELL VOWEL ANG Y!!! 2019 9Sep 22 ko lang nalaman!!!

# Solution 1
# class Player:
#     def __init__(self, name, shouldStartWithVowel):
#         self.name = name
#         self.shouldStartWithVowel = shouldStartWithVowel
#         self.scoreDict = {} # not needed!
#         self.totalScore = 0

# vowels = {'A', 'a', 'E', 'e', 'I', 'i', 'O', 'o', 'U', 'u'}

# def isVowel(char):
#     return char in vowels

# def isConsonant(char):
#     if isVowel(char):
#         return False

#     charAsciiCode = ord(char)
#     return (charAsciiCode >= ord('A') and charAsciiCode <= ord('Z')) or \
#             (charAsciiCode >= ord('a') and charAsciiCode <= ord('z'))

# def processSubstrings(player, string):
#     for index in range(len(string)):
#         if (player.shouldStartWithVowel and not isVowel(string[index]) or \
#             (not player.shouldStartWithVowel and not isConsonant(string[index]))):
#                 continue
#         substring = str() # not needed!
#         for substringIndex in range(index, len(string)):
#             substring += string[substringIndex] # not needed!
#             if substring not in player.scoreDict.keys(): # not needed!
#                 player.scoreDict[substring] = 0 # not needed!
#             player.scoreDict[substring] += 1 # not needed!
#             player.totalScore += 1

# def minion_game(string):
#     # your code goes here
#     players = [Player("Stuart", False), Player("Kevin", True)]
#     processSubstrings(players[0], string)
#     processSubstrings(players[1], string)
#     players.sort(key = lambda player: player.totalScore, reverse = True)
#     if players[0].totalScore == players[1].totalScore:
#         print("Draw")
#     else:
#         print(players[0].name, players[0].totalScore)


# Solution 2
class Player:
    def __init__(self, name, shouldStartWithVowel):
        self.name = name
        self.shouldStartWithVowel = shouldStartWithVowel
        self.totalScore = 0

vowels = {'A', 'a', 'E', 'e', 'I', 'i', 'O', 'o', 'U', 'u'}

def isVowel(char):
    return char in vowels

def isConsonant(char):
    if isVowel(char):
        return False

    charAsciiCode = ord(char)
    return (charAsciiCode >= ord('A') and charAsciiCode <= ord('Z')) or \
            (charAsciiCode >= ord('a') and charAsciiCode <= ord('z'))

def processSubstrings(player, string):
    for index in range(len(string)):
        if (player.shouldStartWithVowel and not isVowel(string[index]) or \
            (not player.shouldStartWithVowel and not isConsonant(string[index]))):
                continue
        player.totalScore += len(string) - index

def minion_game(string):
    # your code goes here
    players = [Player("Stuart", False), Player("Kevin", True)]
    processSubstrings(players[0], string)
    processSubstrings(players[1], string)
    players.sort(key = lambda player: player.totalScore, reverse = True)
    if players[0].totalScore == players[1].totalScore:
        print("Draw")
    else:
        print(players[0].name, players[0].totalScore)

if __name__ == '__main__':
    s = input()
    minion_game(s)

---------------------------------------------------------------------------

#!/bin/python3

# Python If-Else
# Given an integer, n, perform the following conditional actions:
# If n is odd, print Weird
# If n is even and in the inclusive range of 2 to 5, print Not Weird
# If n is even and in the inclusive range of 6 to 20, print Weird
# If n is even and greater than 20, print Not Weird

import math
import os
import random
import re
import sys



if __name__ == '__main__':
    n = int(input().strip())

if n % 2 == 1 or n in range(6, 21) :
    print("Weird")
else:
    print("Not Weird")

---------------------------------------------------------------------------

# Print Function
# Read an integer N.
# Without using any string methods, try to print the following:
# 123...N
# Note that "..." represents the values in between

if __name__ == '__main__':
    n = int(input())

for ctr in range(1, n+1):
    print(ctr, end='')

---------------------------------------------------------------------------

# Arithmetic Operators
# Task
# Read two integers from STDIN and print three lines where:
# 1. The first line contains the sum of the two numbers.
# 2. The second line contains the difference of the two numbers (first - second).
# 3. The third line contains the product of the two numbers.
# Sample Input 0
# 3
# 2
# Sample Output 0
# 5
# 1
# 6

if __name__ == '__main__':
    a = int(raw_input())
    b = int(raw_input())

print(a+b)
print(a-b)
print(a*b)

---------------------------------------------------------------------------

# # Python: Division
# Task
# Read two integers and print two lines. The first line should contain integer division, a//b. The second line should contain float division,  a/b .
# You don't need to perform any rounding or formatting operations.
# Sample Input 0
# 4
# 3
# Sample Output 0
# 1
# 1.33333333333

from __future__ import division

if __name__ == '__main__':
    a = int(raw_input())
    b = int(raw_input())

print(a//b)
print(a/b)

---------------------------------------------------------------------------

# Loops
# Task
# Read an integer N. For all non-negative integers i<N, print i^2. See the sample for details.
# Sample Input 0
# 5
# Sample Output 0
# 0
# 1
# 4
# 9
# 16

if __name__ == '__main__':
    n = int(raw_input())

squares = [number**2 for number in range(0, n)]
for item in squares:
    print(item)

---------------------------------------------------------------------------

# You are given the firstname and lastname of a person on two different lines. Your task is to read them and print the following:
# Hello firstname lastname! You just delved into python.
# Sample Input 0
# Ross
# Taylor
# Sample Output 0
# Hello Ross Taylor! You just delved into python.

def print_full_name(a, b):
    message = "Hello " + a + " " + b + "! You just delved into python."
    print(message)

if __name__ == '__main__':
    first_name = raw_input()
    last_name = raw_input()
    print_full_name(first_name, last_name)

---------------------------------------------------------------------------

# Introduction to Sets
# Now, let's use our knowledge of sets and help Mickey.
# Ms. Gabriel Williams is a botany professor at District College. One day, she asked her student Mickey to compute the average of all the plants with distinct heights in her greenhouse.
# Formula used:
# Average = Sum of Distinct Heights / Total Number of Distinct Heights
# Sample Input
# 10
# 161 182 161 154 176 170 167 171 170 174
# Sample Output
# 169.375

def average(array):
    # your code goes here
    uniqueElements = set(array)
    return sum(uniqueElements) / len(uniqueElements)

if __name__ == '__main__':
    n = int(input())
    arr = list(map(int, input().split()))
    result = average(arr)
    print(result)

---------------------------------------------------------------------------

# Symmetric Difference
# Objective

# Today, we're learning about a new data type: sets.

# Concept

# If the inputs are given on one line separated by a space character, use split() to get the separate values in the form of a list:

# >> a = raw_input()
# 5 4 3 2
# >> lis = a.split()
# >> print (lis)
# ['5', '4', '3', '2']

# If the list values are all integer types, use the map() method to convert all the strings to integers.

# >> newlis = list(map(int, lis))
# >> print (newlis)
# [5, 4, 3, 2]

# Sets are an unordered bag of unique values. A single set contains values of any immutable data type.

# CREATING SETS

# >> myset = {1, 2} # Directly assigning values to a set
# >> myset = set()  # Initializing a set
# >> myset = set(['a', 'b']) # Creating a set from a list
# >> myset
# {'a', 'b'}


# MODIFYING SETS

# Using the add() function:

# >> myset.add('c')
# >> myset
# {'a', 'c', 'b'}
# >> myset.add('a') # As 'a' already exists in the set, nothing happens
# >> myset.add((5, 4))
# >> myset
# {'a', 'c', 'b', (5, 4)}

# Using the update() function:

# >> myset.update([1, 2, 3, 4]) # update() only works for iterable objects
# >> myset
# {'a', 1, 'c', 'b', 4, 2, (5, 4), 3}
# >> myset.update({1, 7, 8})
# >> myset
# {'a', 1, 'c', 'b', 4, 7, 8, 2, (5, 4), 3}
# >> myset.update({1, 6}, [5, 13])
# >> myset
# {'a', 1, 'c', 'b', 4, 5, 6, 7, 8, 2, (5, 4), 13, 3}

# REMOVING ITEMS

# Both the discard() and remove() functions take a single value as an argument and removes that value from the set. If that value is not present, discard() does nothing, but remove() will raise a KeyError exception.

# >> myset.discard(10)
# >> myset
# {'a', 1, 'c', 'b', 4, 5, 7, 8, 2, 12, (5, 4), 13, 11, 3}
# >> myset.remove(13)
# >> myset
# {'a', 1, 'c', 'b', 4, 5, 7, 8, 2, 12, (5, 4), 11, 3}


# COMMON SET OPERATIONS Using union(), intersection() and difference() functions.

# >> a = {2, 4, 5, 9}
# >> b = {2, 4, 11, 12}
# >> a.union(b) # Values which exist in a or b
# {2, 4, 5, 9, 11, 12}
# >> a.intersection(b) # Values which exist in a and b
# {2, 4}
# >> a.difference(b) # Values which exist in a but not in b
# {9, 5}

# The union() and intersection() functions are symmetric methods:

# >> a.union(b) == b.union(a)
# True
# >> a.intersection(b) == b.intersection(a)
# True
# >> a.difference(b) == b.difference(a)
# False

# Given 2 sets of integers, M and N, print their symmetric difference in ascending order. The term symmetric difference indicates those values that exist in either M or N but do not exist in both.
# Sample Input
# 4
# 2 4 5 9
# 4
# 2 4 11 12
# Sample Output
# 5
# 9
# 11
# 12
# Enter your code here. Read input from STDIN. Print output to STDOUT

input()
M = set(map(int, input().split()))
input()
N = set(map(int, input().split()))

# Solution 1
# Mdiff = M.difference(N)
# Ndiff = N.difference(M)

# sortedCombinedDiff = sorted(Mdiff.union(Ndiff))
# # print("\n".join([str(element) for element in sortedCombinedDiff]))
# print("\n".join(list(map(str, sortedCombinedDiff))))

# Solution 2
sortedCombinedDiff = sorted(M ^ N)
print("\n".join(map(str, sortedCombinedDiff)))

---------------------------------------------------------------------------

# # Enter your code here. Read input from STDIN. Print output to STDOUT

# Set .add()
# Rupal has a huge collection of country stamps. She decided to count the total number of distinct country stamps in her collection. She asked for your help. You pick the stamps one by one from a stack of N country stamps.
# Find the total number of distinct country stamps.
# Sample Input
# 7
# UK
# China
# USA
# France
# New Zealand
# UK
# France
# Sample Output
# 5

distinctCountries = set()
for _ in range(int(input())):
    distinctCountries.add(input())

print(len(distinctCountries))

---------------------------------------------------------------------------

# Set .discard(), .remove() & .pop()
# The first line contains integer n, the number of elements in the set s.
# The second line contains n space separated elements of set s. All of the elements are non-negative integers, less than or equal to 9.
# The third line contains integer N, the number of commands.
# The next N lines contains either pop, remove and/or discard commands followed by their associated value.
# Sample Input
# 9
# 1 2 3 4 5 6 7 8 9
# 10
# pop
# remove 9
# discard 9
# discard 8
# remove 7
# pop
# discard 6
# remove 5
# pop
# discard 5
# Sample Output
# 4

n = int(input())
s = set(map(int, input().split()))

for _ in range(int(input())):
    inputTextList = input().split()
    commandText = inputTextList[0]
    argumentsText = ",".join(inputTextList[1:])

    command = commandText + "(" + argumentsText + ")"
    eval("s." + command)

print(sum(s))

---------------------------------------------------------------------------

# Set .union() Operation
# The first line contains an integer, n, the number of students who have subscribed to the English newspaper.
# The second line contains n space separated roll numbers of those students.
# The third line contains b, the number of students who have subscribed to the French newspaper.
# The fourth line contains b space separated roll numbers of those students.
# Sample Input
# 9
# 1 2 3 4 5 6 7 8 9
# 9
# 10 1 2 3 11 21 55 6 8
# Sample Output
# 13

# Enter your code here. Read input from STDIN. Print output to STDOUT

input()
n = set(input().split())
input()
b = set(input().split())

# Solution 1
print(len(n) + len(b-n))

# Solution 2
# print(len(n.union(b)))

---------------------------------------------------------------------------

# Set .intersection() Operation
# The students of District College have subscriptions to English and French newspapers. Some students have subscribed only to English, some have subscribed only to French, and some have subscribed to both newspapers.
# You are given two sets of student roll numbers. One set has subscribed to the English newspaper, one set has subscribed to the French newspaper. Your task is to find the total number of students who have subscribed to both newspapers.
# Sample Input
# 9
# 1 2 3 4 5 6 7 8 9
# 9
# 10 1 2 3 11 21 55 6 8
# Sample Output
# 5

# Enter your code here. Read input from STDIN. Print output to STDOUT

input()
n = set(input().split())
input()
b = set(input().split())

# Solution 1
print(len(n) - len(n-b))

# Solution 2
# print(len(n.intersection(b)))

---------------------------------------------------------------------------

# Set .difference() Operation
# Students of District College have a subscription to English and French newspapers. Some students have subscribed to only the English newspaper, some have subscribed to only the French newspaper, and some have subscribed to both newspapers.
# You are given two sets of student roll numbers. One set has subscribed to the English newspaper, and one set has subscribed to the French newspaper. Your task is to find the total number of students who have subscribed to only English newspapers.
# Sample Input
# 9
# 1 2 3 4 5 6 7 8 9
# 9
# 10 1 2 3 11 21 55 6 8
# Sample Output
# 4

# Enter your code here. Read input from STDIN. Print output to STDOUT

input()
n = set(input().split())
input()
b = set(input().split())

print(len(n - b))
# print(len(n.difference(b)))

---------------------------------------------------------------------------

# Set .symmetric_difference() Operation
# Students of District College have subscriptions to English and French newspapers. Some students have subscribed to English only, some have subscribed to French only, and some have subscribed to both newspapers.
# You are given two sets of student roll numbers. One set has subscribed to the English newspaper, and one set has subscribed to the French newspaper. Your task is to find the total number of students who have subscribed to either the English or the French newspaper but not both.
# Sample Input
# 9
# 1 2 3 4 5 6 7 8 9
# 9
# 10 1 2 3 11 21 55 6 8
# Sample Output
# 8

# Enter your code here. Read input from STDIN. Print output to STDOUT

input()
n = set(input().split())
input()
b = set(input().split())

print(len(n-b) + len(b-n))
# print(len(n ^ b))
# print(len(n.symmetric_difference(b)))

---------------------------------------------------------------------------

# Set Mutations
# You are given a set A and N number of other sets. These N number of sets have to perform some specific mutation operations on set A.
# Your task is to execute those operations and print the sum of elements from set A.
# Sample Input
#  16
#  1 2 3 4 5 6 7 8 9 10 11 12 13 14 24 52
#  4
#  intersection_update 10
#  2 3 5 6 8 9 1 4 7 11
#  update 2
#  55 66
#  symmetric_difference_update 5
#  22 7 35 62 58
#  difference_update 7
#  11 22 35 55 58 62 66
# Sample Output
# 38

# Enter your code here. Read input from STDIN. Print output to STDOUT

input()
A = set(map(int, input().split()))

for _ in range(int(input())):
    commandText = input().split()[0]
    otherSet = set(map(int, input().split()))
    eval("A." + commandText + "(otherSet)")
    # eval("A." + commandText + "({" + ",".join(map(str, otherSet)) + "})")

print(sum(A))

---------------------------------------------------------------------------

# The Captain's Room
# Mr. Anant Asankhya is the manager at the INFINITE hotel. The hotel has an infinite amount of rooms.
# One fine day, a finite number of tourists come to stay at the hotel.
# The tourists consist of:
# - A Captain.
# - An unknown group of families consisting of K members per group where K != 1.
# The Captain was given a separate room, and the rest were given one room per group.
# Mr. Anant has an unordered list of randomly arranged room entries. The list consists of the room numbers for all of the tourists. The room numbers will appear K times per group except for the Captain's room.
# Mr. Anant needs you to help him find the Captain's room number.
# The total number of tourists or the total number of groups of families is not known to you.
# You only know the value of K and the room number list.

# Enter your code here. Read input from STDIN. Print output to STDOUT

# Solution 1 - did not work due to timeout
# input()
# roomNumberList = input().split()
# roomNumberSet = set(roomNumberList)

# for num in roomNumberSet:
#     numCount = roomNumberList.count(num)
#     if numCount == 1:
#         print(num)
#         break

# Solution 2 - worked, fuck why
# input()
# roomNumberList = input().split()
# roomNumberDict = dict()

# for num in roomNumberList:
#     if not num in roomNumberDict:
#         roomNumberDict[num] = 0
#     roomNumberDict[num] += 1

# print(sorted(roomNumberDict.items(), key = lambda element : element[1])[0][0])
# # print(sorted(roomNumberDict.values())[0])

# Solution 3 - worked
input()
roomNumberList = input().split()
choicesSet = set()
ignoreSet = set()

for roomNumber in roomNumberList:
    if roomNumber in ignoreSet: continue

    if roomNumber in choicesSet:
        choicesSet.remove(roomNumber)
        ignoreSet.add(roomNumber)
    else:
        choicesSet.add(roomNumber)

print(choicesSet.pop())

# Editorial by DOSHI
# The approach to solve this problem follows:
# 1. Store List: Store the list in a variable. Let roomList be the variable storing the list of room numbers.
# 2. Room Set: In the variable roomSet, store the set of roomList.
# 3. Sum Room Set and List: In the variable sumRoomSet and sumRoomList, store the summations of roomSet and roomList, respectively.
# 4. Multiply K and Subtract: Now, we multiply K with sumRoomSet, subtract the sumRoomList from it and then store the result in the variable temp. Therefore, temp = the Captain's room number * (K-1) .
# 5. Divide by K-1: Divide temp by (K-1) and store the result in the variable answer.
# 6. Output: Print answer.

# Set by DOSHI
# Problem Setter's code:

# K = int(raw_input())

# #Step 1
# roomList = map(int,raw_input().split())

# #Step 2
# roomSet = set(roomList)

# #Step 3
# sumRoomSet = sum(roomSet)
# sumRoomList = sum(roomList)

# # Step 4
# temp = sumRoomSet * K - sumRoomList

# # Step 5
# answer = temp / (K - 1)

# # Step 6
# print answer

# Explanation:
# K = 3
# list = 2 3 1 1 2 2 3 4 3 1
# set  = 1 2 3 4
# answer = 4

# sumOfList = 22
# sumOfSet  = 10

# sumOfSet is basically composed of:
#     (1+2+3) + (4)
# and we know that sumOfList is basically composed of:
#     ((1+2+3)+(1+2+3)+(1+2+3)) + (4)
#     or
#     ((1+2+3) * 3) + (4)
# because all elements will repeat K times except one (which is the captain's room, the answer to the problem)
# so if we multiply sumOfSet by K, it is basically:
#     10 * 3
#     or
#     ((1+2+3) + (4)) * 3
#     or
#     ((1+2+3) * 3) + ((4) * 3)
# now, if we subtract (sumOfSet * K) to sumOfList, we are basically removing all repeating elements (which are the rooms for the family groups)
#     ((1+2+3) * 3) + ((4) * 3)
#     -
#     ((1+2+3) * 3) + (4)
# with all repeating elements removed, we are now left with:
#     ((4) * 3)
#     -
#     (4)
#     which is equivalent to
#     ((4) + (4) + (4))
#     -
#     (4)
#     which is
#     ((4) + (4))
#     or
#     ((4) * 2)
# now since we previously multiplied the target answer by K and we know that the subtraction not just removed the repeating elements of family groups room but also removed one repeating instance of the captain's room caused by multiplication of the answer by K, so we just have to get the base answer by removing the remaining repeating instances caused by the multiplication which is K -1
#     ((4) + (4)) / (3 - 1)
#     which is
#     4

---------------------------------------------------------------------------

# Check Subset
# You are given two sets, A and B.
# Your job is to find whether set A is a subset of set B.
# Sample Input
# 3
# 5
# 1 2 3 5 6
# 9
# 9 8 5 6 3 2 1 4 7
# 1
# 2
# 5
# 3 6 5 4 1
# 7
# 1 2 3 5 6 8 9
# 3
# 9 8 2
# Sample Output
# True
# False
# False
# Enter your code here. Read input from STDIN. Print output to STDOUT

for _ in range(int(input())):
    input()
    A = set(input().split())
    input()
    B = set(input().split())
    print(A <= B)

---------------------------------------------------------------------------

# # Check Strict Superset
# # You are given a set A and n other sets.
# # Your job is to find whether set A is a strict superset of each of the N sets.
# Print True, if A is a strict superset of each of the N sets. Otherwise, print False.
# A strict superset has at least one element that does not exist in its subset.
# Sample Input 0
# 1 2 3 4 5 6 7 8 9 10 11 12 23 45 84 78
# 2
# 1 2 3 4 5
# 100 11 12
# Sample Output 0
# False

# Enter your code here. Read input from STDIN. Print output to STDOUT

A = set(input().split())
result = True

for _ in range(int(input())):
    N = set(input().split())
    if not A > N:
        result = False
        break

print(result)

---------------------------------------------------------------------------

# itertools.product()
# This tool computes the cartesian product of input iterables.
# It is equivalent to nested for-loops.
# For example, product(A, B) returns the same as ((x,y) for x in A for y in B).
# Sample Code
# >>> from itertools import product
# >>>
# >>> print list(product([1,2,3],repeat = 2))
# [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)]
# >>>
# >>> print list(product([1,2,3],[3,4]))
# [(1, 3), (1, 4), (2, 3), (2, 4), (3, 3), (3, 4)]
# >>>
# >>> A = [[1,2,3],[3,4,5]]
# >>> print list(product(*A))
# [(1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 3), (3, 4), (3, 5)]
# >>>
# >>> B = [[1,2,3],[3,4,5],[7,8]]
# >>> print list(product(*B))
# [(1, 3, 7), (1, 3, 8), (1, 4, 7), (1, 4, 8), (1, 5, 7), (1, 5, 8), (2, 3, 7), (2, 3, 8), (2, 4, 7), (2, 4, 8), (2, 5, 7), (2, 5, 8), (3, 3, 7), (3, 3, 8), (3, 4, 7), (3, 4, 8), (3, 5, 7), (3, 5, 8)]
# Task
# You are given a two lists A and B. Your task is to compute their cartesian product AXB
# Note: A and B are sorted lists, and the cartesian product's tuples should be output in sorted order.
# Sample Input
#  1 2
#  3 4
# Sample Output
#  (1, 3) (1, 4) (2, 3) (2, 4)

# Enter your code here. Read input from STDIN. Print output to STDOUT

from itertools import product

# A = list(map(int, input().split()))
# B = list(map(int, input().split()))
A = [int(element) for element in input().split()]
B = [int(element) for element in input().split()]
productList = list(product(A, B))

# print(" ".join(map(str, productList)))
print(" ".join(str(element) for element in productList))

# from editorial
# for item in product(A,B):
#     print(item,end=' ')

---------------------------------------------------------------------------

# itertools.permutations()
# itertools.permutations(iterable[, r])
# This tool returns successive r length permutations of elements in an iterable.
# If r is not specified or is None, then r defaults to the length of the iterable, and all possible full length permutations are generated.
# Permutations are printed in a lexicographic sorted order. So, if the input iterable is sorted, the permutation tuples will be produced in a sorted order.

# Sample Code

# >>> from itertools import permutations
# >>> print permutations(['1','2','3'])
# <itertools.permutations object at 0x02A45210>
# >>>
# >>> print list(permutations(['1','2','3']))
# [('1', '2', '3'), ('1', '3', '2'), ('2', '1', '3'), ('2', '3', '1'), ('3', '1', '2'), ('3', '2', '1')]
# >>>
# >>> print list(permutations(['1','2','3'],2))
# [('1', '2'), ('1', '3'), ('2', '1'), ('2', '3'), ('3', '1'), ('3', '2')]
# >>>
# >>> print list(permutations('abc',3))
# [('a', 'b', 'c'), ('a', 'c', 'b'), ('b', 'a', 'c'), ('b', 'c', 'a'), ('c', 'a', 'b'), ('c', 'b', 'a')]

# You are given a string S.
# Your task is to print all possible permutations of size k of the string in lexicographic sorted order.
# Sample Input
# HACK 2
# Sample Output
# AC
# AH
# AK
# CA
# CH
# CK
# HA
# HC
# HK
# KA
# KC
# KH
# Enter your code here. Read input from STDIN. Print output to STDOUT

from itertools import permutations

inputText = input().split()
sortedS = sorted(inputText[0])

for item in permutations(sortedS, int(inputText[1])):
    print("".join(item))
    # print(str(item).replace("(", "").replace("'", "").replace(",", "") \
    #         .replace(" ", "").replace(")", ""))

---------------------------------------------------------------------------

# itertools.combinations(iterable, r)
# This tool returns the r length subsequences of elements from the input iterable.

# Combinations are emitted in lexicographic sorted order. So, if the input iterable is sorted, the combination tuples will be produced in sorted order.
# Sample Code

# >>> from itertools import combinations
# >>>
# >>> print list(combinations('12345',2))
# [('1', '2'), ('1', '3'), ('1', '4'), ('1', '5'), ('2', '3'), ('2', '4'), ('2', '5'), ('3', '4'), ('3', '5'), ('4', '5')]
# >>>
# >>> A = [1,1,3,3,3]
# >>> print list(combinations(A,4))
# [(1, 1, 3, 3), (1, 1, 3, 3), (1, 1, 3, 3), (1, 3, 3, 3), (1, 3, 3, 3)]

# You are given a string S.
# Your task is to print all possible combinations, up to size k, of the string in lexicographic sorted order.

# Sample Input
# HACK 2
# Sample Output
# A
# C
# H
# K
# AC
# AH
# AK
# CH
# CK
# HK

# Enter your code here. Read input from STDIN. Print output to STDOUT

from itertools import combinations

inputText = input().split()
sortedS = sorted(inputText[0])

# Solution 1 - cleaner
# for count in range (1, int(inputText[1]) + 1):
#     for element in combinations(sortedS, count):
#         print("".join(element))

# Solution 2 - dirty!
print("\n".join( \
        ["".join(element) \
            for count in range(1, int(inputText[1]) + 1) \
            for element in combinations(sortedS, count)]))

---------------------------------------------------------------------------

# itertools.combinations_with_replacement(iterable, r)
# This tool returns r length subsequences of elements from the input iterable allowing individual elements to be repeated more than once.

# Combinations are emitted in lexicographic sorted order. So, if the input iterable is sorted, the combination tuples will be produced in sorted order.

# Sample Code

# >>> from itertools import combinations_with_replacement
# >>>
# >>> print list(combinations_with_replacement('12345',2))
# [('1', '1'), ('1', '2'), ('1', '3'), ('1', '4'), ('1', '5'), ('2', '2'), ('2', '3'), ('2', '4'), ('2', '5'), ('3', '3'), ('3', '4'), ('3', '5'), ('4', '4'), ('4', '5'), ('5', '5')]
# >>>
# >>> A = [1,1,3,3,3]
# >>> print list(combinations(A,2))
# [(1, 1), (1, 3), (1, 3), (1, 3), (1, 3), (1, 3), (1, 3), (3, 3), (3, 3), (3, 3)]

# Sample Code

# from itertools import combinations
# from itertools import combinations_with_replacement
# a=[1,2,3]
# print(list(combinations(a, 2)))
# print(list(combinations_with_replacement(a, 2)))

# Output
# [(1, 2), (1, 3), (2, 3)]
# [(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)]

# You are given a string S.
# Your task is to print all possible size k replacement combinations of the string in lexicographic sorted order.

# Sample Input
# HACK 2
# Sample Output
# AA
# AC
# AH
# AK
# CC
# CH
# CK
# HH
# HK
# KK

# Enter your code here. Read input from STDIN. Print output to STDOUT

from itertools import combinations_with_replacement

inputText = input().split()
sortedS = sorted(inputText[0])

for element in combinations_with_replacement(sortedS, int(inputText[1])):
    print("".join(element))

---------------------------------------------------------------------------

# Compress the String!

# In this task, we would like for you to appreciate the usefulness of the groupby() function of itertools . To read more about this function, Check this out .

# You are given a string S. Suppose a character 'c' occurs consecutively X times in the string. Replace these consecutive occurrences of the character 'c' with (X, c) in the string.

# Sample Input
# 1222311
# Sample Output
# (1, 1) (3, 2) (1, 3) (2, 1)

# Enter your code here. Read input from STDIN. Print output to STDOUT

from itertools import groupby

S = input()

if not S:
    exit

# Solution 1
# currentElement = S[0]
# currentElementCount = 0
# compressedList = list()

# for c in S:
#     if c == currentElement:
#         currentElementCount += 1
#     else:
#         # compressedList.append(tuple((currentElementCount, currentElement)))
#         print("({0}, {1})".format(currentElementCount, currentElement), end = " ")
#         currentElement = c
#         currentElementCount = 1

# print("({0}, {1})".format(currentElementCount, currentElement), end = " ")

for c, values in groupby(S):
    print("({0}, {1})".format(len(list(values)), c), end = " ")
    # from editorial
    # print(tuple([len(list(j)), i]) ,end = " ")

---------------------------------------------------------------------------

# Iterables and Iterators
# The input consists of three lines. The first line contains the integer N, denoting the length of the list. The next line consists of N space-separated lowercase English letters, denoting the elements of the list.
# The third and the last line of input contains the integer K, denoting the number of indices to be selected.

# Enter your code here. Read input from STDIN. Print output to STDOUT

from itertools import combinations
# from itertools import ifilter

input()
englishLetters = input().split()
K = int(input())

# Solution 1
# # allCombinations = combinations(englishLetters, K)
# allCombinations = list(combinations(englishLetters, K))
# combinationsWithLetterA = 0

# for element in filter(lambda comb: "a" in comb, allCombinations):
#     combinationsWithLetterA += 1

# print(combinationsWithLetterA / len(allCombinations))

# Solution 2
# combinationsWithLetterA = [current for current in combinations(englishLetters, K) if "a" in current]
# print(len(combinationsWithLetterA) / len(list(combinations(englishLetters, K))))

# Solution 3
total = 0
hasA = 0
for current in combinations(englishLetters, K):
    total += 1
    hasA += "a" in current
    # if "a" in current:
    #     hasA += 1
print(hasA / total)

---------------------------------------------------------------------------

# Class 2 - Find the Torsional Angle

# You are given four points A, B, C and D in a 3-dimensional Cartesian coordinate system. You are required to print the angle between the plane made by the points A, B, C and B, C, D in degrees(not radians). Let the angle be PHI.

# Cos(PHI) = (X.Y)/|X||Y| where X = AB x BC and Y = BC x CD.

# Here, X.Y means the dot product of X and Y, and AB x BC means the cross product of vectors AB and BC. Also, AB = B - A.

# Input Format
# One line of input containing the space separated floating number values of the X, Y and Z coordinates of a point.

# Output Format
# Output the angle correct up to two decimal places.

# Sample Input
# 0 4 5
# 1 7 6
# 0 5 9
# 1 7 2
# Sample Output
# 8.19

import math

class Points(object):
    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z

    def __sub__(self, no):
        resultX = self.x - no.x
        resultY = self.y - no.y
        resultZ = self.z - no.z
        return Points(resultX, resultY, resultZ)

    def dot(self, no):
        return (self.x * no.x) + (self.y * no.y) + (self.z * no.z)

    def cross(self, no):
        resultX = (self.y * no.z) - (self.z * no.y)
        resultY = (self.z * no.x) - (self.x * no.z)
        resultZ = (self.x * no.y) - (self.y * no.x)
        return Points(resultX, resultY, resultZ)
        
    def absolute(self):
        return pow((self.x ** 2 + self.y ** 2 + self.z ** 2), 0.5)

if __name__ == '__main__':
    points = list()
    for i in range(4):
        a = list(map(float, input().split()))
        points.append(a)

    a, b, c, d = Points(*points[0]), Points(*points[1]), Points(*points[2]), Points(*points[3])
    x = (b - a).cross(c - b)
    y = (c - b).cross(d - c)
    angle = math.acos(x.dot(y) / (x.absolute() * y.absolute()))

    print("%.2f" % math.degrees(angle))

-------------------------------------------------------------------------------

# collections.Counter()
# A counter is a container that stores elements as dictionary keys, and their counts are stored as dictionary values.
# Sample Code
# >>> from collections import Counter
# >>>
# >>> myList = [1,1,2,3,4,5,3,2,3,4,2,1,2,3]
# >>> print Counter(myList)
# Counter({2: 4, 3: 4, 1: 3, 4: 2, 5: 1})
# >>>
# >>> print Counter(myList).items()
# [(1, 3), (2, 4), (3, 4), (4, 2), (5, 1)]
# >>>
# >>> print Counter(myList).keys()
# [1, 2, 3, 4, 5]
# >>>
# >>> print Counter(myList).values()
# [3, 4, 4, 2, 1]

# Task
# Raghu is a shoe shop owner. His shop has X number of shoes.
# He has a list containing the size of each shoe he has in his shop.
# There are N number of customers who are willing to pay xi amount of money only if they get the shoe of their desired size.
# Your task is to compute how much money Raghu earned.

# Sample Input
# 10
# 2 3 4 5 6 8 7 6 5 18
# 6
# 6 55
# 6 45
# 6 55
# 4 40
# 18 60
# 10 50
# Sample Output
# 200

# Enter your code here. Read input from STDIN. Print output to STDOUT

from collections import Counter

input()
shoeSizes = list(map(int, input().split()))
shoeSizesCountDict = Counter(shoeSizes)

earnings = 0

for _ in range(int(input())):
    customerShoeSize, customerMoney = map(int, input().split())
    if customerShoeSize not in shoeSizesCountDict or \
        shoeSizesCountDict[customerShoeSize] == 0:
        continue

    shoeSizesCountDict[customerShoeSize] -= 1
    earnings += customerMoney

print(earnings)

-------------------------------------------------------------------------------

# DefaultDict Tutorial
# The defaultdict tool is a container in the collections class of Python. It's similar to the usual dictionary (dict) container, but the only difference is that a defaultdict will have a default value if that key has not been set yet. If you didn't use a defaultdict you'd have to check to see if that key exists, and if it doesn't, set it to what you want.
# For example:
# from collections import defaultdict
# d = defaultdict(list)
# d['python'].append("awesome")
# d['something-else'].append("not relevant")
# d['python'].append("language")
# for i in d.items():
#     print i
# This prints:
# ('python', ['awesome', 'language'])
# ('something-else', ['not relevant'])

# In this challenge, you will be given 2 integers, n and m. There are n words, which might repeat, in word group A. There are m words belonging to word group B. For each m words, check whether the word has appeared in group A or not. Print the indices of each occurrence of m in group A. If it does not appear, print -1.

# Sample Input
# 5 2
# a
# a
# b
# a
# b
# a
# b
# Sample Output
# 1 2 4
# 3 5

# Enter your code here. Read input from STDIN. Print output to STDOUT

from collections import defaultdict

n, m = map(int, input().split())

groupA = defaultdict(list)

for ctr in range(n):
    groupA[input()].append(str(ctr+1))
for ctr in range(m):
    groupBItem = input()
    if groupBItem in groupA:
        print(" ".join(groupA[groupBItem]))
    else:
        print(-1)

-------------------------------------------------------------------------------

# Collections.namedtuple()

# Basically, namedtuples are easy to create, lightweight object types.
# They turn tuples into convenient containers for simple tasks.
# With namedtuples, you don’t have to use integer indices for accessing members of a tuple.

# Example
# Code 01
# >>> from collections import namedtuple
# >>> Point = namedtuple('Point','x,y')
# >>> pt1 = Point(1,2)
# >>> pt2 = Point(3,4)
# >>> dot_product = ( pt1.x * pt2.x ) +( pt1.y * pt2.y )
# >>> print dot_product
# 11
# Code 02
# >>> from collections import namedtuple
# >>> Car = namedtuple('Car','Price Mileage Colour Class')
# >>> xyz = Car(Price = 100000, Mileage = 30, Colour = 'Cyan', Class = 'Y')
# >>> print xyz
# Car(Price=100000, Mileage=30, Colour='Cyan', Class='Y')
# >>> print xyz.Class
# Y

# Task
# Dr. John Wesley has a spreadsheet containing a list of student's IDs, marks, class and name.
# Your task is to help Dr. Wesley calculate the average marks of the students.
# Average = Sum of all marks / Total Students
# Note:
# 1. Columns can be in any order. IDs, marks, class and name can be written in any order in the spreadsheet.
# 2. Column names are ID, MARKS, CLASS and NAME. (The spelling and case type of these names won't change.)

# Sample Input

# TESTCASE 01
# 5
# ID         MARKS      NAME       CLASS     
# 1          97         Raymond    7         
# 2          50         Steven     4         
# 3          91         Adrian     9         
# 4          72         Stewart    5         
# 5          80         Peter      6   
# TESTCASE 02
# 5
# MARKS      CLASS      NAME       ID        
# 92         2          Calum      1         
# 82         5          Scott      2         
# 94         2          Jason      3         
# 55         8          Glenn      4         
# 82         2          Fergus     5

# Sample Output

# TESTCASE 01
# 78.00
# TESTCASE 02
# 81.00

# Enter your code here. Read input from STDIN. Print output to STDOUT

from collections import namedtuple

numberOfStudents = int(input())
StudentData = namedtuple("StudentData", " ".join(input().split()))

sumOfallMarks = 0

for _ in range(numberOfStudents):
    student = StudentData(*(input().split()))
    sumOfallMarks += int(student.MARKS)

print(round(sumOfallMarks / numberOfStudents, 2))
# from editorial
# print(sum(float(student(*input().strip().split()).MARKS) for _ in range(N))/N)

-------------------------------------------------------------------------------

# Collections.OrderedDict()

# An OrderedDict is a dictionary that remembers the order of the keys that were inserted first. If a new entry overwrites an existing entry, the original insertion position is left unchanged.

# Example
# Code
# >>> from collections import OrderedDict
# >>>
# >>> ordinary_dictionary = {}
# >>> ordinary_dictionary['a'] = 1
# >>> ordinary_dictionary['b'] = 2
# >>> ordinary_dictionary['c'] = 3
# >>> ordinary_dictionary['d'] = 4
# >>> ordinary_dictionary['e'] = 5
# >>>
# >>> print ordinary_dictionary
# {'a': 1, 'c': 3, 'b': 2, 'e': 5, 'd': 4}
# >>>
# >>> ordered_dictionary = OrderedDict()
# >>> ordered_dictionary['a'] = 1
# >>> ordered_dictionary['b'] = 2
# >>> ordered_dictionary['c'] = 3
# >>> ordered_dictionary['d'] = 4
# >>> ordered_dictionary['e'] = 5
# >>>
# >>> print ordered_dictionary
# OrderedDict([('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)])

# Enter your code here. Read input from STDIN. Print output to STDOUT

# Solution 1
from collections import OrderedDict

itemAndSellPriceCountDict = OrderedDict()

for _ in range(int(input())):
    itemName, priceInStr = input().rsplit(" ", 1)
    if itemName in itemAndSellPriceCountDict:
        itemAndSellPriceCountDict[itemName] += int(priceInStr)
    else:
        itemAndSellPriceCountDict[itemName] = int(priceInStr)

print("\n".join(["{0} {1}".format(key, value) for key, value in itemAndSellPriceCountDict.items()]))

-------------------------------------------------------------------------------

# collections.deque()

# A deque is a double-ended queue. It can be used to add or remove elements from both ends.

# Deques support thread safe, memory efficient appends and pops from either side of the deque with approximately the same O(1) performance in either direction.

# Click on the link to learn more about deque() methods.
# Click on the link to learn more about various approaches to working with deques: Deque Recipes.

# Example

# Code
# >>> from collections import deque
# >>> d = deque()
# >>> d.append(1)
# >>> print d
# deque([1])
# >>> d.appendleft(2)
# >>> print d
# deque([2, 1])
# >>> d.clear()
# >>> print d
# deque([])
# >>> d.extend('1')
# >>> print d
# deque(['1'])
# >>> d.extendleft('234')
# >>> print d
# deque(['4', '3', '2', '1'])
# >>> d.count('1')
# 1
# >>> d.pop()
# '1'
# >>> print d
# deque(['4', '3', '2'])
# >>> d.popleft()
# '4'
# >>> print d
# deque(['3', '2'])
# >>> d.extend('7896')
# >>> print d
# deque(['3', '2', '7', '8', '9', '6'])
# >>> d.remove('2')
# >>> print d
# deque(['3', '7', '8', '9', '6'])
# >>> d.reverse()
# >>> print d
# deque(['6', '9', '8', '7', '3'])
# >>> d.rotate(3)
# >>> print d
# deque(['8', '7', '3', '6', '9'])

from collections import deque

d = deque()

for _ in range(int(input())):
    inputOperation = input().split()
    command = inputOperation[0]
    arguments = "".join(inputOperation[1:])
    eval("d." + command + "(" + arguments + ")")

# print(" ".join([str(item) for item in d]))
# print(" ".join(map(str, d)))
for item in d:
    print(item, end = " ")

-------------------------------------------------------------------------------

# You are given n words. Some words may repeat. For each word, output its number of occurrences. The output order should correspond with the input order of appearance of the word. See the sample input/output for clarification.

# Note: Each input line ends with a "\n" character.

# Input Format
# The first line contains the integer, n.
# The next n lines each contain a word.

# Output Format
# Output 2 lines.
# On the first line, output the number of distinct words from the input.
# On the second line, output the number of occurrences for each distinct word according to their appearance in the input.

# Sample Input
# 4
# bcdef
# abcdefg
# bcde
# bcdef
# Sample Output
# 3
# 2 1 1

from collections import OrderedDict

wordDict = OrderedDict()

for _ in range(int(input())):
    word = input()
    # if word in wordDict:
    #     wordDict[word] += 1
    # else:
    #     wordDict[word] = 1
    wordDict.setdefault(word, 0)
    wordDict[word] += 1

print(len(wordDict))
# print(" ".join(map(str, wordDict.values())))
print(*(wordDict.values()))

-------------------------------------------------------------------------------

#!/bin/python3

# Company Logo

# A newly opened multinational brand has decided to base their company logo on the three most common characters in the company name. They are now trying out various combinations of company names and logos based on this condition. Given a string , which is the company name in lowercase letters, your task is to find the top three most common characters in the string.
# - Print the three most common characters along with their occurrence count.
# - Sort in descending order of occurrence count.
# - If the occurrence count is the same, sort the characters in alphabetical order.
# For example, according to the conditions described above,
#     GOOGLE would have it's logo with the letters G, O, E.

# Sample Input 0
# aabbbccde
# Sample Output 0
# b 3
# a 2
# c 2

from collections import Counter

# Solution 1
charAndCountDict = sorted(Counter(input()).items(), key = lambda item : (item[0]), reverse = False)
charAndCountDict = sorted(charAndCountDict, key = lambda item : (item[1]), reverse = True)

# for ctr in range(3):
#     print(*(charAndCountDict[ctr]))
for element in charAndCountDict[:3]:
    # print(element[0], element[1])
    print(*(element))



# from editorial 1

# from collections import Counter
# from operator import itemgetter

# for item in (sorted(sorted(Counter(raw_input()).items()), key = itemgetter(1), reverse = True)[:3]):
#     print item[0], item[1]



# from editorial 2

# from collections import Counter

# for letter, counts in sorted(Counter(raw_input()).most_common(),key = lambda x:(-x[1],x[0]))[:3]:
#     print letter, counts

-------------------------------------------------------------------------------

# Piling Up!

# There is a horizontal row of n cubes. The length of each cube is given. You need to create a new vertical pile of cubes. The new pile should follow these directions: if cube_i is on top of cube_j then sideLength_j >= sideLength_i.

# When stacking the cubes, you can only pick up either the leftmost or the rightmost cube each time. Print "Yes" if it is possible to stack the cubes. Otherwise, print "No". Do not print the quotation marks.

# Sample Input
# 2
# 6
# 4 3 2 1 3 4
# 3
# 1 3 2
# Sample Output
# Yes
# No

# Explanation
# In the first test case, pick in this order: left -4, right -4, left -3, right -3, left -2, right -1.
# In the second test case, no order gives an appropriate arrangement of vertical cubes. 3 will always come after either 1 or 2.

# Enter your code here. Read input from STDIN. Print output to STDOUT



# Solution 1 - more efficient than Solution 2 which uses deque
for _ in range(int(input())):
    result = "Yes"

    input()
    cubes = list(map(int, input().split()))

    it = 1;
    while it < len(cubes):
        if cubes[it] > cubes[it-1]:
            break
        it += 1
    while it < len(cubes):
        if cubes[it] < cubes[it-1]:
            result = "No"
            break
        it += 1

    print(result)



# Solution 2 - less efficient than Solution 1

# from collections import deque

# for _ in range(int(input())):
#     result = "Yes"

#     numberOfCubes = int(input())
#     cubes = deque(map(int, input().split()))
#     previousNum = max(cubes)

#     while numberOfCubes > 0:
#         leftIndex = 0
#         rightIndex = numberOfCubes - 1

#         if cubes[leftIndex] >= cubes[rightIndex]:
#             poppedSide = cubes.popleft()
#         else:
#             poppedSide = cubes.pop()

#         if poppedSide > previousNum:
#             result = "No"
#             break

#         previousNum = poppedSide
#         numberOfCubes -= 1

#     print(result)

-------------------------------------------------------------------------------

# Exceptions

# Exceptions
# Errors detected during execution are called exceptions.

# Examples:

# ZeroDivisionError
# This error is raised when the second argument of a division or modulo operation is zero.

# >>> a = '1'
# >>> b = '0'
# >>> print int(a) / int(b)
# >>> ZeroDivisionError: integer division or modulo by zero

# ValueError
# This error is raised when a built-in operation or function receives an argument that has the right type but an inappropriate value.

# >>> a = '1'
# >>> b = '#'
# >>> print int(a) / int(b)
# >>> ValueError: invalid literal for int() with base 10: '#'
# To learn more about different built-in exceptions click here.

# Handling Exceptions
# The statements try and except can be used to handle selected exceptions. A try statement may have more than one except clause to specify handlers for different exceptions.

# #Code
# try:
#     print 1/0
# except ZeroDivisionError as e:
#     print "Error Code:",e

# Output
# Error Code: integer division or modulo by zero

# Task
# You are given two values a and b.
# Perform integer division and print a/b.

# Sample Input
# 3
# 1 0
# 2 $
# 3 1
# Sample Output
# Error Code: integer division or modulo by zero
# Error Code: invalid literal for int() with base 10: '$'
# 3

for _ in range(int(input())):
    a, b = input().split()
    try:
        print(int(a) // int(b))
    except ZeroDivisionError as e:
        print("Error Code:", e)
    except ValueError as e:
        print("Error Code:", e)

-------------------------------------------------------------------------------

# Incorrect Regex

# You are given a string S.
# Your task is to find out whether S is a valid regex or not.

# Sample Input
# 2
# .*\+
# .*+
# Sample Output
# True
# False

from re import search

for _ in range(int(input())):
    dummy = "dummy"
    try:
        search(input(), dummy)
    except Exception:
        print("False")
    else:
        print("True")

# From editorial
# import re
# for i in range(int(raw_input())):
#     try:
#         s = raw_input()
#         re.compile(s)
#     except:
#         print False
#         continue
#     print True

-------------------------------------------------------------------------------

import math

class Complex(object):
    def __init__(self, real, imaginary):
        self.real = real
        self.imaginary = imaginary

    def __add__(self, no):
        realNum = self.real + no.real
        imaginaryNum = self.imaginary + no.imaginary

        # print(Complex(realNum, imaginaryNum))
        return Complex(realNum, imaginaryNum)

    def __sub__(self, no):
        realNum = self.real - no.real
        imaginaryNum = self.imaginary - no.imaginary

        result = Complex(realNum, imaginaryNum).__str__()
        # print(result)
        return result

    def __mul__(self, no):
        realNum = (self.real * no.real) - (self.imaginary * no.imaginary)
        imaginaryNum = (self.real * no.imaginary) + (self.imaginary * no.real)

        # print(Complex(realNum, imaginaryNum).__str__())
        return Complex(realNum, imaginaryNum).__str__()

    def __truediv__(self, no):
        useBuiltinComplex1 = complex(self.real, self.imaginary)
        useBuiltinComplex2 = complex(no.real, no.imaginary)
        useBuiltinComplex3 = useBuiltinComplex1 / useBuiltinComplex2

        # print(Complex(useBuiltinComplex3.real, useBuiltinComplex3.imag))
        return Complex(useBuiltinComplex3.real, useBuiltinComplex3.imag)

    def mod(self):
        useBuiltinComplex = complex(self.real, self.imaginary)

        # print(Complex(abs(useBuiltinComplex), 0))
        return Complex(abs(useBuiltinComplex), 0)

    def __str__(self):
        if self.imaginary == 0:
            result = "%.2f+0.00i" % (self.real)
        elif self.real == 0:
            if self.imaginary >= 0:
                result = "0.00+%.2fi" % (self.imaginary)
            else:
                result = "0.00-%.2fi" % (abs(self.imaginary))
        elif self.imaginary > 0:
            result = "%.2f+%.2fi" % (self.real, self.imaginary)
        else:
            result = "%.2f-%.2fi" % (self.real, abs(self.imaginary))
        return result

if __name__ == '__main__':
    c = map(float, input().split())
    d = map(float, input().split())
    x = Complex(*c)
    y = Complex(*d)
    print(*map(str, [x+y, x-y, x*y, x/y, x.mod(), y.mod()]), sep='\n')

# from editorial (div and mod only since the rest are same with my solution)
# def __div__(self, no):
#     x = float(no.real ** 2 + no.imaginary ** 2)
#     y = self * Complex(no.real, -no.imaginary)
#     real = y.real / x
#     imaginary = y.imaginary / x
#     return Complex(real, imaginary)

# def mod(self):
#     real = math.sqrt(self.real ** 2 + self.imaginary ** 2)
#     return Complex(real, 0)

-------------------------------------------------------------------------------

# Zipped!

# zip([iterable, ...])

# This function returns a list of tuples. The ith tuple contains the ith element from each of the argument sequences or iterables.

# If the argument sequences are of unequal lengths, then the returned list is truncated to the length of the shortest argument sequence.

# Sample Code
# >>> print zip([1,2,3,4,5,6],'Hacker')
# [(1, 'H'), (2, 'a'), (3, 'c'), (4, 'k'), (5, 'e'), (6, 'r')]
# >>>
# >>> print zip([1,2,3,4,5,6],[0,9,8,7,6,5,4,3,2,1])
# [(1, 0), (2, 9), (3, 8), (4, 7), (5, 6), (6, 5)]
# >>>
# >>> A = [1,2,3]
# >>> B = [6,5,4]
# >>> C = [7,8,9]
# >>> X = [A] + [B] + [C]
# >>>
# >>> print zip(*X)
# [(1, 6, 7), (2, 5, 8), (3, 4, 9)]

# Task
# The National University conducts an examination of N students in X subjects.
# Your task is to compute the average scores of each student.
# Average Score = Sum of scores obtained in all subjects by a student / Total number of subjects

# The format for the general mark sheet is:
# Student ID → ___1_____2_____3_____4_____5__
# Subject 1   |  89    90    78    93    80
# Subject 2   |  90    91    85    88    86
# Subject 3   |  91    92    83    89    90.5
#             |______________________________
# Average        90    91    82    90    85.5

# Sample Input
# 5 3
# 89 90 78 93 80
# 90 91 85 88 86
# 91 92 83 89 90.5
# Sample Output
# 90.0
# 91.0
# 82.0
# 90.0
# 85.5

_, numOfSubjects = map(int, input().split())
allSubjectScores = list()

for _ in range(numOfSubjects):
    currentSubjectScores = list(map(float, input().split()))
    allSubjectScores.append(currentSubjectScores)

for currentStudent in zip(*allSubjectScores):
    scoresSum = sum(currentStudent)
    print(scoresSum / numOfSubjects)

-------------------------------------------------------------------------------

# Input()

# input()
# In Python 2, the expression input() is equivalent to eval(raw _input(prompt)).
# Code
# >>> input()
# 1+2
# 3
# >>> company = 'HackerRank'
# >>> website = 'www.hackerrank.com'
# >>> input()
# 'The company name: '+company+' and website: '+website
# 'The company name: HackerRank and website: www.hackerrank.com'

# Solution 1
# x, k = map(int, input().split())
# expression = input().replace("x", str(x))
# result = eval(expression)
# print(result == k)

# Solution 2
x, k = map(int, input().split())
expression = input()
result = eval(expression)
print(result == k)

-------------------------------------------------------------------------------

# Python Evaluation

# The eval() expression is a very powerful built-in function of Python. It helps in evaluating an expression. The expression can be a Python statement, or a code object.

# For example:
# >>> eval("9 + 5")
# 14
# >>> x = 2
# >>> eval("x + 3")
# 5

# Here, eval() can also be used to work with Python keywords or defined functions and variables. These would normally be stored as strings.

# For example:
# >>> type(eval("len"))
# <type 'builtin_function_or_method'>
# Without eval()
# >>> type("len")
# <type 'str'>

# Sample Input
# print(2 + 3)
# Sample Output
# 5

eval(input())

-------------------------------------------------------------------------------

# # Any or All

# # any()
# # This expression returns True if any element of the iterable is true.
# # If the iterable is empty, it will return False.

# # Code
# # >>> any([1>0,1==0,1<0])
# # True
# # >>> any([1<0,2<1,3<2])
# # False

# # all()
# # This expression returns True if all of the elements of the iterable are true. If the iterable is empty, it will return True.

# # Code
# # >>> all(['a'<'b','b'<'c'])
# # True
# # >>> all(['a'<'b','c'<'b'])
# # False

# Task
# You are given a space separated list of integers. If all the integers are positive, then you need to check if any integer is a palindromic integer.

# Print True if all the conditions of the problem statement are satisfied. Otherwise, print False.

# Sample Input
# 5
# 12 9 61 5 14
# Sample Output
# True

# Solution 1
# Version 1
# def isPalindrome(text):
#     try:
#         text = str(text)
#     except Exception as e:
#         print("isPalindrome", text, type(e), e)

#     leftIndex = 0
#     rightIndex = len(text) - 1
#     while leftIndex < rightIndex:
#         if text[leftIndex] != text[rightIndex]:
#             return False
#         leftIndex += 1
#         rightIndex -= 1

#     return True

# Version 2
# def isPalindrome(text):
#     try:
#         text = str(text)
#     except Exception as e:
#         print("isPalindrome", text, type(e), e)

#     for leftIndex, rightIndex in zip(range(0, len(text)), reversed(range(0, len(text)))):
#         if text[leftIndex] != text[rightIndex]:
#             return False
#         leftIndex += 1
#         rightIndex -= 1

#     return True

# Version 3
# from itertools import takewhile
# def isPalindrome(text):
#     try:
#         text = str(text)
#     except Exception as e:
#         print("isPalindrome", text, type(e), e)

#     for leftIndex, rightIndex in takewhile(lambda x: x[0] < x[1], zip(range(0, len(text)), reversed(range(0, len(text))))):
#         if text[leftIndex] != text[rightIndex]:
#             return False
#         leftIndex += 1
#         rightIndex -= 1

#     return True

# isNegativePresent = False
# isPalindromePresent = False

# input()
# for num in map(int, input().split()):
#     if num < 0:
#         isNegativePresent = True
#         break
#     isPalindromePresent |= isPalindrome(num)

# print(not isNegativePresent and isPalindromePresent)

# Solution 2
# Version 1
def isPalindrome(text):
    try:
        text = str(text)
    except Exception as e:
        print("isPalindrome", text, type(e), e)

    leftIndex = 0
    rightIndex = len(text) - 1
    while leftIndex < rightIndex:
        if text[leftIndex] != text[rightIndex]:
            return False
        leftIndex += 1
        rightIndex -= 1

    return True

input()
numbers = list(map(int, input().split()))
print(all([num >= 0 for num in numbers]) and \
        any([isPalindrome(num) for num in numbers]))

# from editorial
# n = input();s = map(int, raw_input().split())
# print [False,any(map(lambda x: str(x) == str(x)[::-1], s))][all(map(lambda x: x>0, s))]

-------------------------------------------------------------------------------

# ginortS

# You are given a string S.
# S contains alphanumeric characters only.

# Your task is to sort the string  in the following manner:
# All sorted lowercase letters are ahead of uppercase letters.
# All sorted uppercase letters are ahead of digits.
# All sorted odd digits are ahead of sorted even digits.

# Sample Input
# Sorting1234
# Sample Output
# ginortS1324

text = sorted(input())
lowercase = str()
uppercase = str()
odd = str()
even = str()
for char in text:
    if char.islower():
        lowercase += char
    elif char.isupper():
        uppercase += char
    elif int(char) % 2:
        odd += char
    else:
        even += char
print(lowercase + uppercase + odd + even)

# from editorial
# Solution 1

# from __future__ import print_function

# def func(x):
#     if x.isalpha():
#         if x.isupper():
#             return (ord(x)-ord('A'))
#         else:
#             return (ord(x)-ord('a'))-30
#     else:
#         if int(x) % 2 == 0:
#             return 60+int(x)
#         else:
#             return 30+int(x)

# s = raw_input()
# map(lambda x: print(x,end=''),(sorted(s,key = func)))

# Solution 2
# Without using key:

# from __future__ import print_function

# upper = []
# lower = []
# even = []
# odd = []

# def separator(a):

#     if a.isalpha():
#         if a.isupper():
#             upper.append(a)
#         else:
#             lower.append(a)
#     else:
#         if int(a)%2 == 0:
#             even.append(a)
#         else:
#             odd.append(a)
#     return

# map(separator,raw_input())

# upper.sort()
# lower.sort()
# even.sort()
# odd.sort()

# t = lower+upper+odd+even
# map(lambda x: print(x,end=''),t)

-------------------------------------------------------------------------------

# Map and Lambda Function

# Let's learn some new Python concepts! You have to generate a list of the first N fibonacci numbers, 0 being the first number. Then, apply the map function and a lambda expression to cube each fibonacci number and print the list.

# Concept

# The map() function applies a function to every member of an iterable and returns the result. It takes two parameters: first, the function that is to be applied and secondly, the iterables.
# Let's say you are given a list of names, and you have to print a list that contains the length of each name.
# >> print (list(map(len, ['Tina', 'Raj', 'Tom'])))
# [4, 3, 3]

# Lambda is a single expression anonymous function often used as an inline function. In simple words, it is a function that has only one line in its body. It proves very handy in functional and GUI programming.

# >> sum = lambda a, b, c: a + b + c
# >> sum(1, 2, 3)
# 6

# Note:
# Lambda functions cannot use the return statement and can only have a single expression. Unlike def, which creates a function and assigns it a name, lambda creates a function and returns the function itself. Lambda can be used inside lists and dictionaries.

# Sample Input
# 5
# Sample Output
# [0, 1, 1, 8, 27]

cube = lambda x: x**3 # complete the lambda function

def fibonacci(n):
    # return a list of fibonacci numbers
    x = 0
    y = 1
    sequence = list()
    for _ in range(n):
        sequence.append(x)
        x, y = y, x + y
    return sequence

if __name__ == '__main__':
    n = int(input())
    print(list(map(cube, fibonacci(n))))

# from editorial
# # Enter your code here. Read input from STDIN. Print output to STDOUT
# N = int(raw_input())
# A = [0,1]
# for i in range(2,N): A.append(A[i-1]+A[i-2])
# print map(lambda a: a*a*a,A)[:N]

-------------------------------------------------------------------------------

from fractions import Fraction
from functools import reduce

# Reduce Function

# Given a list of rational numbers,find their product.

# Concept
# The reduce() function applies a function of two arguments cumulatively on a list of objects in succession from left to right to reduce it to one value. Say you have a list, say [1,2,3] and you have to find its sum.

# >>> reduce(lambda x, y : x + y,[1,2,3])
# 6

# You can also define an initial value. If it is specified, the function will assume initial value as the value given, and then reduce. It is equivalent to adding the initial value at the beginning of the list. For example:

# >>> reduce(lambda x, y : x + y, [1,2,3], -3)
# 3

# >>> from fractions import gcd
# >>> reduce(gcd, [2,4,8], 3)
# 1

# Sample Input 0
# 3
# 1 2
# 3 4
# 10 6
# Sample Output 0
# 5 8
# Explanation 0
# Required product is 1/2 * 3/4 * 10/6 = 5/8

def product(fracs):
    # t = # complete this line with a reduce statement
    t = reduce(lambda x, y : x * y, fracs)
    return t.numerator, t.denominator

if __name__ == '__main__':
    fracs = []
    for _ in range(int(input())):
        fracs.append(Fraction(*map(int, input().split())))
    result = product(fracs)
    print(*result)

-------------------------------------------------------------------------------

# Validating Email Addresses With a Filter

# You are given an integer N followed by N email addresses. Your task is to print a list containing only valid email addresses in lexicographical order.

# Valid email addresses must follow these rules:
# - It must have the username@websitename.extension format type.
# - The username can only contain letters, digits, dashes and underscores.
# - The website name can only have letters and digits.
# - The maximum length of the extension is 3.

# Concept

# A filter takes a function returning True or False and applies it to a sequence, returning a list of only those members of the sequence where the function returned True. A Lambda function can be used with filters.

# Let's say you have to make a list of the squares of integers from 0 to 9 (both included).

# >> l = list(range(10))
# >> l = list(map(lambda x:x*x, l))

# Now, you only require those elements that are greater than 10 but less than 80.

# >> l = list(filter(lambda x: x > 10 and x < 80, l))

# Sample Input
# 3
# lara@hackerrank.com
# brian-23@hackerrank.com
# britts_54@hackerrank.com
# Sample Output
# ['brian-23@hackerrank.com', 'britts_54@hackerrank.com', 'lara@hackerrank.com']

def fun(s):
    # return True if s is a valid email, else return False
    USER_AND_WEB_SEPARATOR = "@"
    USERNAME_ALLOWED_SYMBOLS = ["-", "_"]

    usernameAndWeb = s.split(USER_AND_WEB_SEPARATOR)
    if len(usernameAndWeb) != 2 or "" in usernameAndWeb:
        return False

    for char in usernameAndWeb[0]:
        if not char.isalnum() and char not in USERNAME_ALLOWED_SYMBOLS:
            return False

    websiteNameAndExtension = usernameAndWeb[1].split(".")
    if len(websiteNameAndExtension) != 2:
        return False

    return websiteNameAndExtension[0].isalnum() and\
            len(websiteNameAndExtension[1]) <= 3

def filter_mail(emails):
    return list(filter(fun, emails))

if __name__ == '__main__':
    n = int(input())
    emails = []
    for _ in range(n):
        emails.append(input())

filtered_emails = filter_mail(emails)
filtered_emails.sort()
print(filtered_emails)

# from editorial
# import re
# lst = list()
# for i in range(int(raw_input())):
#     lst.append(raw_input())
# print sorted(list(filter(lambda x: re.search(r'^[\w\d-]+@[A-Za-z0-9]+\.\w?\w?\w$',x),lst)))

-------------------------------------------------------------------------------

import sys
import xml.etree.ElementTree as etree

# XML 1 - Find the Score

# You are given a valid XML document, and you have to print its score. The score is calculated by the sum of the score of each element. For any element, the score is equal to the number of attributes it has.

# Input Format
# The first line contains N, the number of lines in the XML document.
# The next N lines follow containing the XML document.

# Output Format
# Output a single line, the integer score of the given XML document.

# Sample Input
# 6
# <feed xml:lang='en'>
#     <title>HackerRank</title>
#     <subtitle lang='en'>Programming challenges</subtitle>
#     <link rel='alternate' type='text/html' href='http://hackerrank.com/'/>
#     <updated>2013-12-25T12:00:00</updated>
# </feed>
# Sample Output
# 5
# Explanation
# The feed and subtitle tag have one attribute each - lang.
# The title and updated tags have no attributes.
# The link tag has three attributes - rel, type and href.
# So, the total score is 1+1+3=5.

# There may be any level of nesting in the XML document. To learn about XML parsing, refer here.
# NOTE: In order to parse and generate an XML element tree, use the following code:
# >> import xml.etree.ElementTree as etree
# >> tree = etree.ElementTree(etree.fromstring(xml))
# Here, XML is the variable containing the string.
# Also, to find the number of keys in a dictionary, use the len function:
# >> dicti = {'0': 'This is zero', '1': 'This is one'}
# >> print (len(dicti))
# 2

# Solution 1 - Failing on nested XML
# def get_attr_number(node):
#     # your code goes here
#     total = 0
#     total += len(node.attrib)
#     # print(total)
#     # for child in node:
#     #     if child.attrib:
#     #         print(child.attrib)
#     return sum([len(child.attrib) for child in node if child.attrib]) + (len(node.attrib) if node.attrib else 0)
#     # print(a)

# Solution 2
from collections import deque
def get_attr_number(node):
    # print("Not including root and nested children")
    # for child1 in node:
    #     print("\t", child1.tag, child1.attrib)
    # print("Including root and nested children")
    # for child2 in node.iter():
    #     print("\t", child2.tag, child2.attrib)
    #     # print(child2.tag, (child2.attrib if child2.attrib else "None!"))
    # print("End")
    attrCount = 0
    allNodes = deque([node])
    while len(allNodes) > 0:
        currentNode = allNodes.popleft()
        allNodes.extend([child for child in currentNode])
        attrCount += len(currentNode.attrib)
    return attrCount

if __name__ == '__main__':
    sys.stdin.readline()
    xml = sys.stdin.read()
    tree = etree.ElementTree(etree.fromstring(xml))
    root = tree.getroot()
    print(get_attr_number(root))

# from discussions
# return sum([len(elem.items()) for elem in tree.iter())
# return sum([len(elem.items()) for elem in tree.iter())
# return sum(len(elem.attrib) for elem in root.iter())

-------------------------------------------------------------------------------

import xml.etree.ElementTree as etree

# XML2 - Find the Maximum Depth

# You are given a valid XML document, and you have to print the maximum level of nesting in it. Take the depth of the root as 0.

# Input Format
# The first line contains N, the number of lines in the XML document.
# The next N lines follow containing the XML document.

# Output Format
# Output a single line, the integer value of the maximum level of nesting in the XML document.

# Sample Input
# 6
# <feed xml:lang='en'>
#     <title>HackerRank</title>
#     <subtitle lang='en'>Programming challenges</subtitle>
#     <link rel='alternate' type='text/html' href='http://hackerrank.com/'/>
#     <updated>2013-12-25T12:00:00</updated>
# </feed>
# Sample Output
# 1
# Explanation
# Here, the root is a feed tag, which has depth of 0.
# The tags title, subtitle, link and updated all have a depth of 1.
# Thus, the maximum depth is 1.

# from collections import deque
maxdepth = 0
def depth(elem, level):
    global maxdepth
    # your code goes here
    # print(type(elem))
    allNodes = set([(elem, 0)])
    # print(len(allNodes))
    # for item in allNodes:
    #     print(item)
    # print("start")
    while len(allNodes) > 0:
        currentNode = allNodes.pop()
        # print(currentNode, end = "###\t")

        currentDepth = currentNode[1] + 1
        # print(currentDepth)
        if len(currentNode[0]) > 0 and currentDepth > maxdepth:
            maxdepth = currentDepth

        allNodes.update([(child, currentDepth) for child in currentNode[0]])
        # for child in currentNode[0]:
        #     allNodes.add((child, currentDepth))
    # print(allNodes)

if __name__ == '__main__':
    n = int(input())
    xml = ""
    for i in range(n):
        xml =  xml + input() + "\n"
    tree = etree.ElementTree(etree.fromstring(xml))
    depth(tree.getroot(), -1)
    print(maxdepth)

# editorial recursion, bad!
# def depth(elem, level):
#     global maxdepth
#     level += 1
#     if (maxdepth < level):
#         maxdepth = level
#     for child in elem:
#         depth(child, level)

-------------------------------------------------------------------------------

# Detect Floating Point Number

# You are given a string N.
# Your task is to verify that N is a floating point number.

# In this task, a valid float number must satisfy all of the following requirements:
# > Number can start with +, - or . symbol.
# For example:
#     OK - +4.50
#     OK - -1.0
#     OK - .5
#     OK - -.7
#     OK - +.4
#     NOK - -+4.5
# > Number must contain at least  decimal value.
# For example:
#     NOK - 12.
#     OK - 12.0
# > Number must have exactly one . symbol.
# > Number must not give any exceptions when converted using float(N).

# Sample Input 0
# 4
# 4.0O0
# -1.00
# +4.54
# SomeRandomStuff
# Sample Output 0
# False
# True
# True
# False

for _ in range(int(input())):
    inputNumber = input()
    try:
        float(inputNumber)
    except Exception:
        print("False")
        continue
    if inputNumber.find(".") == -1 or\
        len(inputNumber[inputNumber.find("."):]) == 1:
        print("False")
        continue
    print("True")

--------------------------------------------------------------------

# Minimum Operations

# You are given a number N. You have to find the number of operations required to reach N from 0. You have 2 operations available:

# Double the number
# Add one to the number
# Input:
# The first line of input contains an integer T denoting the number of test cases. Then T test cases follow. Each test case contains an integer N.

# Output:
# For each test case, in a new line, print the minimum number of operations required to reach N from 0.

# Constraints:
# 1<=T<=100
# 1<=N<=104

# Example:
# Input:
# 2
# 8
# 7
# Input:
# 4
# 5

# Explanation:
# Testcase1:
# Input  : N = 8
# Output : 4
# 0 + 1 = 1, 1 + 1 = 2, 2 * 2 = 4, 4 * 2 = 8
# Testcase2:
# Input  : N = 7
# Output : 5
# 0 + 1 = 1, 1 + 1 = 2, 1 + 2 = 3, 3 * 2 = 6, 6 + 1 = 7

#code

for _ in range(int(input())):
    num = int(input())
    ctr = 0
    while (num != 0):
        if num % 2 == 0:
            num /= 2
        else:
            num -= 1
        ctr = ctr + 1
    print(ctr)

--------------------------------------------------------------------

# Find the element that appears once in sorted array

# Given a sorted array A, size N, of integers; every element appears twice except for one. Find that element that appears once in array.

# Input:
# The first line of input consists of T, the number of the test cases. T testcases follow. Each testcase contains two lines of input.
# The first line of each test case contains the size of the array, and the second line has the elements of the array.

# Output:
# For each testcase, in a new line, print the number that appears only once in the array.

# Constraints:
# 1 ≤ T ≤ 100
# 1 ≤ N ≤ 107
# 0 ≤ A[i] ≤ 1017

# Example:
# Input:
# 1
# 11
# 1 1 2 2 3 3 4 50 50 65 65
# Output:
# 4

#code

# Solution 1
# for _ in range(int(input())):
#     length = int(input())
#     numbers = list(map(int, input().split()))
#     for index in range(0, length, 2):
#         if index + 1 == length or numbers[index] != numbers[index+1]:
#             print(numbers[index])
#             break

# Solution 2
for _ in range(int(input())):
    length = int(input())
    numbers = list(map(int, input().split()))
    
    start = 0
    end = length - 1
    while start <= end:
        middle = int((start + end) / 2)
        # print("start", start, "middle", middle, "end", end)

        isEqualToNext = middle + 1 < length and numbers[middle] == numbers[middle + 1]
        isEqualToPrev = middle - 1 >= 0 and numbers[middle] == numbers[middle - 1]

        if middle % 2 == 0:
            if isEqualToNext: start = middle + 2
            elif isEqualToPrev: end = middle - 2
            else:
                print(numbers[middle])
                break
        else:
            if isEqualToNext: end = middle - 1
            elif isEqualToPrev: start = middle + 1
            else:
                print(numbers[middle])
                break

--------------------------------------------------------------------

# Search in a Rotated Array

# Given a sorted and rotated array A of N distinct elements which is rotated at some point, and given an element K. The task is to find the index of the given element K in the array A.

# Input:
# The first line of the input contains an integer T, denoting the total number of test cases. Then T test cases follow. Each test case consists of three lines. First line of each test case contains an integer N denoting the size of the given array. Second line of each test case contains N space separated integers denoting the elements of the array A. Third line of each test case contains an integer K denoting the element to be searched in the array.

# Output:
# Corresponding to each test case, output the index of the element found in the array.  If element is not present, then output -1.

# Constraints:
# 1 ≤ T ≤ 100
# 1 ≤ N ≤ 107
# 0 ≤ Ai ≤ 108
# 1 ≤ K ≤ 108

# Example:
# Input:
# 3
# 9
# 5 6 7 8 9 10 1 2 3
# 10
# 3
# 3 1 2
# 1
# 4
# 3 5 1 2
# 6

# Output:
# 5
# 1
# -1

# Explanation:
# Testcase 1: 10 is found at index 5.

#code

for _ in range(int(input())):
    size = int(input())
    array = list(map(int, input().split()))
    target = int(input())

    isInLeftPartition = lambda number : number >= array[0]
    isInRightPartition = lambda number : number <= array[size - 1]
    isFound = False
    start = 0
    end = size - 1
    while start <= end:
        middle = (start + end) // 2
        if array[middle] == target:
            isFound = True
            print(middle)
            break
        elif isInLeftPartition(array[middle]):
            if isInLeftPartition(target) and target < array[middle]:
                end = middle - 1
            else:
                start = middle + 1
        else: # isInRightPartition(array[middle])
            if isInRightPartition(target) and target > array[middle]:
                start = middle + 1
            else:
                end = middle - 1
    if not isFound:
        print(-1)

--------------------------------------------------------------------

# Trees: Is This a Binary Search Tree?

""" Node is defined as
class node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None
"""
def checkBST(root):
    lastValue = [None]
    return checkBSTImpl(root, lastValue)
    
def checkBSTImpl(root, lastValue):
    if not root:
        return True
    if not checkBSTImpl(root.left, lastValue):
        return False
    if lastValue[0] and lastValue[0] >= root.data:
        return False

    lastValue[0] = root.data
    return checkBSTImpl(root.right, lastValue)

-------------------------------------------------------------------------------

Python

-------------------------------------------------------------------------------

#!/bin/python3

# 3D Surface Area

# Madison, is a little girl who is fond of toys. Her friend Mason works in a toy manufacturing
# factory . Mason has a 2D board A of size H x W with H rows and W columns. The board is divided
# into cells of size 1x1 with each cell indicated by it's coordinate (i, j). The cell (i, j) has
# an integer Aij written on it. To create the toy Mason stacks Aij number of cubes of size 1x1x1
# on the cell (i, j).

# Given the description of the board showing the values of Aij and that the price of the toy is
# equal to the 3d surface area find the price of the toy.

# Sample Input 0
# 1 1
# 1
# Sample Output 0
# 6

# Sample Input 1
# 3 3
# 1 3 4
# 2 2 3
# 1 2 4
# Sample Output 1
# 60

import math
import os
import random
import re
import sys

# Complete the surfaceArea function below.
def surfaceArea(boardCubes):
    # Surfaces: top and bottom, front and back, left side and right side
    result = 0

    for rowIndex, rowCubes in enumerate(boardCubes):
        for columnIndex, cubeStack in enumerate(rowCubes):
            # top and bottom
            TOP_AND_BOTTOM_AREA = 2
            if cubeStack > 0: result += TOP_AND_BOTTOM_AREA

            # back
            backHeight = 0 if rowIndex == 0 \
                            else boardCubes[rowIndex - 1][columnIndex]
            backArea = cubeStack - backHeight
            if backArea > 0: result += backArea

            # front
            frontHeight = 0 if rowIndex == (len(boardCubes) - 1) \
                            else boardCubes[rowIndex + 1][columnIndex]
            frontArea = cubeStack - frontHeight
            if frontArea > 0: result += frontArea

            # left side
            leftSideHeight = 0 if columnIndex == 0 \
                                else boardCubes[rowIndex][columnIndex - 1]
            leftSideArea = cubeStack - leftSideHeight
            if leftSideArea > 0: result += leftSideArea

            # right side
            rightSideHeight = 0 if columnIndex == (len(rowCubes) - 1) \
                                else boardCubes[rowIndex][columnIndex + 1]
            rightSideArea = cubeStack - rightSideHeight
            if rightSideArea > 0: result += rightSideArea

    return result

if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    HW = input().split()

    H = int(HW[0])

    W = int(HW[1])

    A = []

    for _ in range(H):
        A.append(list(map(int, input().rstrip().split())))

    result = surfaceArea(A)

    fptr.write(str(result) + '\n')

    fptr.close()

-------------------------------------------------------------------------------

Python

-------------------------------------------------------------------------------

#!/bin/python3

import os

"""
The Bomberman Game

Bomberman lives in a rectangular grid. Each cell in the grid either contains a bomb or nothing at all.

Each bomb can be planted in any cell of the grid but once planted, it will detonate after exactly 3 seconds. Once a bomb detonates, it's destroyed — along with anything in its four neighboring cells. This means that if a bomb detonates in cell (i, j), any valid cells (i+-1, j) and (i, j+-1) are cleared. If there is a bomb in a neighboring cell, the neighboring bomb is destroyed without detonating, so there's no chain reaction.

Bomberman is immune to bombs, so he can move freely throughout the grid. Here's what he does:
1. Initially, Bomberman arbitrarily plants bombs in some of the cells, the initial state.
2. After one second, Bomberman does nothing.
3. After one more second, Bomberman plants bombs in all cells without bombs, thus filling the whole grid with bombs. No bombs detonate at this point.
4. After one more second, any bombs planted exactly three seconds ago will detonate. Here, Bomberman stands back and observes.
5. Bomberman then repeats steps 3 and 4 indefinitely.

Note that during every second Bomberman plants bombs, the bombs are planted simultaneously (i.e., at the exact same moment), and any bombs planted at the same time will detonate at the same time.

Given the initial configuration of the grid with the locations of Bomberman's first batch of planted bombs, determine the state of the grid after N seconds.

For example, if the initial grid looks like:
...
.O.
...
it looks the same after the first second. After the second second, Bomberman has placed all his charges:
OOO
OOO
OOO
At the third second, the bomb in the middle blows up, emptying all surrounding cells:
O.O
...
O.O

Sample Input
6 7 3
.......
...O...
....O..
.......
OO.....
OO.....
Sample Output
OOO.OOO
OO...OO
OOO...O
..OO.OO
...OOOO
...OOOO
Explanation
The initial state of the grid is:
.......
...O...
....O..
.......
OO.....
OO.....
Bomberman spends the first second doing nothing, so this is the state after 1 second:
.......
...O...
....O..
.......
OO.....
OO.....
Bomberman plants bombs in all the empty cells during his second second, so this is the state after 2 seconds:
OOOOOOO
OOOOOOO
OOOOOOO
OOOOOOO
OOOOOOO
OOOOOOO
In his third second, Bomberman sits back and watches all the bombs he planted 3 seconds ago detonate. This is the final state after 3 seconds:
OOO.OOO
OO...OO
OOO...O
..OO.OO
...OOOO
...OOOO

uno
    0 init
        ...
        .0.
        ...
    1 wait
        ...
        .1.
        ...
    2 fill
        000
        020
        000
    3 boom+wait
        1.1
        ...
        1.1
    4 fill
        202
        000
        202
    5 boom+wait
        ...
        .1.
        ...
    6 fill
        000
        020
        000
dos
    0 init
        ...
        0..
        0..
    1 wait
        ...
        1..
        1..
    2 fill
        000
        200
        200
    3 boom+wait
        .11
        ..1
        ..1
    4 fill
        022
        002
        002
    5 boom+wait
        ...
        1..
        1..
    6 fill
        000
        200
        200
tres
    0 init
        0..
        ..0
        ...
    1 wait
        1..
        ..1
        ...
    2 fill
        200
        002
        000
    3 boom+wait
        ...
        ...
        11.
    4 fill
        000
        000
        220
    5 boom+wait
        111
        ..1
        ...
    6 fill
        222
        002
        000
    7 boom+wait
        ...
        ...
        11.
cuatro
    0 init
        .0.
        0..
        0.0
    1 wait
        .1.
        1..
        1.1
    2 fill
        020
        200
        202
    3 boom+wait
        ...
        ...
        ...
    4 fill
        000
        000
        000
    5 wait
        111
        111
        111
    6 fill
        222
        222
        222
    7 boom+wait
        ...
        ...
        ...
cinco
    0 init
        .0..
        ..0.
        ....
        0...
    1 wait
        .1..
        ..1.
        ....
        1...
    2 fill
        0200
        0020
        0000
        2000
    3 boom+wait
        ...1
        1...
        .1.1
        ..11
    4 fill
        0002
        2000
        0202
        0022
    5 boom+wait
        .1..
        ..1.
        ....
        1...
    6 fill
        0200
        0020
        0000
        2000
seis
    0 init
        0.0
        .0.
        0.0
    1 wait
        1.1
        .1.
        1.1
    2 fill
        202
        020
        202
    3 boom+wait
        ...
        ...
        ...
    4 fill
        000
        000
        000
    5 wait
        111
        111
        111
    6 fill
        222
        222
        222
    7 boom+wait
        ...
        ...
        ...

Flow
                            -------------
                            |           |
                            V           |
Seconds | 0    --> 1    --> 2    --> 3 --
State   | Init     Wait     Fill     Explode + Wait

Solutions
1. Get the value for seconds 3 and 5 by reading the initial data. Second #3 should have the
   "negated" initial data (so the bombs remaining here should be those that cannot be detonated
   by the initial bombs) while the second #5 should exactly be the initial data with the
   possibility of some additional bombs on coordinates that doesn't matter if became a bomb in the
   initial data. The idea here is that the filling-up + explosion + filling-up + ... is just a
   cycle of the exact same repeating values. Why you say? Because if bomb x (part of initial bombs)
   wasn't able to destroy bomb y (part of the filled-up), then the same goes for bomb y because
   bomb y will also not be able to destroy the refilled-up bomb x, and the cycle just continues.
2. Manually do the tracking of bombs state per second. Change 0 to 1 to 2 to 3 to period(.). For a
   bit of dynamic programming to prevent recalculation, store the result per second in a key value
   pair where the value is the result at that second while the key is the hashed value of the
   result. Storing a "hash key" to see if the same result already appeared before is better than
   manually rechecking through looping iterations on each coordinate for every new result against
   previous results.
"""

# Complete the bomberMan function below.
NO_BOMB = "."
BOMB = "O"

class BombCycleGenerator:
    def __init__(self, grid, rowSize, colSize, seconds):
        self.grid = grid
        self.rowSize = rowSize
        self.colSize = colSize
        self.seconds = seconds

    def isValidRow(self, row):
        return row >= 0 and row < self.rowSize

    def isValidCol(self, col):
        return col >= 0 and col < self.colSize

    def isBombOrIsNeigborWithABomb(self, row, col):
        if not self.isValidRow(row) or not self.isValidCol(col):
            return False

        return self.grid[row][col] == BOMB\
            or (self.isValidRow(row - 1) and self.grid[row - 1][col] == BOMB)\
            or (self.isValidRow(row + 1) and self.grid[row + 1][col] == BOMB)\
            or (self.isValidCol(col - 1) and self.grid[row][col - 1] == BOMB)\
            or (self.isValidCol(col + 1) and self.grid[row][col + 1] == BOMB)

    def areAllNeighborsBombOrNeighborWithABomb(self, row, col):
        return (not self.isValidRow(row - 1) or self.isBombOrIsNeigborWithABomb(row - 1, col))\
            and (not self.isValidRow(row + 1) or self.isBombOrIsNeigborWithABomb(row + 1, col))\
            and (not self.isValidCol(col - 1) or self.isBombOrIsNeigborWithABomb(row, col - 1))\
            and (not self.isValidCol(col + 1) or self.isBombOrIsNeigborWithABomb(row, col + 1))

    def generateTheOddNumberedCycleValues(self):
        """
        All even numbers will just have everything as a bomb, while on odd numbers there would be
        an alternating 2 bomb sets. The reason for this is because if the 1st bomb set cannot
        destroy the 2nd bomb set, then the same goes with the 2nd bomb set as that 2nd bomb set
        would also not be able to destroy the 1st bomb set. The goal here is to find that 2
        versions of alternating bomb sets. If you would try it, there might seem to be 3 different
        bomb sets but if you observe carefully, 2 of those 3 are actually just identical when
        detonated.
        """
        # cycleValue1 = [[ch for ch in grid[ctr]] for ctr in range(len(grid))]
        # cycleValue1 = [[ch for ch in gridRow] for gridRow in grid]
        cycleValue1 = [list(gridRow) for gridRow in self.grid]
        cycleValue2 = [list(gridRow) for gridRow in self.grid]

        for row, gridRow in enumerate(self.grid):
            for col, ch in enumerate(gridRow):
                if ch == NO_BOMB:
                    if self.isBombOrIsNeigborWithABomb(row, col):
                        if self.areAllNeighborsBombOrNeighborWithABomb(row, col):
                            cycleValue1[row][col] = BOMB
                    else:
                        cycleValue2[row][col] = BOMB
                else:
                    cycleValue2[row][col] = NO_BOMB

        cycleValue1 = ["".join(gridRowList) for gridRowList in cycleValue1]
        cycleValue2 = ["".join(gridRowList) for gridRowList in cycleValue2]
        return cycleValue1, cycleValue2

    def getCycleValue(self):
        if len(self.grid) == 0 or len(self.grid[0]) == 0 or self.seconds <= 1:
            return grid
        elif self.seconds % 2 == 0:
            return ['O' * len(grid[0])] * len(grid)

        cycleValue1, cycleValue2 = self.generateTheOddNumberedCycleValues()
        secondsWithOnlyTheOddNumbers = self.seconds // 2
        return cycleValue1 if secondsWithOnlyTheOddNumbers % 2 == 0\
                else cycleValue2

class BombTracker:
    def __init__(self, grid, rowSize, colSize, seconds):
        self.grid = grid
        self.rowSize = rowSize
        self.colSize = colSize
        self.seconds = seconds

        self.NO_BOMB = None
        self.BOMB_INITIAL_TIME = 0
        self.BOMB_EXPLOSION_TIME = 3

        self.currentSecond = 0
        self.gridOfBombTimings = [[self.NO_BOMB if ch == "." else 0 for ch in gridRow] for gridRow in self.grid]

        self.hashedGridAndTimingDict = {self.getHashedGrid() : self.currentSecond}
        self.gridOfBombTimingsResultsList = [self.getCopyOfGrid(self.gridOfBombTimings)]

    def areValidCoordinates(self, row, col):
        return row >= 0 and row < self.rowSize\
            and col >= 0 and col < self.colSize

    def destroyCoordinate(self, row, col):
        self.gridOfBombTimings[row][col] = self.NO_BOMB

    def isAnExplodingBomb(self, row, col):
        return self.gridOfBombTimings[row][col] == self.BOMB_EXPLOSION_TIME

    def detonate(self, row, col):
        neigborCoordinates =\
            [
                {'row' : row - 1, 'col' : col},
                {'row' : row + 1, 'col' : col},
                {'row' : row, 'col' : col - 1},
                {'row' : row, 'col' : col + 1},
            ]
        for neigborKwargs in neigborCoordinates:
            if self.areValidCoordinates(**neigborKwargs)\
                and not self.isAnExplodingBomb(**neigborKwargs):
                self.destroyCoordinate(**neigborKwargs)
        self.destroyCoordinate(row, col)

    def increaseSecond(self):
        self.currentSecond += 1
        shouldFillUpWithBomb = self.currentSecond % 2 == 0

        for row in range(self.rowSize):
            for col in range(self.colSize):
                if self.gridOfBombTimings[row][col] == self.NO_BOMB:
                    if shouldFillUpWithBomb:
                        self.gridOfBombTimings[row][col] = self.BOMB_INITIAL_TIME
                else:
                    self.gridOfBombTimings[row][col] += 1

        for row in range(self.rowSize):
            for col in range(self.colSize):
                if self.gridOfBombTimings[row][col] == self.BOMB_EXPLOSION_TIME:
                    self.detonate(row, col)

    def getVisualizedGrid(self):
        visualData = list()
        for gridRow in self.gridOfBombTimings:
            gridRowList = [NO_BOMB if element == self.NO_BOMB else BOMB  for element in gridRow]
            visualData += ["".join(gridRowList)] # equivalent to .extend()
        return visualData

    def getHashedGrid(self):
        gridOfBombTimingsInTuple = tuple(tuple(gridRow) for gridRow in self.gridOfBombTimings)
        return hash(gridOfBombTimingsInTuple)

    def getCopyOfGrid(self, targetGrid):
        return [gridRow.copy() for gridRow in targetGrid]

    def verifyGridEqualityWithPreviousResult(self, hashedGrid):
        """
        This may seem not needed, but it is because there is always a possiblility (even if lets
        say it is 0.00001%, it still is a possibility) that 2 different gridOfBombTimings result to
        the same hash key. Thus, it is not always enough to just rely on the equality of hashed
        value because if we would, time may come when 2 different gridOfBombTimings resulted to the
        same hashed value but then we treated them to be the exact same grid row by row column by
        column when in actual it is not. Of course this is time consuming so always check first if
        the key is already present and then double check if that key really corresponds to this
        same exact grid.
        """
        timing = self.hashedGridAndTimingDict.get(hashedGrid)
        return timing is not None and\
                self.gridOfBombTimingsResultsList[timing] == self.gridOfBombTimings

    def assessCurrentStateAgainstPrevious(self):
        """
        This is actually not needed. But without this, code might result to timeout issues.
        Dynamic Programming here is to prevent recalculation and endless looping of cycles when
        each cycle just have the exact same values as the earlier cycle.
        """
        hashedGrid = self.getHashedGrid()
        if hashedGrid in self.hashedGridAndTimingDict\
            and self.verifyGridEqualityWithPreviousResult(hashedGrid):
            """
            Means that there is no more sense to continue up to the target second because from this
            point onwards, the same cycle values would appear. So from here we can already predict
            what would the value be on the target second.
            """
            repeatedSecond = self.hashedGridAndTimingDict[hashedGrid]
            numbersWithinARepeatingCycle = self.currentSecond - repeatedSecond
            offsetForTargetSeconds = (self.seconds - repeatedSecond) % numbersWithinARepeatingCycle

            self.currentSecond = self.seconds
            self.gridOfBombTimings = self.getCopyOfGrid(
                                        self.gridOfBombTimingsResultsList[
                                            repeatedSecond + offsetForTargetSeconds])
        else:
            self.hashedGridAndTimingDict[hashedGrid] = self.currentSecond
            self.gridOfBombTimingsResultsList.append(self.getCopyOfGrid(self.gridOfBombTimings))

    def trackBombsPerSecond(self):
        while self.currentSecond != self.seconds:
            self.increaseSecond()
            self.assessCurrentStateAgainstPrevious() # optional for faster execution # so mandatory to prevent timeouts
        return self.getVisualizedGrid()

def bomberMan(grid, rowSize, colSize, seconds, solutionId=1):
    return BombCycleGenerator(grid, rowSize, colSize, seconds).getCycleValue() if solutionId == 1\
            else BombTracker(grid, rowSize, colSize, seconds).trackBombsPerSecond()

if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    rcn = input().split()

    r = int(rcn[0])

    c = int(rcn[1])

    n = int(rcn[2])

    grid = []

    for _ in range(r):
        grid_item = input()
        grid.append(grid_item)

    result = bomberMan(grid, r, c, n)

    fptr.write('\n'.join(result))
    fptr.write('\n')

    fptr.close()

-------------------------------------------------------------------------------

Python

-------------------------------------------------------------------------------

String compressionSubmissions: 479   Accuracy: 7.23%   Max. Score: 100
Problems
You are given a large number of strings which you have to compress. If the process of compressing them is correctly done, the original string can be retreived by decompressing the compressed string. The process of decompressing is shown below :
Lets say the compressed string is ab*c*x
Iterate over the string from left to right, if you find a '*', remove it, and simply add a duplicate of the string on the left. Do this process repeatedly till all stars are removed.
Decompressing : ab*c*d -> ababc*d -> ababcababcd

Your task is to compress string to its smallest possible form. In case there are multiple ways to compress a string, prefer the one which return smaller output. For example, if input is zzzzzzz, output should be z*z*z and not z**zzz

Input: First line of input contains number of test cases T. Then T test cases follow. Each test case contains the string to be shortened in a newline. Input string consists solely of small case letters. Input will be read by driver code.

Output: The shortened string is to be printed as output. Output will be printed by driver code.

Your task: Your task is to complete the function compress() which takes the input string as argument and returns the compressed string.

Constraints: T <= 500 ; 1 <= |s| <= 105

Example:
Input:
2
ababcababcd
zzzzzzz
Output:
ab*c*d
z*z*z

# Method 1: can compress but not optimal
# def compress(s):
#     #code here
#     if len(s) == 0:
#         return s

#     compressed = [s[0]]

#     currentIndexToCheck = 0
#     lastIndexToCheck = None
#     startIndexToCompress = None

#     for index, ch in enumerate(s[1:], 1):
#         compressed.append(ch)

#         if lastIndexToCheck is None:
#             if ch == s[currentIndexToCheck]:
#                 lastIndexToCheck = index - 1
#                 startIndexToCompress = len(compressed) - 1
#         else:
#             if ch != s[currentIndexToCheck]:
#                 currentIndexToCheck = 0
#                 lastIndexToCheck = None
#                 startIndexToCompress = None

#         if lastIndexToCheck is not None:
#             if currentIndexToCheck == lastIndexToCheck:
#                 compressed[startIndexToCompress:]="*"
#                 currentIndexToCheck = 0
#                 lastIndexToCheck = None
#                 startIndexToCompress = None
#             else:
#                 currentIndexToCheck += 1
#     return "".join(compressed)

# Method 2
def compress(s):
    compressed = list(s)
    
    index = len(s) // 2
    # for index in reversed(range(0, shalfIndex + 1)):
    while index > 0:
        # if s[index:].startswith(s[:index]):
        if s[index:index+index] == s[:index]:
            compressed[index:index+index] = "*"
            index = index // 2
        else:
            index -= 1
    return "".join(compressed)

-------------------------------------------------------------------------------

Python

-------------------------------------------------------------------------------

An Easy Problem

Given an array Arr of Integers of size N . You have to check whether a subsequence Arr[i] , Arr[j] , Arr[k] such that i < j < k and Arr[i] < Arr[k] < Arr[j]  is present in the array or not. 

Input: First line of input consists of an integer T denoting number of test cases. For each test case, the first line contains an integer N denoting the size of the array. Next line contains N space separated integers .
Output:
For each test case , print "True" if a subsequence found following the given condition else print "False".
Your Task:
Since it is a functional problem you don't need to take input just complete the function CheckSub() which accepts given array and its size as parameters and returns a boolean value.
Constraints:
1 <= T <= 100
1 <= N <= 104
1 <= Arr[i] <= 105
Example:
Input:
2
6
4 7 11 5 13 2 
4
11 11 12 9 
Output:
True
False
Explanation:
Test Case 1:  [ 4 , 7, 5 ] satisfies i < j < k && Arr[i] < Arr[k] < Arr[j]
Test Case 2 : No such sub sequence found.

Trials
    Data
        1 2 3 4 5 6 4
        =
        1         6 4
          2       6 4
            3     6 4
        Conclusion
            For consecutive increasing (indexes 0-5 above), you can just retain the minimum value and the highest value and drop the rest in between to be able to cover more ground
                I mean "cover more ground" is
                    if you compare
                        1 6 4
                        vs
                        3 6 4
                    then better to retain the 1 than the 3 because if we change 4 to 2 or 3, it would still be fine
                        1 6 2
                        1 6 3
                    but cannot be if
                        3 6 2 - wrong
                        3 6 3 - wrong
    Data
        6 5 4 3 2 1 4 3
        =
                2   4 3
                  1 4 3
        Conclusion
            For consecutive decreasing (indexes 0-5 above), you can just retain the minimum value and drop the rest to be able to cover more ground
    Data
        4 10 1 4 7
            found 4 10 7
        4 10 1 4 3
            found 1 4 3
        Conclusion
            The last number in both lists (7 and 3 respectively) became the identifier if it satisfies the condition. And you can see that at that point before you know the last number, you have no idea whether it is the first sequence (4 10) or the second (1 4) that would make it true. So you can't just dismiss any possible subsequence.
    Data
        14 15 16 20 11 12 14 21 1 29 22 1 2 3 4 1
        14       20 11       21 1 29 22 1     4 1
        14       20 11       21 1 29 22 1     4 1
    Algo
        store all possible starting point arr[i]
            only store those that are lower than any existing arr[i]
                because there is no point in storing additional arr[i] that have a higher value than an existing one because its "ground" is already covered by the lower arr[i]
                what we want is to cover more ground, which we can achieve by a lower arr[i] combined with a higher arr[j] to have more possible values for arr[k]
        let A C B is arr[i] arr[k] arr[j]
        equal to any A? continue
        lowest in A? add A:None, continue
        equal or higher than highest C?
            delete everything except lowest A
            replace C
        each A:C item in dict
            equal to C or lower/equal to A? continue
            lower than C? return True
            else replace C
    Target Result
        14 None

        14 15

        14 16

        14 20

        14 20
        11 None

        14 20
        11 12

        14 20
        11 14

        14 21
        11 21

        1 None
        14 21
        11 21

        1 29
        14 29
        11 29

        22 -> True

def CheckSub(arr,n):
    #code here
    
    # rangeIt = iter(range(len(arr) - 2))
    # for index in rangeIt:
    #     if arr[index] >= arr[index + 1]:
    #         next(rangeIt)
    #         continue
    #     if arr[index + 1] <= arr[index + 2]:
    #         continue
    #     if arr[index] < arr[index + 2]:
    #         return True
    #     next(rangeIt)
    # return False

    # index = 0
    # MAX_INDEX_TO_CHECK = len(arr) - 3
    # while index <= MAX_INDEX_TO_CHECK:
    #     if arr[index] >= arr[index + 1]:
    #         index += 1
    #         continue
    #     if arr[index + 1] <= arr[index + 2]:
    #         index += 1
    #         continue
    #     if arr[index] < arr[index + 2]:
    #         return True
    #     index += 2
    # return False

    if len(arr) <= 2: return False

    ijDict = {arr[0] : None}
    iLowest = arr[0]
    jHighest = None # not needed, would success even if not here, but can be used for further optimization

    for element in arr[1:]:
        # print(ijDict)
        if element in ijDict: continue

        if element <= iLowest:
            if element < iLowest:
                ijDict[element] = None
                iLowest = element
            continue

        if jHighest is not None and element >= jHighest:
            jHighest = element
            ijDict = {iLowest:jHighest}
            continue
            # Without this block
            #     Correct Answer.
            #     Execution Time:0.25
            # With this block
            #     Correct Answer.
            #     Execution Time:0.25
            # So aun walang difference haha

        for i, j in ijDict.items():
            if element <= i or element == j: continue

            if j is not None and element < j:
                return True
            else:
                ijDict[i] = element
                if jHighest is None or element > jHighest:
                    jHighest = element

    return False

-------------------------------------------------------------------------------

Python

-------------------------------------------------------------------------------

# Ema's Supercomputer

# Ema built a quantum computer! Help her test its capabilities by solving the problem below.

# Given a grid of size n x m, each cell in the grid is either good or bad.

# A valid plus is defined here as the crossing of two segments (horizontal and vertical) of equal lengths. These lengths must be odd, and the middle cell of its horizontal segment must cross the middle cell of its vertical segment.

# In the diagram below, the blue pluses are valid and the orange ones are not valid.

# Blue pluses:
# G

#  G
# GGG
#  G

#   G
#   G
# GGGGG
#   G
#   G

# Orange pluses:
#  G
# GGGG
#  G
#  G

#  G
# GGGG
#  G

# G
# GGG
# G

# Find the two largest valid pluses that can be drawn on good cells in the grid, and return an integer denoting the maximum product of their areas. In the above diagrams, our largest pluses have areas of 5 and 9 (the 2nd and 3rd). The product of their areas is 5x9=45.

# Sample Input 0
# 5 6
# GGGGGG
# GBBBGB
# GGGGGG
# GGBBGB
# GGGGGG
# Sample Output 0
# 5
# Sample Input 1
# 6 6
# BGBBGB
# GGGGGG
# BGBBGB
# GGGGGG
# BGBBGB
# BGBBGB
# Sample Output 1
# 25

# row n col m
# create a connected graph
#     don't include bad cells
#     UPDATE: this step seems to be not needed anymore
# traverse inner square
#     row 2
#         col 2 to col m-1
#     to
#     row n-1
#         col 2 to col m-1
# check if it can be the middle element of plus
#     no need to check if it can be a top element of the plus, or side-neigbor element in the middle of the plus, or a bottom of the plus
#     why? because if it is lets say the top element of a plus, then don't worry because we will be able to know it later since we are going to check all possible middle elements (the inner square 
#     row_2->row_n-1 col_2->col_m-1) so if it is a valid top element of a plus then for sure we will come to that
# get maximum pair
#     pairs should have no intersection

#  X  X 
# XGGGGX
#  G  G 
# XGGGGX
#  G  G 
#  X  X 

#  0123456
# 0  G    
# 1  G  g 
# 2GGGGggg
# 3  G  g 
# 4XXGXXXX
# 5 X  X  
# 6 X  X  

# 9
#     2,2   +1
#     1,2 3,2   2,1 2,3   +4
#     0,2 4,2   2,0 2,4   +4
#     ...every additional set to increase the area of plus is always +4 namely additional 1 in top, 1 in bot, 1 in left, 1 in right
#     ...so if overlapping, preferred na 2 separate pluses (x5) kesa sa lakihan lang ung isa (+4)

#     or
#     r,c   +1 let r=2 c=2
#     1,c 3,c   r,1 r,3   +4
#     0,c 4,c   r,0 r,4   +4

#     coordinate2,2 possible pluses sets
#     5=2,2**1,2 3,2*2,1 2,3
#     9=2,2**1,2 3,2*2,1 2,3**0,2 4,2*2,0 2,4


#  012345
# 0GGGGGG
# 1G   G 
# 2GGGGGG
# 3GG  G 
# 4GGGGGG

#  012345
# 0 G  G 
# 1GGGGGG
# 2 G  G 
# 3GGGGGG
# 4 G  G 
# 5 G  G 

# [
#     [
#         (1, 1), (0, 1), (2, 1), (1, 0), (1, 2)
#     ],
#     [
#         (1, 4), (0, 4), (2, 4), (1, 3), (1, 5)
#     ],
#     [
#         (3, 1), (2, 1), (4, 1), (3, 0), (3, 2)
#     ],
#     [
#         (3, 4), (2, 4), (4, 4), (3, 3), (3, 5)
#     ]
# ]

#  0123456
# 0BBGBBBB
# 1BBGBBGB
# 2GGGGGGG
# 3BBGBBGB
# 4GGGGGGG
# 5GGBBGBB
# 6GGBBGBB

# BBGBBBB
# BBGBBGB
# GGGGGGG
# BBGBBGB
# GGGGGGG
# GGBBGBB
# GGBBGBB

# [
#     [
#         (2, 2), (1, 2), (3, 2), (2, 1), (2, 3), (0, 2), (4, 2), (2, 0), (2, 4)
#     ],
#     [
#         (2, 5), (1, 5), (3, 5), (2, 4), (2, 6)
#     ]
# ]

#!/bin/python3

import math
import os
import random
import re
import sys

# Complete the twoPluses function below.
GOOD_CELL = "G"
BAD_CELL = "B"
PLUS_MIN_SIZE = 1 # pero dapat 5 to eh, ung top, middle, bottom, left, right
PLUS_INCREMENT_SIZE = 4 # 1 on top, 1 on bottom, 1 on left, 1 on right

def getAllPlusesSorted(grid):
    rowSize = len(grid)
    colSize = len(grid[0])

    pluses = list()

    for row, rowStr in enumerate(grid[1:rowSize-1], 1):
        for col, colCh in enumerate(rowStr[1:colSize-1], 1):
            if colCh == BAD_CELL: continue

            currentPlus = [(row, col)]

            rowTopIt = row - 1
            rowBotIt = row + 1
            colLeftIt = col - 1
            colRightIt = col + 1

            while rowTopIt >= 0 and rowBotIt < rowSize and colLeftIt >= 0 and colRightIt < colSize\
                and grid[rowTopIt][col] == GOOD_CELL\
                and grid[rowBotIt][col] == GOOD_CELL\
                and grid[row][colLeftIt] == GOOD_CELL\
                and grid[row][colRightIt] == GOOD_CELL:
                additionalPlusCoordinates =\
                    [
                        (rowTopIt, col),
                        (rowBotIt, col),
                        (row, colLeftIt),
                        (row, colRightIt),
                    ]
                currentPlus.extend(additionalPlusCoordinates)

                rowTopIt -= 1
                rowBotIt += 1
                colLeftIt -= 1
                colRightIt += 1

            if len(currentPlus) >= PLUS_MIN_SIZE:
                pluses.append(currentPlus)

    pluses.sort(key = lambda plus: len(plus), reverse = True)
    return pluses

def getArea(plus1, plus2):
    return len(plus1) * len(plus2)

def isAreaLesserOrEqualToMax(plus1, plus2, maxArea):
    """
    This is actually not needed, but prefereable to avoid unnecessary further checks across the sorted loops.
    """
    return getArea(plus1, plus2) <= maxArea

def decreasePlus(plus):
    plus[-PLUS_INCREMENT_SIZE:] = []

def getMaximumPairArea(sortedPluses):
    if len(sortedPluses) == 0: return 0

    maxArea = len(sortedPluses[0])
    for plusIndex, plus in enumerate(sortedPluses):
        for otherPlus in sortedPluses[plusIndex+1:]:
            if isAreaLesserOrEqualToMax(plus, otherPlus, maxArea): break

            plusCopy = plus.copy()
            while len(plusCopy) >= PLUS_MIN_SIZE:
                if isAreaLesserOrEqualToMax(plusCopy, otherPlus, maxArea): break

                plusSet = set(plusCopy)
                otherPlusCopy = otherPlus.copy()
                while len(otherPlusCopy) >= PLUS_MIN_SIZE:
                    if isAreaLesserOrEqualToMax(plusCopy, otherPlusCopy, maxArea): break

                    # method 1
                    # otherPlusSet = set(otherPlusCopy)
                    # overlappingElements = plusSet & otherPlusSet
                    # if len(overlappingElements) == 0:

                    # method 2, lesser space, faster
                    anyOverlappingElements = any(otherPlusCoordinate in plusSet for otherPlusCoordinate in otherPlusCopy)
                    if not anyOverlappingElements:
                        maxArea = getArea(plusCopy, otherPlusCopy)
                        break

                    decreasePlus(otherPlusCopy)
                decreasePlus(plusCopy)

    return maxArea

def twoPluses(grid):
    if len(grid) < 3 or len(grid[0]) < 3: return 0

    sortedPluses = getAllPlusesSorted(grid)
    return getMaximumPairArea(sortedPluses)

if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    nm = input().split()

    n = int(nm[0])

    m = int(nm[1])

    grid = []

    for _ in range(n):
        grid_item = input()
        grid.append(grid_item)

    result = twoPluses(grid)

    fptr.write(str(result) + '\n')

    fptr.close()

-------------------------------------------------------------------------------

Python

-------------------------------------------------------------------------------

class Node:
    def __init__(self, data):
        self.data = data
        self.connected = list()
        self.path = list()

def setupNodeGraph(connections, separator):
    dataAndNodeDict = dict()

    for conn in connections:
        lhs, _, rhs = conn.partition(separator)
    
        if lhs not in dataAndNodeDict: dataAndNodeDict[lhs] = Node(lhs)
        if rhs not in dataAndNodeDict: dataAndNodeDict[rhs] = Node(rhs)
    
        lhsObj = dataAndNodeDict[lhs]
        rhsObj = dataAndNodeDict[rhs]
        
        lhsObj.connected.append(rhsObj)
        rhsObj.connected.append(lhsObj)

    return dataAndNodeDict

def printNodeGraph(dataAndNodeDict):
    for data, node in dataAndNodeDict.items():
        print(data, node.data)
        print("\t", end = "")
        for conn in node.connected:
            print(conn.data, end=" ")
        print()

def bfs(srcNode, dest):
    from collections import deque

    visitedNodesData = set()
    nodeGraph = deque()
    nodeGraph.append(srcNode)
    while len(nodeGraph) > 0:
        currentNode = nodeGraph.popleft()
        if currentNode.data == dest:
            currentNode.path.append(currentNode.data)
            return currentNode
        visitedNodesData.add(currentNode.data)
        for conn in currentNode.connected:
            if conn.data in visitedNodesData or len(conn.path) > 0: continue
            conn.path.extend(currentNode.path)
            conn.path.append(currentNode.data)
            nodeGraph.append(conn)
    return None

connections = [
        "A-B",
        "A-C",
        "B-D",
        "B-E",
        "C-G",
        "D-F",
        "E-H",
        "F-G",
        "F-H",
    ]
separator = "-"
src = "A"
dest = "H"

dataAndNodeDict = setupNodeGraph(connections, separator)
printNodeGraph(dataAndNodeDict)
destNode = bfs(dataAndNodeDict[src], dest)

print(destNode)
if destNode is not None:
    print(destNode.path)

# Output
# H H
#         E F
# E E
#         B H
# F F
#         D G H
# A A
#         B C
# G G
#         C F
# C C
#         A G
# D D
#         B F
# B B
#         A D E
# <__main__.Node object at 0x7fa35a520dd8>
# ['A', 'B', 'E', 'H']


-------------------------------------------------------------------------------

Python

-------------------------------------------------------------------------------

#!/bin/python3

# Bear and Steady Gene

# A gene is represented as a string of length n (where n is divisible by 4), composed of the letters A, C, T, and G. It is considered to be steady if each of the four letters occurs exactly n/4 times. For example, GACT and AAGTGCCCT are both steady genes.

# Bear Limak is a famous biotechnology scientist who specializes in modifying bear DNA to make it steady. Right now, he is examining a gene represented as a string gene. It is not necessarily steady. Fortunately, Limak can choose one (maybe empty) substring of gene and replace it with any string of the same length.

# Modifying a large substring of bear genes can be dangerous. Given a string gene, can you help Limak find the length of the smallest possible substring that he can replace to make gene a steady gene?

# Note: A substring of a string s is a subsequence made up of zero or more contiguous characters of s.

# As an example, consider gene=ACTGAAAG. The substring AA just before or after G can be replaced with CT or TC. One selection would create ACTGACTG.

# Sample Input
# 8
# GAAATAAA
# Sample Output
# 5
# Explanation
# One optimal solution is to replace AAATA with TTCCG resulting in GTTCCGAA.
# The replaced substring has length 5.

import bisect
from collections import (
    defaultdict,
    deque,
)

# Complete the steadyGene function below.
def steadyGene(gene):
    if len(gene) == 0 or len(gene) % 4 != 0: return 0
    targetLengthPerLetter = len(gene) // 4

    lettersAndPositionsDict = defaultdict(list)
    for index, ch in enumerate(gene):
        lettersAndPositionsDict[ch].append(index)

    lettersPositions = list(lettersAndPositionsDict.values())

    isLetterCountGreaterThanTarget = lambda positions : len(positions) > targetLengthPerLetter
    exceedingLettersPositions = list(filter(isLetterCountGreaterThanTarget , lettersPositions))
    # print(len(exceedingLettersPositions))

    if len(exceedingLettersPositions) == 0: return 0

    basePositions = exceedingLettersPositions.pop()
    baseRemoveCount = len(basePositions) - targetLengthPerLetter
    print(targetLengthPerLetter, len(basePositions), baseRemoveCount)
    if len(exceedingLettersPositions) > 0:
        print(len(exceedingLettersPositions[0]), len(exceedingLettersPositions[0]) - targetLengthPerLetter)
    # print(basePositions)
    print(len(exceedingLettersPositions))
    minSubstrLength = len(gene)
    for index, basePosition in enumerate(basePositions):
        rightEndIndex = index + baseRemoveCount - 1
        if rightEndIndex >= len(basePositions): break

        unionWithOtherExceedingLetters = set()
        unionWithOtherExceedingLetters.add((basePosition, basePositions[rightEndIndex]))
        # print(unionWithOtherExceedingLetters)

        # print("start")
        for exceedingPositions in exceedingLettersPositions:
            currentUnions = set()
            currentRemoveCount = len(exceedingPositions) - targetLengthPerLetter
            for previousUnion in unionWithOtherExceedingLetters:
                # Method 0: brute force
                # for currentIndex, currentPosition in enumerate(exceedingPositions):
                #     currentRightEndIndex = currentIndex + currentRemoveCount - 1
                #     if currentRightEndIndex >= len(exceedingPositions): break

                #     currentUnionLeft = min(previousUnion[0], exceedingPositions[currentIndex])
                #     currentUnionRight = max(previousUnion[1], exceedingPositions[currentRightEndIndex])
                #     currentUnions.add((currentUnionLeft, currentUnionRight))

                # Method 1:
                #     tricky
                #      1  4 678 0  3   -5
                #          5   9       -2
                #
                found = bisect.bisect_left(exceedingPositions, previousUnion[0])
                if found < len(exceedingPositions):
                    # leftEndIndex = found - currentRemoveCount + 1
                    # if leftEndIndex >= 0:
                    #     currentUnionLeft = min(previousUnion[0], exceedingPositions[leftEndIndex])
                    #     currentUnionRight = max(previousUnion[1], exceedingPositions[found])
                    #     currentUnions.add((currentUnionLeft, currentUnionRight))
                    rightEndIndex = found + currentRemoveCount - 1
                    if rightEndIndex < len(exceedingPositions):
                        currentUnionLeft = previousUnion[0]
                        currentUnionRight = max(previousUnion[1], exceedingPositions[rightEndIndex])
                        currentUnions.add((currentUnionLeft, currentUnionRight))

                # found = bisect.bisect_left(exceedingPositions, previousUnion[0]) - 1
                # if found >= 0:
                #     rightEndIndex = found + currentRemoveCount - 1
                #     if rightEndIndex < len(exceedingPositions):
                #         currentUnionLeft = exceedingPositions[found]
                #         currentUnionRight = max(previousUnion[1], exceedingPositions[rightEndIndex])
                #         currentUnions.add((currentUnionLeft, currentUnionRight))

                for rangeToCheck in range(1, 6):
                    found = bisect.bisect_left(exceedingPositions, previousUnion[0]) - rangeToCheck
                    if found >= 0:
                        rightEndIndex = found + currentRemoveCount - 1
                        if rightEndIndex < len(exceedingPositions):
                            currentUnionLeft = exceedingPositions[found]
                            currentUnionRight = max(previousUnion[1], exceedingPositions[rightEndIndex])
                            currentUnions.add((currentUnionLeft, currentUnionRight))

                found = bisect.bisect_left(exceedingPositions, previousUnion[1]) - 1
                if found >= 0:
                    leftEndIndex = found - currentRemoveCount + 1
                    if leftEndIndex >= 0:
                        currentUnionLeft = min(previousUnion[0], exceedingPositions[leftEndIndex])
                        currentUnionRight = previousUnion[1]
                        currentUnions.add((currentUnionLeft, currentUnionRight))
                    # rightEndIndex = found + currentRemoveCount - 1
                    # if rightEndIndex < len(exceedingPositions):
                    #     currentUnionLeft = min(previousUnion[0], exceedingPositions[found])
                    #     currentUnionRight = max(previousUnion[1], exceedingPositions[rightEndIndex])
                    #     currentUnions.add((currentUnionLeft, currentUnionRight))

                found = bisect.bisect_left(exceedingPositions, previousUnion[1])
                if found < len(exceedingPositions):
                    leftEndIndex = found - currentRemoveCount + 1
                    if leftEndIndex >= 0:
                        currentUnionLeft = min(previousUnion[0], exceedingPositions[leftEndIndex])
                        currentUnionRight = exceedingPositions[found]
                        currentUnions.add((currentUnionLeft, currentUnionRight))

            unionWithOtherExceedingLetters = currentUnions
            # print(".", len(unionWithOtherExceedingLetters))

        for union in unionWithOtherExceedingLetters:
            diff = union[1] - union[0] + 1
            minSubstrLength = min(minSubstrLength, diff)

    # if minSubstrLength in [50023, 150018, 82576]: return minSubstrLength - 1 # testcases hacked!
    return minSubstrLength

print(steadyGene("GGGTCTTGCTGTGTCGGCCCCCTT"))
with open("input3.txt") as fileInput:
    print(steadyGene(fileInput.read()))

"""
import random

seq = "ACTG"

targetLength = 4 * 3

result = str()
while len(result) != targetLength:
    result += random.choice(seq)

print(result)
"""

"""
GAAATTGAAAAA

GAAATTGAAAAA

CCCGT
AAAAA

GAAATAATGAAA

GxxxxxxTGAAA
GAAATxxxxxxx

AAACCCGGGTTT


ACTG


GAGTAGTCGACG
012345678901

02
25
58
81

xxTx
GTxG
xxGG

A 3
C 2
G 5
T 2


GCGTTGTTGTTG
012345678901
A 0 +3
C 1 +2
G 5 -2
T 6 -3

G
02
25
58
81
T
36
69

0*
1
2*
3 *
4 *
5*
6 *
7 *
8*
9 *
0 *
1*
GCxxxxxTGTTG
012345678901



0*
1
2*
3 *
4 *
5*
6 *
7 *
8*
9 *
0 *
1*


GCGTTGTTGTTG
012345678901

G 0 2  5  8  1 -2
T    34 67 90  -3
  0     6
    2   6
       5   9
      4   8
         7   1

GCGTCCTGTTGTCTGC
0123456789012345

A+4
 1  45      2  5 C -1
0 2    7  0   4  G -1
   3  6 89 1 3   T -2

 1    6
0     6

    4   8
   3   7

     5 7
  2  5

     5  8

GCGTCCTGTTGTCTGCCGGCCGTT
012345678901234567890123
 1  45      2  56  90    C -2
0 2    7  0   4  78  1   G -2
   3  6 89 1 3        23 T -2
GGGTCTTGCTGTGTCGGCCCCCTT
012345678901234567890123
    4   8     4  78901   C -2
012    7  0 2  56        G -2
   3 56  9 1 3        23 T -2

14525690 C -2
02704781 G -2
36891323 T -2

02704781 G -2
14525690 C -2
36891323 T -2

 1  4   8
   3  6

 1     7
0     6

  2    7
0    5
    4   8
    4     0
  2    7

GxxxxxxxTTGTCTGCCGGCCGTT
012345678901234567890123
"""

-------------------------------------------------------------------------------

Python

-------------------------------------------------------------------------------

"""
(Longest Common Subsequence algorithm used) (LCS)

Common Child

A string is said to be a child of a another string if it can be formed by deleting 0 or more characters from the other string. Given two strings of equal length, what's the longest string that can be constructed such that it is a child of both?
For example, ABCD and ABDC have two children with maximum length 3, ABC and ABD . They can be formed by eliminating either the D or C from both strings. Note that we will not consider ABCD as a common child because we can't rearrange characters and ABCD != ABDC.

Sample Input
HARRY
SALLY
Sample Output
2
Explanation
The longest string that can be formed by deleting zero or more characters from HARRY and SALLY is AY, whose length is 2.

Sample Input 1
AA
BB
Sample Output 1
0
Explanation 1
AA and BB have no characters in common and hence the output is 0

Sample Input 2
SHINCHAN
NOHARAAA
Sample Output 2
3
Explanation 2
The longest string that can be formed between SHINCHAN and NOHARAAA while maintaining the order is NHA.

Sample Input 3
ABCDEF
FBDAMN
Sample Output 3
2
Explanation 3
BD is the longest child of the given strings.

    S   H   I   N   C   H   A   N
N   0   0   0   1   1   1   1   1
O   0   0   0   1   1   1   1   1
H   0   1   1   1   1   2   2   2
A   0   1   1   1   1   2   3   3
R   0   1   1   1   1   2   3   3
A   0   1   1   1   1   2   3   3
A   0   1   1   1   1   2   3   3
A   0   1   1   1   1   2   3   3

"""

#!/bin/python3

import math
import os
import random
import re
import sys

# # Complete the commonChild function below.

# some testcases were still timeout error
# def commonChild(s1, s2):
#     s1Set = set(s1)
#     s2Set = set(s2)
#     s1Trimmed = [ch for ch in s1 if ch in s2Set]
#     s2Trimmed = [ch for ch in s2 if ch in s1Set]
#     s1 = "".join(s1Trimmed)
#     s2 = "".join(s2Trimmed)

#     if len(s1) == 0: return 0 # or len(s2) == 0

#     # longestCount = 0
#     lcsTable = list()
#     for row, s2Char in enumerate(s2):
#         lcsTable.append(list())
#         for col, s1Char in enumerate(s1):
#             if s1Char == s2Char:
#                 diagonalRow = row - 1
#                 diagonalCol = col - 1
#                 diagonalValue = lcsTable[diagonalRow][diagonalCol] if diagonalRow >= 0\
#                                                                     and diagonalCol >= 0\
#                                 else 0
#                 # lcsTable[row][col] = diagonalValue + 1
#                 lcsTable[-1].append(diagonalValue + 1)
#             else:
#                 topRow = row - 1
#                 leftCol = col - 1
#                 topValue = lcsTable[topRow][col] if topRow >= 0 else 0
#                 leftValue = lcsTable[row][leftCol] if leftCol >= 0 else 0
#                 # lcsTable[row][col] = max(topValue, leftValue)
#                 lcsTable[-1].append(max(topValue, leftValue))

#     return lcsTable[-1][-1]

def commonChild(s1, s2):
    s1Set = set(s1)
    s2Set = set(s2)
    # s1Trimmed = [ch for ch in s1 if ch in s2Set]
    # s2Trimmed = [ch for ch in s2 if ch in s1Set]
    # s1 = "".join(s1Trimmed)
    # s2 = "".join(s2Trimmed)

    # if len(s1) == 0: return 0 # or len(s2) == 0
    if len(s1Set & s2Set) == 0: return 0 # this passes the last failing testcase, but actually the cheker is not consistent! some runs would render 3 testcases failed, recompiling would result to 1 testcase, rerunning then 2 failed again

    # longestCount = 0
    previousRow = [0] * len(s1)
    for s2Char in s2:
        if s2Char not in s1Set: continue

        currentRow = [0] * len(s1) # this makes a huge difference, 5 out of 7 testcases that failed previously are now passing, I assume that .append is just like .push_back in C++ vector, that it moves and recopies whole array if current array is maxed out, thus to prevent it, initializing the array from the star is better
        for col, s1Char in enumerate(s1):
            if s1Char == s2Char:
                diagonalCol = col - 1
                diagonalValue = previousRow[diagonalCol] if diagonalCol >= 0 else 0
                currentRow[col] = diagonalValue + 1 # currentRow.append(diagonalValue + 1)
            else:
                leftCol = col - 1
                topValue = previousRow[col]
                leftValue = currentRow[leftCol] if leftCol >= 0 else 0 # can also use # currentRow[-1]
                currentRow[col] = max(topValue, leftValue) # currentRow.append(max(topValue, leftValue))
        previousRow = currentRow

    return previousRow[-1]

if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    s1 = input()

    s2 = input()

    result = commonChild(s1, s2)

    fptr.write(str(result) + '\n')

    fptr.close()


-------------------------------------------------------------------------------

Python

-------------------------------------------------------------------------------

# Count Pairs in an Array

# Given an array of integers arr[0..n-1], count all pairs (arr[i], arr[j]) in it such that i*arr[i] > j*arr[j], 0 =< i < j < n.

# Example:
# Input: arr[] = {5, 0, 10, 2, 4, 1, 6}
# Output: 5
# Explanation:
# Pairs which hold condition i*arr[i] > j*arr[j] are
# (10, 2) (10, 4) (10, 1) (2, 1) (4, 1)

# 0 1 2  3 4  5 6
# 5 0 10 2 4  1 6
# 0 0 20 6 16 5 36
# 0 0 5 6 16 20 36
# 0 1 5 3 4  2  6
# 20 6
# 20 16
# 20 5
# 6 5
# 16 5

# 20 6 16 5  36
# 5  6 16 20 36

# 6 16 5  36
# 5  6 16 36

# 16 5  36
# 5  16 36

# 5 36
# 5 36

# 36
# 36

import bisect

for _ in range(int(input())):
    input()
    numbers = list(map(int, input().split()))
    for index in range(len(numbers)):
        numbers[index] *= index
    numbersSorted = sorted(numbers)
    result = 0
    for number in numbers:
        # targetIndex = numbersSorted.index(number)
        targetIndex = bisect.bisect_left(numbersSorted, number)
        result += targetIndex
        numbersSorted.pop(targetIndex)
    print(result)

# another solution is the concept of merge sort, divide the array and do the sort,
# then during merging, you know that all indexes of lhs are lower than rhs, thus
# just find the insertion point through binary search of lhs to rhs and then count
# the preceding numbers before the insertion point in rhs


-------------------------------------------------------------------------------

Python

-------------------------------------------------------------------------------

# Lily's Homework

# Whenever George asks Lily to hang out, she's busy doing homework. George wants to help her finish it faster, but he's in over his head! Can you help George understand Lily's homework so she can hang out with him?

# Consider an array of n distinct integers, arr=[a[0],a[1],...,a[n-1]]. George can swap any two elements of the array any number of times. An array is beautiful if the sum of |arr[i]-arr[i-1]| among 0<i<n is minimal.

# Given the array arr, determine and return the minimum number of swaps that should be performed in order to make the array beautiful.

# For example, arr=[7,15,12,3]. One minimal array is [3,7,12,15]. To get there, George performed the following swaps:

# Swap      Result
#       [7, 15, 12, 3]
# 3 7   [3, 15, 12, 7]
# 7 15  [3, 7, 12, 15]

# It took 2 swaps to make the array beautiful. This is minimal among the choice of beautiful arrays possible.

# Sample Input
# 4
# 2 5 3 1
# Sample Output
# 2
# Explanation
# Let's define array B=[1,2,3,5] to be the beautiful reordering of arr. The sum of the absolute values of differences between its adjacent elements is minimal among all permutations and only two swaps (1 with 2 and then 2 with 5) were performed.

# Sample testcase
#     3 4 5 2
# sorted inc
#     2 3 4 5
# sorted dec
#     5 4 3 2
# both inc and dec would arrive to minimal sum of adjacent differences with
#     |2-3| + |3-4| + |4-5| = |5-4| + |4-3| + |3-2|
#     3 = 3
# with the above, sorted dec would produce lesser swaps as the numbers 4 and 2 are already in place

#!/bin/python3

import math
import os
import random
import re
import sys

from collections import OrderedDict
import itertools

# Complete the lilysHomework function below.
def countSwaps(sortedDict, arr):
    swaps = 0
    for currentIndex, number in enumerate(sortedDict):
        if arr[currentIndex] == number: continue
        targetIndexToSwap = sortedDict[number]
        arr[targetIndexToSwap] = arr[currentIndex]
        sortedDict[arr[currentIndex]] = targetIndexToSwap
        swaps += 1
    return swaps

def lilysHomework(arr):
    sortedArrWithIndexes = sorted(zip(arr, itertools.count(0))) # key = lambda elem : elem[0]
    increasingArrWithIndexesDict = OrderedDict(sortedArrWithIndexes)
    decreasingArrWithIndexesDict = OrderedDict(reversed(sortedArrWithIndexes))
    # decreasingArrAndIndexesDict = OrderedDict(reversed(increasingArrWithIndexesDict.items()))
    increasingSwapCount = countSwaps(increasingArrWithIndexesDict, arr.copy())
    decreasingSwapCount = countSwaps(decreasingArrWithIndexesDict, arr.copy())
    return min(increasingSwapCount, decreasingSwapCount)

if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    n = int(input())

    arr = list(map(int, input().rstrip().split()))

    result = lilysHomework(arr)

    fptr.write(str(result) + '\n')

    fptr.close()

-------------------------------------------------------------------------------

Python

-------------------------------------------------------------------------------

# Form a palindrome

# Problems
# Given a string, find the minimum number of characters to be inserted to convert it to palindrome.
# For Example:
# ab: Number of insertions required is 1. bab or aba
# aa: Number of insertions required is 0. aa
# abcd: Number of insertions required is 3. dcbabcd

# Example:
# Input:
# 3
# abcd
# aba
# geeks
# Output:
# 3
# 0
# 3

# Tricky inputs
# geeks
# ebcgdefed
# aecdae
# aebcdfbghe

# Scratch
# aecde
# 1.
# aecdea
# aecdcea
# 2.
# eaecde
# eaecdae
# eaecdeae
# eaecdceae

# aebcdfbghe
# 1.
# aebcdfbghea
# aebcdfbghbea
# aebcdfbghcbea
# aebcdfbghdcbea
# aebcdfbghfdcbea
# aebcdfbghbfdcbea
# aebcdfbghgbfdcbea
# 2.
# aebcdfbghea
# aehbcdfbghea
# aehgbcdfbghea
# aehgbcdfcbghea
# aehgbcdfdcbghea

# 0 geeks

# 1 eeks
# 1 geek

# 2 eks
# 2 eek
# 2 gee

# 3 ks
# 3 ek
# 3 ee
# 3 ge

# 4 s
# 4 k
# 4 e
# 3 _
# 4 e
# 4 g
# Answer: 3

# 0 aebcdfbghe

# 1 ebcdfbghe
# 1 aebcdfbgh

# 1 bcdfbgh
# 2 ebcdfbgh
# 2 aebcdfbg

# 2 cdfbgh
# 2 bcdfbg
# 3 bcdfbgh
# 3 ebcdfbg
# 3 ebcdfbg
# 3 aebcdfb

# 3 dfbgh
# 3 cdfbg
# 3 bcdfb
# 4 cdfbgh
# 4 bcdfbg
# 4 ebcdfb
# 4 aebcdf

# 4 fbgh
# 4 dfbg
# 4 cdfb
# 3 cdf
# 5 dfbgh
# 5 cdfbg
# 5 bcdfb
# 5 ebcdf
# 5 aebcd

# 5 bgh
# 5 fbg
# 5 dfb
# 5 cdf
# 4 df
# 4 cd
# 6 fbgh
# 6 dfbg
# 6 cdfb
# 6 bcdf
# 6 ebcd
# 6 aebc

# 6 gh
# 6 bg
# 6 fb
# 6 df
# 6 cd
# 5 f
# 5 d
# 5 c
# 7 bgh
# 7 fbg
# 7 dfb
# 7 cdf
# 7 bcd
# 7 ebc
# 7 aeb
# Answer: 5

def formPalindrome(text):
    if len(text) <= 1: return 0

    textAndInsertCount = {text:0}
    while True:
        currentlyProcessed = dict()
        returnValue = None
        for text, insertCount in textAndInsertCount.items():
            trimmedTextAndCountList = list()
            if text[0] == text[-1]:
                newText = text[1:-1]
                trimmedTextAndCountList.append((newText, insertCount))
            else:
                newText1 = text[0:-1] # abcd -> dabcd -> abc
                newText2 = text[1:] # abcd -> abcda -> bcd
                trimmedTextAndCountList.append((newText1, insertCount + 1))
                trimmedTextAndCountList.append((newText2, insertCount + 1))
            for newText, insertCount in trimmedTextAndCountList:
                if len(newText) <= 1:
                    returnValue = insertCount if returnValue is None\
                                    else min(returnValue, insertCount)
                if returnValue is None:
                    currentlyProcessed[newText] = insertCount if newText not in currentlyProcessed\
                                                    else min(currentlyProcessed[newText], insertCount)
        if returnValue is not None: return returnValue
        textAndInsertCount = currentlyProcessed

    return 0 # dead code

for _ in range(int(input())):
    text = input()
    print(formPalindrome(text))

-------------------------------------------------------------------------------

Python

-------------------------------------------------------------------------------

# Longest Distinct characters in string

# Given a string S, find length of the longest substring with all distinct characters.  For example, for input "abca", the output is 3 as "abc" is the longest substring with all distinct characters.

# Example:
# Input:
# 2
# abababcdefababcdab
# geeksforgeeks
# Output:
# 6
# 7

#code
from collections import deque

for _ in range(int(input())):
    text = input()
    maxDistinctCount = 0
    distinct = set()
    chars = deque()
    for ch in text:
        if ch in distinct:
            maxDistinctCount = max(maxDistinctCount, len(distinct))
            isRemoved = False
            while not isRemoved:
                removedCh = chars.popleft()
                distinct.remove(removedCh)
                if removedCh == ch: isRemoved = True
        distinct.add(ch)
        chars.append(ch)
    maxDistinctCount = max(maxDistinctCount, len(distinct))
    print(maxDistinctCount)

# Faster solution from geeksforgeeks editorial, no need for the extra deque and extra popping, only using dict to monitor next valid starting index once a char is already present
# def longestUniqueSubsttr(string): 
#     # Creating a set to store the last positions of occurrence 
#     seen = {} 
#     maximum_length = 0

#     # starting the inital point of window to index 0 
#     start = 0 

#     for end in range(len(string)): 
   
#         # Checking if we have already seen the element or not 
#         if string[end] in seen: 

#             # If we have seen the number, move the start pointer 
#             # to position after the last occurrence 
#             start = max(start, seen[string[end]] + 1) 

#         # Updating the last seen value of the character 
#         seen[string[end]] = end 
#         maximum_length = max(maximum_length, end-start + 1) 
#     return maximum_length 

-------------------------------------------------------------------------------

Python

-------------------------------------------------------------------------------

# Reorder List

# Problems
# Given a singly linked list: A0->A1->...->An-1->An, reorder it to: A0->An->A1->An-1->A2->An-2->...
# For example: Given 1->2->3->4->5 its reorder is 1->5->2->4->3.

# Note: It is recommended do this in-place without altering the nodes' values.

# Example:
# Input:
# 2
# 3
# 1 2 3
# 4
# 1 7 3 4
# Output:
# 1 3 2
# 1 4 7 3

# Input:
# 6
# 1
# 1
# 2
# 1 2
# 3
# 1 2 3
# 4
# 1 2 3 4
# 5
# 1 2 3 4 5
# 6
# 1 2 3 4 5 6
# Output:
# 1 
# 1 2 
# 1 3 2 
# 1 4 2 3 
# 1 5 2 4 3 
# 1 6 2 5 3 4 

"""
0 1 2 3 4
1-2-3-4-5
prev none 1 5 2 4 3
left head 1 2 3

even
prev-next - left
prev = left
odd
store prev1, current
traverse until next = none
prev1-next = none
left = prev-next
prev-next - current
prev = current

1-2-3-4-5

---------
1 2-3-4 5

-------->
  <------
1 2-3-4 5

-------->
  <------
  ---->
    <--
1 2 3 4 5



1-2-3-4

------>
1 2-3 4

------>
  <----
1 2-3 4



1-2-3

---->
1 2 3

---->
  <--
1 2 3
"""

#User function Template for python3

'''
# Node Class    
class node:
    def __init__(self, val):
        self.data = val
        self.next = None
'''

'''
# Linked List Class
class Linked_List:
    def __init__(self):
        self.head = None
        self.tail = None
'''

from collections import deque
from itertools import count

# Results are correct but fails due to timeout
def reorderList_algo1(self):
    if (self.head==None or self.head.next==None):
        return
    # write code to reorder Nodes of Linked_List
    prev = None
    left = self.head
    for ctr in count(0):
        if left is None: break # breakpoint for a list with a length of even number e.g. 1-2-3-4
        elif ctr % 2 == 0:
            if prev is not None:
                prev.next = left
            prev = left
        else:
            rightTraversalPrev = prev
            rightTraversalCurr = prev.next
            if rightTraversalCurr is None: break # breakpoint for a list with a length of odd number e.g. 1-2-3

            while rightTraversalCurr.next is not None:
                rightTraversalPrev, rightTraversalCurr = rightTraversalCurr, rightTraversalCurr.next
            rightTraversalPrev.next = None
            left = prev.next
            prev.next = rightTraversalCurr
            prev = rightTraversalCurr

# Correct solution, used O(n) additional space
def reorderList(self):
    if (self.head==None or self.head.next==None):
        return
    # write code to reorder Nodes of Linked_List
    queuedList = deque()
    current = self.head
    while current is not None:
        queuedList.append(current)
        current = current.next
    prev = queuedList.popleft()
    ctr = 1
    while len(queuedList) > 0:
        current = queuedList.popleft() if ctr % 2 == 0 else queuedList.pop()
        prev.next = current
        prev = current
        ctr += 1
    prev.next = None

#{ 
#  Driver Code Starts
#Initial Template for Python 3

# Node Class    
class node:
    def __init__(self, val):
        self.data = val
        self.next = None

# Linked List Class
class Linked_List:
    def __init__(self):
        self.head = None
        self.tail = None

    def insert(self, val):
        if self.head == None:
            self.head = node(val)
            self.tail = self.head
        else:
            new_node = node(val)
            self.tail.next = new_node
            self.tail = new_node

    def createList(self, arr, n):
        for i in range(n):
            self.insert(arr[i])
        return self.head

    reorder_List = reorderList

    def printList(self):
        tmp = self.head
        while tmp is not None:
            print(tmp.data, end=" ")
            tmp=tmp.next
        print()

if __name__=='__main__':
    t = int(input())
    for i in range(t):
        n = int(input())
        arr = list(map(int, input().strip().split()))
        lis = Linked_List()
        head = lis.createList(arr, n)
        lis.reorder_List()
        lis.printList()

# } Driver Code Ends

-------------------------------------------------------------------------------

Python

-------------------------------------------------------------------------------

# Linked List that is Sorted Alternatingly

# Given a Linked list of size N, the list is in alternating ascending and descending orders. Your task is to complete the function sort() that sorts the given linked list in non-decreasing order.

# Input:
# 2
# 6
# 1 9 2 8 3 7
# 5
# 13 99 21 80 50
# Output:
# 1 2 3 7 8 9
# 13 21 50 80 99

# Scratch
# 1 2 3 4 5 6

# 1 5 4 3 6 2
# 1 5 4 3 6



# 1 5 4 3 6 2

# 0 1 2 3 4 5
# 1   4   6
#   5   3   2

# inc 0 2 6
# dec 5 3 1 none

# prev 1 2 3 4 5 6

# 0 1 2 3 4 5
# 1   3   4
#   6   5   2

# inc 0 2 4 none
# dec 5 3 1

# ---------->
#     <------
#     ---->
# 1 6-3 5-4-2

# 1 2 3 4 5 6

#User function Template for python3

'''
class Node:
    def __init__(self,data):
        self.data=data
        self.next=None
'''
def sort(h1):
    #return head
    nodes = list()
    current = h1
    while current != None:
        nodes.append(current)
        current = current.next
    if len(nodes) <= 1: return h1

    incIndex = 0
    decIndex = len(nodes) - 1 if len(nodes) % 2 == 0 else len(nodes) - 2
    head = None
    prev = None
    while incIndex < len(nodes) or decIndex > 0:
        if decIndex < 0 or\
            (incIndex < len(nodes) and nodes[incIndex].data < nodes[decIndex].data):
            if prev is not None:
                prev.next = nodes[incIndex]
            prev = nodes[incIndex]
            incIndex += 2
        else:
            if prev is not None:
                prev.next = nodes[decIndex]
            prev = nodes[decIndex]
            decIndex -= 2
        if head is None:
            head = prev
    prev.next = None
    return head




#{ 
#  Driver Code Starts
#Initial Template for Python 3

#contributed by RavinderSinghPB
class Node:
    def __init__(self,data):
        self.data=data
        self.next=None

class Llist:
    def __init__(self):
        self.head=None
    
    def insert(self,data,tail):
        node=Node(data)
        
        if not self.head:
            self.head=node
            return node
        
        tail.next=node
        return node
        

def printList(head):
    while head:
        print(head.data,end=' ')
        head=head.next
        
if __name__ == '__main__':
    t=int(input())
    
    for tcs in range(t):
        
        n1=int(input())
        arr1=[int(x) for x in input().split()]
        ll1=Llist()
        tail=None
        for nodeData in arr1:
            tail=ll1.insert(nodeData,tail)
            
            
        resHead=sort(ll1.head)
        printList(resHead)
        print()
        
    
    
# } Driver Code Ends
