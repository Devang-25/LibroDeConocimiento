/******************************************************************************

                              Online C++ Compiler.
               Code, Compile, Run and Debug C++ program online.
Write your code in this editor and press "Run" button to compile and execute it.

*******************************************************************************/

#include <algorithm>
#include <iostream>
#include <string>
#include <list>
#include <map>
#include <set>
#include <unordered_map>
#include <unordered_set>
#include <vector>
#include <cmath>

template <typename T>
class MyOptional
{
public:
    MyOptional() :
        isValueInitialized_(false),
        value_()
    {
    }

    MyOptional(const T& value) :
        isValueInitialized_(true),
        value_(value)
    {
    }

    MyOptional& operator=(const MyOptional& other)
    {
        isValueInitialized_ = other.isValueInitialized_;
        value_ = other.value_;
        return *this;
    }

    MyOptional& operator=(const T& value)
    {
        isValueInitialized_ = true;
        value_ = value;
        return *this;
    }

    operator bool()
    {
        return isValueInitialized_;
    }

    T getValueOr(const T& value)
    {
        return isValueInitialized_ ?
                value_ :
                value;
    }

private:
    bool isValueInitialized_;
    T value_;
};

int queensAttack(
    int n,
    int k,
    int r_q,
    int c_q,
    const std::vector<std::vector<int>>& obstacles)
{
    MyOptional<int> nearestLeftConstraint;
    MyOptional<int> nearestRightConstraint;
    MyOptional<int> nearestDownConstraint;
    MyOptional<int> nearestUpConstraint;
    MyOptional<int> nearestDiagonalDownLeftAttacks;
    MyOptional<int> nearestDiagonalDownRightAttacks;
    MyOptional<int> nearestDiagonalUpLeftAttacks;
    MyOptional<int> nearestDiagonalUpRightAttacks;

    for (const auto& xy : obstacles)
    {
        const int obstacleX = xy.at(0);
        const int obstacleY = xy.at(1);
        if (obstacleX == r_q && obstacleY == c_q) continue;

        if (obstacleX == r_q)
        {
            if (obstacleY < c_q && (!nearestLeftConstraint || obstacleY > nearestLeftConstraint.getValueOr(0)))        nearestLeftConstraint = obstacleY;
            else if (obstacleY > c_q && (!nearestRightConstraint || obstacleY < nearestRightConstraint.getValueOr(0))) nearestRightConstraint = obstacleY;
        }
        else if (obstacleY == c_q)
        {
            if (obstacleX < r_q && (!nearestDownConstraint || obstacleX > nearestDownConstraint.getValueOr(0)))  nearestDownConstraint = obstacleX;
            else if (obstacleX > r_q && (!nearestUpConstraint || obstacleX < nearestUpConstraint.getValueOr(0))) nearestUpConstraint = obstacleX;
        }
        else
        {
            int xDiff = r_q - obstacleX;
            int yDiff = c_q - obstacleY;
            int xDiffAbs = std::abs(xDiff);
            int yDiffAbs = std::abs(yDiff);
            if (xDiffAbs != yDiffAbs) continue;

            if (xDiff > 0) // down diagonal
            {
                if (yDiff > 0 && (!nearestDiagonalDownLeftAttacks || yDiffAbs < nearestDiagonalDownLeftAttacks.getValueOr(0))) // left diagonal
                {
                    nearestDiagonalDownLeftAttacks = yDiffAbs;
                }
                else if (yDiff < 0 && (!nearestDiagonalDownRightAttacks || yDiffAbs < nearestDiagonalDownRightAttacks.getValueOr(0))) // right diagonal
                {
                    nearestDiagonalDownRightAttacks = yDiffAbs;
                }
            }
            else if (xDiff < 0) // up diagonal
            {
                if (yDiff > 0 && (!nearestDiagonalUpLeftAttacks || yDiffAbs < nearestDiagonalUpLeftAttacks.getValueOr(0))) // left diagonal
                {
                    nearestDiagonalUpLeftAttacks = yDiffAbs;
                }
                else if (yDiff < 0 && (!nearestDiagonalUpRightAttacks || yDiffAbs < nearestDiagonalUpRightAttacks.getValueOr(0))) // right diagonal
                {
                    nearestDiagonalUpRightAttacks = yDiffAbs;
                }
            }
        }
    }
        std::cout << nearestLeftConstraint.getValueOr(0) << " nearestLeftConstraint\n";
        std::cout << nearestRightConstraint.getValueOr(0) << " nearestRightConstraint\n";
        std::cout << nearestDownConstraint.getValueOr(0) << " nearestDownConstraint\n";
        std::cout << nearestUpConstraint.getValueOr(0) << " nearestUpConstraint\n";
        std::cout << nearestDiagonalDownLeftAttacks.getValueOr(0) << " nearestDiagonalDownLeftAttacks\n";
        std::cout << nearestDiagonalDownRightAttacks.getValueOr(0) << " nearestDiagonalDownRightAttacks\n";
        std::cout << nearestDiagonalUpLeftAttacks.getValueOr(0) << " nearestDiagonalUpLeftAttacks\n";
        std::cout << nearestDiagonalUpRightAttacks.getValueOr(0) << " nearestDiagonalUpRightAttacks\n";
    
    int maxLeftAttacks = c_q - 1;
    int maxRightAttacks = n - c_q;
    int maxDownAttacks = r_q - 1;
    int maxUpAttacks = n - r_q;
    int maxDiagonalDownLeftAttacks = std::min(maxDownAttacks, maxLeftAttacks);
    int maxDiagonalDownRightAttacks = std::min(maxDownAttacks, maxRightAttacks);
    int maxDiagonalUpLeftAttacks = std::min(maxUpAttacks, maxLeftAttacks);
    int maxDiagonalUpRightAttacks = std::min(maxUpAttacks, maxRightAttacks);

std::cout << "\n\n\n nearestLeftConstraint " << c_q - 1 - nearestLeftConstraint.getValueOr(0);
std::cout << "\n nearestRightConstraint " << nearestRightConstraint.getValueOr(n) - c_q - 1;
std::cout << "\n nearestDownConstraint " << r_q - 1 - nearestDownConstraint.getValueOr(0);
std::cout << "\n nearestUpConstraint " << nearestUpConstraint.getValueOr(n) - r_q;
std::cout << "\n nearestDiagonalDownLeftAttacks " << nearestDiagonalDownLeftAttacks.getValueOr(maxDiagonalDownLeftAttacks);
std::cout << "\n nearestDiagonalDownRightAttacks " << nearestDiagonalDownRightAttacks.getValueOr(maxDiagonalDownRightAttacks);
std::cout << "\n nearestDiagonalUpLeftAttacks " << nearestDiagonalUpLeftAttacks.getValueOr(maxDiagonalUpLeftAttacks);
std::cout << "\n nearestDiagonalUpRightAttacks " << nearestDiagonalUpRightAttacks.getValueOr(maxDiagonalUpRightAttacks);
    return c_q - 1 - nearestLeftConstraint.getValueOr(0) +
            nearestRightConstraint.getValueOr(n + 1) - c_q - 1 +
            r_q - 1 - nearestDownConstraint.getValueOr(0) +
            nearestUpConstraint.getValueOr(n + 1) - r_q - 1 +
            nearestDiagonalDownLeftAttacks.getValueOr(maxDiagonalDownLeftAttacks + 1) - 1 +
            nearestDiagonalDownRightAttacks.getValueOr(maxDiagonalDownRightAttacks + 1) - 1 +
            nearestDiagonalUpLeftAttacks.getValueOr(maxDiagonalUpLeftAttacks + 1) - 1 +
            nearestDiagonalUpRightAttacks.getValueOr(maxDiagonalUpRightAttacks + 1) - 1;
}

int main()
{
    auto answer = queensAttack(8, 0, 5, 4,
        {
            {8,3},
            {8,7},
            {7,4},
            {7,7},
            {6,3},
            {5,1},
            {3,2},
            {2,4},
            {1,6},
            {5,7},
        });
    std::cout << "\n\n" <<answer; // answer is 14?
    // int num1 = std::numeric_limits<int>::max();
    // unsigned num2 = std::numeric_limits<unsigned>::max();
    // std::cout << num2<<"\n";
    // unsigned num3 = 4294967293;
    // std::cout << num3<<"\n";
    // num3 += 1;
    // std::cout << num3<<"\n";
    // num3 += 1;
    // std::cout << num3<<"\n";
    // num3 += 1;
    // std::cout << num3<<"\n";
    // num3 += 1;
    // std::cout << num3<<"\n";
        
    //     int a = 3;
    //     int b = 5;
    //     int c = a - b;
    //     int d = std::abs(a - b);
    //     std::cout <<c <<"\n";
    //     std::cout <<d <<"\n";

    return 0;
}
