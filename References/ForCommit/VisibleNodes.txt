#include <deque>
#include <iostream>
#include <string>
#include <vector>
#include <unordered_map>

struct Node
{
    int value;

    std::string previousNodesPath;
    char currentNodePath;
    std::vector<Node*> connectedNodes;
};

// visible nodes are nodes where value is not greater than sum of path leading to it
int countVisibleNodes(
    std::unordered_map<std::string, Node*> idAndNodeMap)
{
    int count = 0;
    std::unordered_map<std::string, int> nodePathCount;

    std::deque<Node*> nodes;
    nodes.push_back(idAndNodeMap["0"]);

    while (!nodes.empty())
    {
        auto currentNode = nodes.front();
        nodes.pop_front();

        nodePathCount[currentNode->previousNodesPath + currentNode->currentNodePath] = 
                nodePathCount[currentNode->previousNodesPath];


        for (auto a :  nodePathCount)
        {
            std::cout << "\nnodePathCount" << a.first << " = " << a.second << " ... " << currentNode->value;
        }
        if (currentNode->previousNodesPath == "" || nodePathCount[currentNode->previousNodesPath] >= currentNode->value)
        {
            ++count;
            nodePathCount[currentNode->previousNodesPath + currentNode->currentNodePath]
                += currentNode->value;
        }

        if (currentNode->connectedNodes.size() != 2) continue;

        currentNode->connectedNodes[0]->previousNodesPath = currentNode->previousNodesPath + currentNode->currentNodePath;
        currentNode->connectedNodes[0]->currentNodePath = '0';
        nodes.push_back(currentNode->connectedNodes[0]);

        currentNode->connectedNodes[1]->previousNodesPath = currentNode->previousNodesPath + currentNode->currentNodePath;
        currentNode->connectedNodes[1]->currentNodePath = '1';
        nodes.push_back(currentNode->connectedNodes[1]);
    }

    return count;
}

int main(int , char** )
{
    std::string input;
    std::getline(std::cin, input);

    std::unordered_map<std::string, Node*> idAndNodeMap;

    //

    idAndNodeMap["0000"] = new Node();
    idAndNodeMap["0000"]->value = 15;

    idAndNodeMap["0001"] = new Node();
    idAndNodeMap["0001"]->value = 9;

    idAndNodeMap["0010"] = new Node();
    idAndNodeMap["0010"]->value = 8;

    idAndNodeMap["0011"] = new Node();
    idAndNodeMap["0011"]->value = 12;

    idAndNodeMap["0100"] = new Node();
    idAndNodeMap["0100"]->value = 13;

    idAndNodeMap["0101"] = new Node();
    idAndNodeMap["0101"]->value = 8;

    idAndNodeMap["0110"] = new Node();
    idAndNodeMap["0110"]->value = 20;

    idAndNodeMap["0111"] = new Node();
    idAndNodeMap["0111"]->value = 2;

    //

    idAndNodeMap["000"] = new Node();
    idAndNodeMap["000"]->value = 4;
    idAndNodeMap["000"]->connectedNodes.push_back(idAndNodeMap["0000"]);
    idAndNodeMap["000"]->connectedNodes.push_back(idAndNodeMap["0001"]);

    idAndNodeMap["001"] = new Node();
    idAndNodeMap["001"]->value = 11;
    idAndNodeMap["001"]->connectedNodes.push_back(idAndNodeMap["0010"]);
    idAndNodeMap["001"]->connectedNodes.push_back(idAndNodeMap["0011"]);

    idAndNodeMap["010"] = new Node();
    idAndNodeMap["010"]->value = 14;
    idAndNodeMap["010"]->connectedNodes.push_back(idAndNodeMap["0100"]);
    idAndNodeMap["010"]->connectedNodes.push_back(idAndNodeMap["0101"]);

    idAndNodeMap["011"] = new Node();
    idAndNodeMap["011"]->value = 10;
    idAndNodeMap["011"]->connectedNodes.push_back(idAndNodeMap["0110"]);
    idAndNodeMap["011"]->connectedNodes.push_back(idAndNodeMap["0111"]);

    //

    idAndNodeMap["00"] = new Node();
    idAndNodeMap["00"]->value = 2;
    idAndNodeMap["00"]->connectedNodes.push_back(idAndNodeMap["000"]);
    idAndNodeMap["00"]->connectedNodes.push_back(idAndNodeMap["001"]);

    idAndNodeMap["01"] = new Node();
    idAndNodeMap["01"]->value = 3;
    idAndNodeMap["01"]->connectedNodes.push_back(idAndNodeMap["010"]);
    idAndNodeMap["01"]->connectedNodes.push_back(idAndNodeMap["011"]);

    //

    idAndNodeMap["0"] = new Node();
    idAndNodeMap["0"]->value = 7;
    idAndNodeMap["0"]->connectedNodes.push_back(idAndNodeMap["00"]);
    idAndNodeMap["0"]->connectedNodes.push_back(idAndNodeMap["01"]);
    idAndNodeMap["0"]->previousNodesPath = "";
    idAndNodeMap["0"]->currentNodePath = '0';


    std::cout << " eto " << countVisibleNodes(idAndNodeMap);





    return 0;
}
