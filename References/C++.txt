#include <deque>
#include <iostream>
#include <string>
#include <vector>
#include <unordered_map>

struct Node
{
    int value;

    std::string previousNodesPath;
    char currentNodePath;
    std::vector<Node*> connectedNodes;
};

// Count the visible nodes present in a tree
// Visible nodes are nodes where value is not greater than sum of path leading to it
int countVisibleNodes(
    std::unordered_map<std::string, Node*> idAndNodeMap)
{
    int count = 0;
    std::unordered_map<std::string, int> nodePathCount;

    std::deque<Node*> nodes;
    nodes.push_back(idAndNodeMap["0"]);

    while (!nodes.empty())
    {
        auto currentNode = nodes.front();
        nodes.pop_front();

        nodePathCount[currentNode->previousNodesPath + currentNode->currentNodePath] =
                nodePathCount[currentNode->previousNodesPath];


        for (auto a :  nodePathCount)
        {
            std::cout << "\nnodePathCount" << a.first << " = " << a.second << " ... " << currentNode->value;
        }
        if (currentNode->previousNodesPath == "" || nodePathCount[currentNode->previousNodesPath] >= currentNode->value)
        {
            ++count;
            nodePathCount[currentNode->previousNodesPath + currentNode->currentNodePath]
                += currentNode->value;
        }

        if (currentNode->connectedNodes.size() != 2) continue;

        currentNode->connectedNodes[0]->previousNodesPath = currentNode->previousNodesPath + currentNode->currentNodePath;
        currentNode->connectedNodes[0]->currentNodePath = '0';
        nodes.push_back(currentNode->connectedNodes[0]);

        currentNode->connectedNodes[1]->previousNodesPath = currentNode->previousNodesPath + currentNode->currentNodePath;
        currentNode->connectedNodes[1]->currentNodePath = '1';
        nodes.push_back(currentNode->connectedNodes[1]);
    }

    return count;
}

int main(int , char** )
{
    std::string input;
    std::getline(std::cin, input);

    std::unordered_map<std::string, Node*> idAndNodeMap;

    //

    idAndNodeMap["0000"] = new Node();
    idAndNodeMap["0000"]->value = 15;

    idAndNodeMap["0001"] = new Node();
    idAndNodeMap["0001"]->value = 9;

    idAndNodeMap["0010"] = new Node();
    idAndNodeMap["0010"]->value = 8;

    idAndNodeMap["0011"] = new Node();
    idAndNodeMap["0011"]->value = 12;

    idAndNodeMap["0100"] = new Node();
    idAndNodeMap["0100"]->value = 13;

    idAndNodeMap["0101"] = new Node();
    idAndNodeMap["0101"]->value = 8;

    idAndNodeMap["0110"] = new Node();
    idAndNodeMap["0110"]->value = 20;

    idAndNodeMap["0111"] = new Node();
    idAndNodeMap["0111"]->value = 2;

    //

    idAndNodeMap["000"] = new Node();
    idAndNodeMap["000"]->value = 4;
    idAndNodeMap["000"]->connectedNodes.push_back(idAndNodeMap["0000"]);
    idAndNodeMap["000"]->connectedNodes.push_back(idAndNodeMap["0001"]);

    idAndNodeMap["001"] = new Node();
    idAndNodeMap["001"]->value = 11;
    idAndNodeMap["001"]->connectedNodes.push_back(idAndNodeMap["0010"]);
    idAndNodeMap["001"]->connectedNodes.push_back(idAndNodeMap["0011"]);

    idAndNodeMap["010"] = new Node();
    idAndNodeMap["010"]->value = 14;
    idAndNodeMap["010"]->connectedNodes.push_back(idAndNodeMap["0100"]);
    idAndNodeMap["010"]->connectedNodes.push_back(idAndNodeMap["0101"]);

    idAndNodeMap["011"] = new Node();
    idAndNodeMap["011"]->value = 10;
    idAndNodeMap["011"]->connectedNodes.push_back(idAndNodeMap["0110"]);
    idAndNodeMap["011"]->connectedNodes.push_back(idAndNodeMap["0111"]);

    //

    idAndNodeMap["00"] = new Node();
    idAndNodeMap["00"]->value = 2;
    idAndNodeMap["00"]->connectedNodes.push_back(idAndNodeMap["000"]);
    idAndNodeMap["00"]->connectedNodes.push_back(idAndNodeMap["001"]);

    idAndNodeMap["01"] = new Node();
    idAndNodeMap["01"]->value = 3;
    idAndNodeMap["01"]->connectedNodes.push_back(idAndNodeMap["010"]);
    idAndNodeMap["01"]->connectedNodes.push_back(idAndNodeMap["011"]);

    //

    idAndNodeMap["0"] = new Node();
    idAndNodeMap["0"]->value = 7;
    idAndNodeMap["0"]->connectedNodes.push_back(idAndNodeMap["00"]);
    idAndNodeMap["0"]->connectedNodes.push_back(idAndNodeMap["01"]);
    idAndNodeMap["0"]->previousNodesPath = "";
    idAndNodeMap["0"]->currentNodePath = '0';


    std::cout << " eto " << countVisibleNodes(idAndNodeMap);

    return 0;
}

-------------------------------------------------------

//https://www.hackerrank.com/challenges/encryption/problem

/*
An English text needs to be encrypted using the following encryption scheme.
First, the spaces are removed from the text. Let L be the length of this text.
Then, characters are written into a grid, whose rows and columns have the following constraints:
sqrt(L) <= row <= column <= sqrt(L) where x is floor function and x is ceil funtion

For example, the sentence s = if man was meant to stay on the ground god would have given us roots,
after removing spaces is 54 characters long. sqrt(54) is between 7 and 8, so it is written in the form of a grid with 7 rows and 8 columns.

ifmanwas
meanttos
tayonthe
groundgo
dwouldha
vegivenu
sroots

Ensure that rows x columns >= L
If multiple grids satisfy the above conditions, choose the one with the minimum area, i.e. rows x columns

The encoded message is obtained by displaying the characters in a column, inserting a space, and then displaying the next column and inserting a space, and so on. For example, the encoded message for the above rectangle is:

imtgdvs fearwer mayoogo anouuio ntnnlvt wttddes aohghn sseoau

You will be given a message to encode and print.
*/

#include <bits/stdc++.h>

using namespace std;

// Complete the encryption function below.
unsigned removeSpacesAndGetNewSize(std::string& str)
{
    unsigned slow = 0;
    unsigned fast = 0;
    while (fast < str.size())
    {
        if (str[fast] != ' ')
        {
            str[slow++] = str[fast];
        }
        ++fast;
    }
    return slow;
}

std::pair<unsigned, unsigned> getRowsAndColumnsCount(const unsigned strSize)
{
    double sqrtResult = sqrt(strSize);
    unsigned rowsCount = sqrtResult;
    unsigned colsCount = ceil(sqrtResult);
    if (rowsCount * colsCount < strSize) ++rowsCount;
    return {rowsCount, colsCount};
}

string encryption(string s)
{
    unsigned sizeWithoutSpaces = removeSpacesAndGetNewSize(s);
    if (sizeWithoutSpaces == 0) return {};

    auto rowsAndCols = getRowsAndColumnsCount(sizeWithoutSpaces);
    unsigned rowsCount = rowsAndCols.first;
    unsigned colsCount = rowsAndCols.second;

    std::string result;
    for (unsigned col = 0; col < colsCount; ++col)
    {
        for (unsigned row = 0, currentCol = col;
            row < rowsCount && currentCol < sizeWithoutSpaces;
            ++row, currentCol += colsCount)
        {
            result += s[currentCol];
        }
        result += " ";
    }

    return result;
}

int main()
{
    ofstream fout(getenv("OUTPUT_PATH"));

    string s;
    getline(cin, s);

    string result = encryption(s);

    fout << result << "\n";

    fout.close();

    return 0;
}

---------------------------------------------------------------

// https://www.hackerrank.com/challenges/bigger-is-greater/problem

/*
Lexicographical order is often known as alphabetical order when dealing with strings. A string is greater than another string if it comes later in a lexicographically sorted list.

Given a word, create a new word by swapping some or all of its characters. This new word must meet two criteria:
1. It must be greater than the original word
2. It must be the smallest word that meets the first condition

For example, given the word w = abcd, the next largest word is abdc.

Complete the function biggerIsGreater below to create and return the new string meeting the criteria. If it is not possible, return no answer.

*/

#include <bits/stdc++.h>

using namespace std;

// Complete the biggerIsGreater function below.
string biggerIsGreater(string w)
{
    int strSize = static_cast<int>(w.size());
    for (int ctr = strSize - 1; ctr > 0; --ctr)
    {
        if (w[ctr] > w[ctr - 1])
        {
            std::sort(w.begin() + ctr, w.end());
            for (int ctr2 = ctr; ctr2 < strSize; ++ctr2)
            {
                if (w[ctr2] > w[ctr - 1])
                {
                    std::swap(w[ctr - 1], w[ctr2]);
                    return w;
                }
            }
            return "no answer";
        }
    }
    return "no answer";
}

int main()
{
    ofstream fout(getenv("OUTPUT_PATH"));

    int T;
    cin >> T;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    for (int T_itr = 0; T_itr < T; T_itr++) {
        string w;
        getline(cin, w);

        string result = biggerIsGreater(w);

        fout << result << "\n";
    }

    fout.close();

    return 0;
}

----------------------------------------------------------------------

// https://www.hackerrank.com/challenges/kaprekar-numbers/problem

/*
A modified Kaprekar number is a positive whole number with a special property. If you square it, then split the number into two integers and sum those integers, you have the same value you started with.

Consider a positive whole number n with d digits. We square n to arrive at a number that is either 2 x d digits long or (2 x d) - 1 digits long. Split the string representation of the square into two parts, l and r. The right hand part, r must be d digits long. The left is the remaining substring. Convert those two substrings back to integers, add them and see if you get n.

For example, if n = 5, d = 1 then n^2 = 25. We split that into two strings and convert them back to integers 2 and 5. We test 2 + 5 = 7 != 5, so this is not a modified Kaprekar number. If n = 9, still d = 1, and n^2 = 81. This gives us 1 + 8 = 9, the original n.

Note: r may have leading zeros.

Here's an explanation from Wikipedia about the ORIGINAL Kaprekar Number (spot the difference!):

In mathematics, a Kaprekar number for a given base is a non-negative integer, the representation of whose square in that base can be split into two parts that add up to the original number again. For instance, 45 is a Kaprekar number, because 45² = 2025 and 20+25 = 45.

Given two positive integers p and q where p is lower than q, write a program to print the modified Kaprekar numbers in the range between p and q, inclusive.

*/

#include <bits/stdc++.h>

using namespace std;

// Complete the kaprekarNumbers function below.
int countDigits(int num)
{
    return static_cast<int>(std::to_string(num).size());
}

void kaprekarNumbers(int p, int q)
{
    bool found = false;
    while (p <= q)
    {
        int digitsCount = countDigits(p);
        long product = static_cast<long>(p) * static_cast<long>(p);

        std::string productStr = std::to_string(product);
        int productStrSize = static_cast<int>(productStr.size());
        int dividerIndex = productStrSize - digitsCount;
        std::string leftNum = productStr.substr(0, dividerIndex);
        std::string rightNum = productStr.substr(dividerIndex, digitsCount);

        if (leftNum.empty()) leftNum = "0";

        if (std::stoi(leftNum) + std::stoi(rightNum) == p)
        {
            std::cout << p << " ";
            found = true;
        }
        ++p;
    }
    if (!found) std::cout << "INVALID RANGE";
}

int main()
{
    int p;
    cin >> p;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    int q;
    cin >> q;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    kaprekarNumbers(p, q);

    return 0;
}

-----------------------------------------------------

// https://www.hackerrank.com/challenges/how-many-substrings/problem

/*
Consider a string of n characters, s, of where each character is indexed from 0 to n-1.

You are given q queries in the form of two integer indices: left and right. For each query, count and print the number of different substrings of s in the inclusive range between left and right.

Note: Two substrings are different if their sequence of characters differs by at least one. For example, given the string s = aab, substrings s[0,0] = a and s[1,1] = a are the same but substrings s[0,1] = aa and s[1,2] = ab are different.
*/

#include <bits/stdc++.h>

using namespace std;

vector<string> split_string(string);

/*
 * Complete the countSubstrings function below.
 */
vector<int> countSubstrings(string s, vector<vector<int>> queries)
{
    /*
     * Write your code here.
     */
    std::vector<int> result;
    for (const auto& query : queries)
    {
        unsigned toSubtract = 0u;
        std::unordered_set<unsigned> indexesWithRepeatedSubstrings;
        std::string targetStr = s.substr(query[0], query[1] - query[0] + 1);
        std::string currentStr = ""; // targetStr.substr(0, index);
        for (unsigned index = 1u; index < targetStr.size(); ++index)
        {
            currentStr += targetStr[index - 1];
            if (currentStr.find(targetStr[index]) != std::string::npos)
            {
                ++toSubtract;
                indexesWithRepeatedSubstrings.insert(index);
            }

            for (auto it = indexesWithRepeatedSubstrings.begin(); it != indexesWithRepeatedSubstrings.end(); )
            {
                if (*it == index)
                {
                    ++it;
                    continue;
                }

                std::string repeatedSubstr = targetStr.substr(*it, index - *it + 1);
                if (currentStr.find(repeatedSubstr) != std::string::npos)
                {
                    ++toSubtract;
                    ++it;
                }
                else
                {
                    indexesWithRepeatedSubstrings.erase(it++);
                }
            }
        }
        unsigned total = ((1 + targetStr.size()) * targetStr.size()) / 2;
        result.push_back(total - toSubtract);
    }
    return result;
}

int main()
{
    ofstream fout(getenv("OUTPUT_PATH"));

    string nq_temp;
    getline(cin, nq_temp);

    vector<string> nq = split_string(nq_temp);

    int n = stoi(nq[0]);

    int q = stoi(nq[1]);

    string s;
    getline(cin, s);

    vector<vector<int>> queries(q);
    for (int queries_row_itr = 0; queries_row_itr < q; queries_row_itr++) {
        queries[queries_row_itr].resize(2);

        for (int queries_column_itr = 0; queries_column_itr < 2; queries_column_itr++) {
            cin >> queries[queries_row_itr][queries_column_itr];
        }

        cin.ignore(numeric_limits<streamsize>::max(), '\n');
    }

    vector<int> result = countSubstrings(s, queries);

    for (int result_itr = 0; result_itr < result.size(); result_itr++) {
        fout << result[result_itr];

        if (result_itr != result.size() - 1) {
            fout << "\n";
        }
    }

    fout << "\n";

    fout.close();

    return 0;
}

vector<string> split_string(string input_string) {
    string::iterator new_end = unique(input_string.begin(), input_string.end(), [] (const char &x, const char &y) {
        return x == y and x == ' ';
    });

    input_string.erase(new_end, input_string.end());

    while (input_string[input_string.length() - 1] == ' ') {
        input_string.pop_back();
    }

    vector<string> splits;
    char delimiter = ' ';

    size_t i = 0;
    size_t pos = input_string.find(delimiter);

    while (pos != string::npos) {
        splits.push_back(input_string.substr(i, pos - i));

        i = pos + 1;
        pos = input_string.find(delimiter, i);
    }

    splits.push_back(input_string.substr(i, min(pos, input_string.length()) - i + 1));

    return splits;
}

----------------------------------------------------------------------------

// https://www.hackerrank.com/challenges/larrys-array/problem

/*
Larry has been given a permutation of a sequence of natural numbers incrementing from 1 as an array. He must determine whether the array can be sorted using the following operation any number of times:

Choose any 3 consecutive indices and rotate their elements in such a way that ABC -> BCA -> CAB -> ABC.
For example, if A = {1, 6, 5, 2, 4, 3}:

A       rotate
[1,6,5,2,4,3]   [6,5,2]
[1,5,2,6,4,3]   [5,2,6]
[1,2,6,5,4,3]   [5,4,3]
[1,2,6,3,5,4]   [6,3,5]
[1,2,3,5,6,4]   [5,6,4]
[1,2,3,4,5,6]

YES
On a new line for each test case, print YES if A can be fully sorted. Otherwise, print NO.
*/

#include <bits/stdc++.h>

using namespace std;

vector<string> split_string(string);

// Complete the larrysArray function below.
void print(const std::vector<int>& vec)
{
    std::cout << "\nPrinting vector: ";
    for (const auto& item : vec)
    {
        std::cout << " " << item;
    }
}

void larrysSort(
    const unsigned index,
    std::vector<int>& vec)
{
    if (index + 2 >= vec.size()) return;
    while (vec[index] > vec[index+1] || vec[index] > vec[index+2])
    {
        std::swap(vec[index], vec[index+2]);
        std::swap(vec[index+1], vec[index+2]);
    }
}

bool isTheCurrentIndexTheSmallest(
    const unsigned index,
    const std::vector<int>& vec)
{
    if (index + 2 >= vec.size()) return false;
    return vec[index] < vec[index+1] && vec[index] < vec[index+2];
}

bool isSorted(const std::vector<int>& vec)
{
    for (unsigned index = 0u; index < vec.size() - 1; ++index)
    {
        if (vec[index] > vec[index+1]) return false;
    }
    return true;
}
std::string larrysArray(std::vector<int> A)
{
    int vecSize = static_cast<int>(A.size());

    if (vecSize < 3) return "NO";
    for (int index = 0u; index <= vecSize - 3; ++index)
    {
        print(A);

        if (isTheCurrentIndexTheSmallest(index, A)) continue;
        larrysSort(index, A);
        print(A);

        int forward = 0;
        for (int reverse = index - 1; reverse >= 0; --reverse)
        {
            if (isTheCurrentIndexTheSmallest(reverse, A))
            {
                forward = reverse + 1;
                break;
            }
            larrysSort(reverse, A);
        }
        print(A);

        for (; forward <= index; ++forward)
        {
            if (isTheCurrentIndexTheSmallest(forward, A)) continue;
            larrysSort(forward, A);
        }
        print(A);

        if (isTheCurrentIndexTheSmallest(index, A)) continue;
        larrysSort(index, A);
    }

    return isSorted(A) ?
            "YES" :
            "NO";
}

int main()
{
    ofstream fout(getenv("OUTPUT_PATH"));

    int t;
    cin >> t;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    for (int t_itr = 0; t_itr < t; t_itr++) {
        int n;
        cin >> n;
        cin.ignore(numeric_limits<streamsize>::max(), '\n');

        string A_temp_temp;
        getline(cin, A_temp_temp);

        vector<string> A_temp = split_string(A_temp_temp);

        vector<int> A(n);

        for (int i = 0; i < n; i++) {
            int A_item = stoi(A_temp[i]);

            A[i] = A_item;
        }

        string result = larrysArray(A);

        fout << result << "\n";
    }

    fout.close();

    return 0;
}

vector<string> split_string(string input_string) {
    string::iterator new_end = unique(input_string.begin(), input_string.end(), [] (const char &x, const char &y) {
        return x == y and x == ' ';
    });

    input_string.erase(new_end, input_string.end());

    while (input_string[input_string.length() - 1] == ' ') {
        input_string.pop_back();
    }

    vector<string> splits;
    char delimiter = ' ';

    size_t i = 0;
    size_t pos = input_string.find(delimiter);

    while (pos != string::npos) {
        splits.push_back(input_string.substr(i, pos - i));

        i = pos + 1;
        pos = input_string.find(delimiter, i);
    }

    splits.push_back(input_string.substr(i, min(pos, input_string.length()) - i + 1));

    return splits;
}

----------------------------------------

/*
A binary gap within a positive integer N is any maximal sequence of consecutive zeros that is surrounded by ones at both ends in the binary representation of N.

For example, number 9 has binary representation 1001 and contains a binary gap of length 2. The number 529 has binary representation 1000010001 and contains two binary gaps: one of length 4 and one of length 3. The number 20 has binary representation 10100 and contains one binary gap of length 1. The number 15 has binary representation 1111 and has no binary gaps. The number 32 has binary representation 100000 and has no binary gaps.

Write a function:

int solution(int N);

that, given a positive integer N, returns the length of its longest binary gap. The function should return 0 if N doesn't contain a binary gap.

For example, given N = 1041 the function should return 5, because N has binary representation 10000010001 and so its longest binary gap is of length 5. Given N = 32 the function should return 0, because N has binary representation '100000' and thus no binary gaps.

Write an efficient algorithm for the following assumptions:

N is an integer within the range [1..2,147,483,647].
*/

int solution(int N)
{
    // write your code in C++14 (g++ 6.2.0)
    while (N > 0 && N % 2 != 1)
    {
        N /= 2;
    }
    N /= 2;

    int maxZeros = 0;
    int currentZeroCount = 0;
    while (N > 0)
    {
        int remainder = N % 2;
        if (remainder == 0)
        {
            ++currentZeroCount;
        }
        else
        {
            maxZeros = std::max(maxZeros, currentZeroCount);
            currentZeroCount = 0;
        }
        N /= 2;
    }
    return maxZeros;
}

----------------------------------------
/*
A non-empty array A consisting of N integers is given. The array contains an odd number of elements, and each element of the array can be paired with another element that has the same value, except for one element that is left unpaired.

For example, in array A such that:

  A[0] = 9  A[1] = 3  A[2] = 9
  A[3] = 3  A[4] = 9  A[5] = 7
  A[6] = 9
the elements at indexes 0 and 2 have value 9,
the elements at indexes 1 and 3 have value 3,
the elements at indexes 4 and 6 have value 9,
the element at index 5 has value 7 and is unpaired.
Write a function:

int solution(vector<int> &A);

that, given an array A consisting of N integers fulfilling the above conditions, returns the value of the unpaired element.

For example, given array A such that:

  A[0] = 9  A[1] = 3  A[2] = 9
  A[3] = 3  A[4] = 9  A[5] = 7
  A[6] = 9
the function should return 7, as explained in the example above.

Write an efficient algorithm for the following assumptions:

N is an odd integer within the range [1..1,000,000];
each element of array A is an integer within the range [1..1,000,000,000];
all but one of the values in A occur an even number of times.
Copyright 2009–2019 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited.
*/

// you can use includes, for example:
#include <algorithm>
#include <unordered_set>

// you can write to stdout for debugging purposes, e.g.
// cout << "this is a debug message" << endl;

int solution(vector<int> &A)
{
    // write your code in C++14 (g++ 6.2.0)

    // // Solution 1
    // // This has not been personally chosen due to the added time complexity of
    // // sorting plus the additional time complexity of iterating again to the
    // // whole vector inputs.
    // std::sort(A.begin(), A.end());
    // for (unsigned it = 0u; it < A.size(); it += 2)
    // {
    //     if (it + 1 >= A.size() || A[it] != A[it+1]) return A[it];
    // }
    // return 0; // something must be wrong if this is reached!

    // Solution 2
    // This has been chosen because time complexity is just linear O(n) along with
    // number of input plus the fact that search and deletion in the unordered_Set
    // is just O(1) due to hash functionality.
    std::unordered_set<int> toBePaired;
    for (const auto& item : A)
    {
        // auto [it, isInserted] = toBePaired.insert(item); // requires -std=c++17
        // if (!isInserted) toBePaired.erase(it); // requires -std=c++17
        auto ret = toBePaired.insert(item);
        if (!ret.second) toBePaired.erase(ret.first);
    }
    return toBePaired.empty() ?
            0 :
            *(toBePaired.begin());
}

---------------------------------------------------------------------------
/*
Divide the number

Given a positive integer N, count the number of possible ways to represent N as sum of four positive integers.

Input
The first line of input contains an integer T denoting the number of test cases. Then T test cases follow.
The first line of each test case contains a positve integer N.

Output
Print out the number of ways to divide N in four parts.

Constraints
1 <= T <= 100
0 <= N <=300

Examples

Input
3
5
41
500

Output
1
511
873264

Explanation

Output 1:  There is only one way to divide 5  (1, 1, 1, 2)

** For More Input/Output Examples Use 'Expected Output' option **

Examples :

Input:  n =  5
Output: 1
There is only one way (1, 1, 1, 2)

Input:  n =  6
Output: 2
There are two ways (1, 1, 1, 3) and
(1, 1, 2, 2)

Input:  n =  8
Output: 5
There are five ways (2, 2, 2, 2), (1, 1, 1, 5),
(1, 1, 3, 3), (1, 1, 2, 4) and (1, 2, 2, 3)

Analysis:
target sum = 17
answer = 39 combinations
Combinations =
1 1 1 14
1 1 2 13
1 1 3 12
1 1 4 11
1 1 5 10
1 1 6 9
1 1 7 8

1 2 2 12
1 2 3 11
1 2 4 10
1 2 5 9
1 2 6 8
1 2 7 7

1 3 3 10
1 3 4 9
1 3 5 8
1 3 6 7

1 4 4 8
1 4 5 7
1 4 6 6

1 5 5 6

2 2 2 11
2 2 3 10
2 2 4 9
2 2 5 8
2 2 6 7

2 3 3 9
2 3 4 8
2 3 5 7
2 3 6 6

2 4 4 7
2 4 5 6

2 5 5 5

3 3 3 8
3 3 4 7
3 3 5 6

3 4 4 6
3 4 5 5

4 4 4 5


target sum = 12
answer = 15 combinations
Combinations =

1 1 1 9
1 1 2 8
1 1 3 7
1 1 4 6
1 1 5 5

1 2 2 7
1 2 3 6
1 2 4 5

1 3 3 5
1 3 4 4

2 2 2 6
2 2 3 5
2 2 4 4

2 3 3 4

3 3 3 3

*/

#include <iostream>
using namespace std;

int countWaysOfFourPositiveIntegers(const int N)
{
    int result = 0;
    for (int ctr = 1; ctr <= N - 3; ++ctr)
    {
        bool isAdditionToResultMade = true;
        for (int ctr2 = ctr; isAdditionToResultMade; ++ctr2)
        {
            isAdditionToResultMade = false;
            int remaining = N - (ctr + ctr2);
            int numberOfAddCombinationsForRemaining = remaining / 2;
            int currentTotalCount = numberOfAddCombinationsForRemaining - ctr2 + 1;

            if (currentTotalCount > 0)
            {
                result += currentTotalCount;
                isAdditionToResultMade = true;
            }
        }
    }
    return result;
}

int main() {
    //code
    unsigned inputCount;
    std::cin >> inputCount;
    for (unsigned ctr = 0u; ctr < inputCount; ++ctr)
    {
        int N;
        std::cin >> N;
        std::cout << countWaysOfFourPositiveIntegers(N) << "\n";
    }
    return 0;
}

----------------------------------------------
/*
Merge k Sorted Arrays

Given K sorted arrays arranged in form of a matrix. The task is to merge them. You need to complete mergeKArrays() function which takes 2 arguments, an arr[k][k] 2D Matrix containing k sorted arrays and an integer k denoting the number of sorted arrays. The function should return a pointer to the merged sorted arrays.

Input:
The first line of input contains the number of test cases, then T test cases follows. Each test case will contain an integer N denoting the number of sorted arrays. Then in the next line contains all the elements of the array separated by space.

Output:
The output will be the sorted merged array.

User Task:
The task is to complete the function mergeKArrays() which takes two arguments, and returns pointer to the modified array.

Constraints:
1 <= T <= 50
1 <= N <= 103
1 <= K <= 10

Example:
Input:
1
3
1 2 3 4 5 6 7 8 9

Output:
1 2 3 4 5 6 7 8 9

Explanation:
Testcase 1:
Above test case has 3 sorted arrays of size 3, 3, 3
arr[][] = [[1, 2, 3],

             [4, 5, 6],

             [7, 8, 9]]
The merged list will be [1, 2, 3, 4, 5, 6, 7, 8, 9].
*/
/*This is a function problem.You only need to complete the function given below*/
// your task is tocomplete this function
// function should return an pointer to output array int*
// of size k*k
int *mergeKArrays(int arr[][N], int k)
{
//code here
    std::vector<int> resultVec;
    for (int ctr = 0; ctr < k; ++ctr)
    {
        for (int ctr2 = 0; ctr2 < k; ++ctr2)
        {
            resultVec.push_back(arr[ctr][ctr2]);
        }
    }
    std::sort(resultVec.begin(), resultVec.end());
    int ctr = 0;;
    int* result = new int[k*k];
    for (auto it = resultVec.begin(); it < resultVec.end(); ++it)
    {
        result[ctr++] = *it;
    }
    return result;
}


----------------------------------------------

/*
Merge Without Extra Space

Given two sorted arrays arr1[] and arr2[] in non-decreasing order with size n and m. The task is to merge the two sorted arrays into one sorted array (in non-decreasing order).

Note: Expected time complexity is O((n+m) log(n+m)). DO NOT use extra space.  We need to modify existing arrays as following.

Input: arr1[] = {10};
       arr2[] = {2, 3};
Output: arr1[] = {2}
        arr2[] = {3, 10}

Input: arr1[] = {1, 5, 9, 10, 15, 20};
       arr2[] = {2, 3, 8, 13};
Output: arr1[] = {1, 2, 3, 5, 8, 9}
        arr2[] = {10, 13, 15, 20}
Input:
First line contains an integer T, denoting the number of test cases. First line of each test case contains two space separated integers X and Y, denoting the size of the two sorted arrays. Second line of each test case contains X space separated integers, denoting the first sorted array P. Third line of each test case contains Y space separated integers, denoting the second array Q.

Output:
For each test case, print (X + Y) space separated integer representing the merged array.

Constraints:
1 <= T <= 100
1 <= X, Y <= 5*104
0 <= arr1i, arr2i <= 109

Example:
Input:
2
4 5
1 3 5 7
0 2 6 8 9
2 3
10 12
5 18 20

Output:
0 1 2 3 5 6 7 8 9
5 10 12 18 20
*/

#include <iostream>
#include <vector>
using namespace std;

void merge(
    std::vector<int> arr1,
    std::vector<int> arr2)
{
    unsigned totalCount = arr1.size() + arr2.size();
    unsigned arr1Index = 0u;
    unsigned arr2Index = 0u;
    while (arr1Index < arr1.size() && arr2Index < arr2.size())
    {
        if (arr1[arr1Index] < arr2[arr2Index])
        {
            std::cout << arr1[arr1Index++] << " ";
        }
        else
        {
            std::cout << arr2[arr2Index++] << " ";
        }
    }
    while (arr1Index < arr1.size())
    {
        std::cout << arr1[arr1Index++] << " ";
    }
    while (arr2Index < arr2.size())
    {
        std::cout << arr2[arr2Index++] << " ";
    }
    std::cout << "\n";
}

int main() {
    //code
    unsigned T;
    std::cin >> T;
    for (unsigned ctr = 0u; ctr < T; ++ctr)
    {
        unsigned X;
        unsigned Y;
        std::cin >> X >> Y;

        std::vector<int> arr1;
        std::vector<int> arr2;
        arr1.reserve(X);
        arr2.reserve(Y);

        for (unsigned ctr2 = 0u; ctr2 < X + Y; ++ctr2)
        {
            int temp;
            std::cin >> temp;
            if (ctr2 < X) arr1.push_back(temp);
            else          arr2.push_back(temp);
        }
        merge(arr1, arr2);
    }
    return 0;
}

---------------------------------------------------------------------------

/*
Rearrange Array Alternately

Given a sorted array of positive integers. Your task is to rearrange  the array elements alternatively i.e first element should be max value, second should be min value, third should be second max, fourth should be second min and so on...

Note: O(1) extra space is allowed. Also, try to modify the input array as required.

Input:
First line of input conatins number of test cases T. First line of test case contain an integer denoting the array size N and second line of test case contain N space separated integers denoting the array elements.

Output:
Output the modified array with alternated elements.

Constraints:
1 <=T<= 100
1 <=N<= 107
1 <=arr[i]<= 107

Example:
Input:
2
6
1 2 3 4 5 6
11
10 20 30 40 50 60 70 80 90 100 110

Output:
6 1 5 2 4 3
110 10 100 20 90 30 80 40 70 50 60

Explanation:
Testcase 1: Max element = 6, min = 1, second max = 5, second min = 2, and so on... Modified array is : 6 1 5 2 4 3.
*/


#include <iostream>
#include <vector>
using namespace std;

/* Unoptimized solution
void rearrangeInPlace(std::vector<int>& arr)
{
    int leftIndex = 0u;
    int rightIndex = arr.size() - 1;
    int lastIndex = arr.size() - 1;

    while (leftIndex < rightIndex)
    {
        std::swap(arr[rightIndex--], arr[leftIndex++]);
        std::swap(arr[lastIndex], arr[leftIndex++]);

        int newlyInsertedLastIndex = lastIndex;
        while (rightIndex < newlyInsertedLastIndex - 1 && leftIndex < newlyInsertedLastIndex)
        {
            std::swap(arr[newlyInsertedLastIndex], arr[newlyInsertedLastIndex-1]);
            --newlyInsertedLastIndex;
        }
    }
    while (leftIndex <= lastIndex)
    {
        int queuedLastIndex = lastIndex;
        while (queuedLastIndex > leftIndex + 1)
        {
            std::swap(arr[queuedLastIndex], arr[queuedLastIndex-1]);
            --queuedLastIndex;
        }
        leftIndex += 2;
    }
}
*/

// Use long if necessary
void rearrangeInPlace(std::vector<int>& arr)
{
    int traverseToRight = 0u;
    int traverseToLeft = arr.size() - 1u;
    const int BASE_NUMBER = arr.back() + 1;

    for (unsigned ctr = 0u; ctr < arr.size(); ++ctr)
    {
        if (ctr % 2 == 0)
        {
            int originalNumber = arr[traverseToLeft] % BASE_NUMBER;
            int numberToStoreInCurrentIndex = originalNumber * BASE_NUMBER;
            arr[ctr] += numberToStoreInCurrentIndex;
            --traverseToLeft;
        }
        else
        {
            int originalNumber = arr[traverseToRight] % BASE_NUMBER;
            int numberToStoreInCurrentIndex = originalNumber * BASE_NUMBER;
            arr[ctr] += numberToStoreInCurrentIndex;
            ++traverseToRight;
        }
    }

    for (unsigned ctr = 0u; ctr < arr.size(); ++ctr)
    {
        arr[ctr] /= BASE_NUMBER;
    }
}

int main() {
    //code
    unsigned T;
    std::cin >> T;
    for (unsigned ctr = 0u; ctr < T; ++ctr)
    {
        unsigned N;
        std::cin >> N;

        std::vector<int> arr;
        arr.reserve(N);

        for (unsigned ctr2 = 0u; ctr2 < N; ++ctr2)
        {
            int temp;
            std::cin >> temp;
            arr.push_back(temp);
        }
        rearrangeInPlace(arr);
        for (const auto& elem : arr)
        {
            std::cout << elem << " ";
        }
        std::cout << "\n";
    }
    return 0;
}

---------------------------------------------------------------------------

/*
Subarray with given sum

Given an unsorted array A of size N of non-negative integers, find a continuous sub-array which adds to a given number S.

Input:
The first line of input contains an integer T denoting the number of test cases. Then T test cases follow. Each test case consists of two lines. The first line of each test case is N and S, where N is the size of array and S is the sum. The second line of each test case contains N space separated integers denoting the array elements.

Output:
For each testcase, in a new line, print the starting and ending positions(1 indexing) of first such occuring subarray from the left if sum equals to subarray, else print -1.

Constraints:
1 <= T <= 100
1 <= N <= 107
1 <= Ai <= 1010

Example:
Input:
2
5 12
1 2 3 7 5
10 15
1 2 3 4 5 6 7 8 9 10
Output:
2 4
1 5

Explanation :
Testcase1: sum of elements from 2nd position to 4th position is 12
Testcase2: sum of elements from 1st position to 5th position is 15

** For More Input/Output Examples Use 'Expected Output' option **
*/

#include <iostream>
#include <vector>

void findSubarray(
    const std::vector<int>& arr,
    const int targetSum)
{
    int lowerBound = 0;
    int sum = 0;

    for (unsigned ctr = 0u; ctr < arr.size(); ++ctr)
    {
        sum += arr[ctr];
        if (sum == targetSum)
        {
            std::cout << lowerBound + 1 << " " << ctr + 1 << "\n";
            return;
        }
        else if (sum > targetSum)
        {
            sum = sum - arr[lowerBound++] - arr[ctr--];
        }
    }
    std::cout << "-1\n";
}

int main() {
    //code
    unsigned T;
    std::cin >> T;
    for (unsigned ctr = 0u; ctr < T; ++ctr)
    {
        unsigned N;
        int S;
        std::cin >> N >> S;

        std::vector<int> arr;
        for (unsigned ctr2 = 0u; ctr2 < N; ++ctr2)
        {
            int temp;
            std::cin >> temp;
            arr.push_back(temp);
        }
        findSubarray(arr, S);
    }
    return 0;
}

---------------------------------------------------------------------------

/*
Count the triplets

Given an array of distinct integers. The task is to count all the triplets such that sum of two elements equals the third element.

Input:
The first line of input contains an integer T denoting the number of test cases. Then T test cases follow. Each test case consists of two lines. First line of each test case contains an Integer N denoting size of array and the second line contains N space separated elements.

Output:
For each test case, print the count of all triplets, in new line. If no such triplets can form, print "-1".

Constraints:
1 <= T <= 100
3 <= N <= 105
1 <= A[i] <= 106

Example:
Input:
2
4
1 5 3 2
3
3 2 7
Output:
2
-1

Explanation:
Testcase 1: There are 2 triplets: 1 + 2 = 3 and 3 +2 = 5
*/

#include <algorithm>
#include <iostream>
#include <unordered_set>
#include <vector>
using namespace std;

// int countTriplets(const std::vector<int>& arr)
// {
//     int totalCount = 0u;
//     for (unsigned ctr = 0u; ctr < arr.size(); ++ctr)
//     {
//         int targetSum = arr[ctr];
//         std::unordered_set<int> arrNumbers;
//         for (unsigned ctr2 = 0u; ctr2 < arr.size(); ++ctr2)
//         {
//             if (ctr2 == ctr) continue;

//             int requiredNumber = targetSum - arr[ctr2];
//             if (arrNumbers.count(requiredNumber)) ++totalCount;

//             arrNumbers.insert(arr[ctr2]);
//         }
//     }
//     return totalCount > 0 ?
//             totalCount :
//             -1;
// }

int countTriplets(std::vector<int> arr)
{
    std::sort(arr.begin(), arr.end());

    int totalCount = 0u;
    for (int ctr = arr.size() - 1; ctr >= 0; --ctr)
    {
        int targetSum = arr[ctr];

        int traverseToRight = 0;
        int traverseToLeft = ctr - 1;
        while (traverseToRight < traverseToLeft)
        {
            int currentSum = arr[traverseToRight] + arr[traverseToLeft];
            if (currentSum == targetSum)
            {
                ++totalCount;
                ++traverseToRight;
                --traverseToLeft;
            }
            else if (currentSum < targetSum)
            {
                ++traverseToRight;
            }
            else // if (currentSum > targetSum)
            {
                --traverseToLeft;
            }
        }
    }
    return totalCount > 0 ?
            totalCount :
            -1;
}

int main() {
    //code
    unsigned T;
    std::cin >> T;
    for (unsigned ctr = 0u; ctr < T; ++ctr)
    {
        unsigned N;
        std::cin >> N;

        std::vector<int> arr;
        arr.reserve(N);
        for (unsigned ctr2 = 0u; ctr2 < N; ++ctr2)
        {
            int temp;
            std::cin >> temp;
            arr.push_back(temp);
        }
        std::cout << countTriplets(arr) << "\n";
    }
    return 0;
}
---------------------------------------------------------------------------

/*
Kadane's Algorithm

Given an array arr of N integers. Find the contiguous sub-array with maximum sum.

Input:
The first line of input contains an integer T denoting the number of test cases. The description of T test cases follows. The first line of each test case contains a single integer N denoting the size of array. The second line contains N space-separated integers A1, A2, ..., AN denoting the elements of the array.

Output:
Print the maximum sum of the contiguous sub-array in a separate line for each test case.

Constraints:
1 ≤ T ≤ 110
1 ≤ N ≤ 106
-107 ≤ A[i] <= 107

Example:
Input
2
5
1 2 3 -2 5
4
-1 -2 -3 -4
Output
9
-1

Explanation:
Testcase 1: Max subarray sum is 9 of elements (1, 2, 3, -2, 5) which is a contiguous subarray.
*/
#include <iostream>
#include <vector>
using namespace std;

int kadaneAlgorithm(const std::vector<int>& arr)
{
    if (arr.empty()) return 0;

    int maxSum = arr.front();
    int currentSum = arr.front();
    for (unsigned ctr = 1u; ctr < arr.size(); ++ctr)
    {
        int newCurrentSum = arr[ctr] + currentSum;
        if (arr[ctr] > newCurrentSum)
        {
            currentSum = arr[ctr];
            if (currentSum > maxSum)
            {
                maxSum = currentSum;
            }
        }
        else if (newCurrentSum >= 0)
        {
            currentSum = newCurrentSum;
            if (currentSum > maxSum)
            {
                maxSum = currentSum;
            }
        }
        else
        {
            currentSum = 0;
        }
    }
    return maxSum;
}

int main() {
    //code
    unsigned T;
    std::cin >> T;
    for (unsigned ctr = 0u; ctr < T; ++ctr)
    {
        unsigned N;
        std::cin >> N;

        std::vector<int> arr;
        arr.reserve(N);
        for (unsigned ctr2 = 0u; ctr2 < N; ++ctr2)
        {
            int temp;
            std::cin >> temp;
            arr.push_back(temp);
        }
        std::cout << kadaneAlgorithm(arr) << "\n";
    }
    return 0;
}
---------------------------------------------------------------------------

/*
Missing number in array

Given an array C of size N-1 and given that there are numbers from 1 to N with one element missing, the missing number is to be found.

Input:
The first line of input contains an integer T denoting the number of test cases. For each test case first line contains N(size of array). The subsequent line contains N-1 array elements.

Output:
Print the missing number in array.

Constraints:
1 ≤ T ≤ 200
1 ≤ N ≤ 107
1 ≤ C[i] ≤ 107

Example:
Input:
2
5
1 2 3 5
10
1 2 3 4 5 6 7 8 10

Output:
4
9

Explanation:
Testcase 1: Given array : 1 2 3 5. Missing element is 4.
*/

#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

int missingNumber(std::vector<int> arr)
{
    std::sort(arr.begin(), arr.end());

    int expectedValue = 1;
    for (const auto& elem : arr)
    {
        if (elem != expectedValue) return expectedValue;
        ++expectedValue;
    }
    return expectedValue;
}

int main() {
    //code
    unsigned T;
    std::cin >> T;
    for (unsigned ctr = 0u; ctr < T; ++ctr)
    {
        unsigned N;
        std::cin >> N;

        std::vector<int> arr;
        arr.reserve(N);
        for (unsigned ctr2 = 0u; ctr2 < N - 1; ++ctr2)
        {
            int temp;
            std::cin >> temp;
            arr.push_back(temp);
        }
        std::cout << missingNumber(arr) << "\n";
    }
    return 0;
}

---------------------------------------------------------------------------

/*
The Time in Words

Given the time in numerals we may convert it into words, as shown below:
5:00 -> five o' clock
5:01 -> one minute past five
5:10 -> ten minutes past five
5:15 -> quarter past five
5:30 -> half past five
5:40 -> twenty minutes to six
5:40 -> quarter to six
5:40 -> thirteen minutes to six
5:28 -> twenty eight minutes past five
*/

#include <bits/stdc++.h>

using namespace std;

// Complete the timeInWords function below.

const std::unordered_map<int, std::string> TIME_AND_WORD_MAP
    {
        {1, "one"},
        {2, "two"},
        {3, "three"},
        {4, "four"},
        {5, "five"},
        {6, "six"},
        {7, "seven"},
        {8, "eight"},
        {9, "nine"},
        {10, "ten"},
        {11, "eleven"},
        {12, "twelve"},
        {13, "thirteen"},
        {14, "fourteen"},
        // {15, "fifteen"},
        {16, "sixteen"},
        {17, "seventeen"},
        {18, "eighteen"},
        {19, "nineteen"},
        {20, "twenty"},
    };

const std::string O_CLOCK = "o' clock";
const std::string MINUTE = "minute";
const std::string MINUTES = "minutes";
const std::string PAST = "past";
const std::string QUARTER = "quarter";
const std::string HALF = "half";
const std::string TO = "to";
const std::string SPACE = " ";

std::string getMinutesTime(const int minutes)
{
    int minutesWithRespectTo30 = minutes < 30 ?
                                    minutes :
                                    60 - minutes;
    int remainingFrom20 = minutesWithRespectTo30 < 20 ?
                            0 :
                            minutesWithRespectTo30 - 20;
    return remainingFrom20 == 0 ?
            TIME_AND_WORD_MAP.at(minutesWithRespectTo30) :
            TIME_AND_WORD_MAP.at(20) + SPACE + TIME_AND_WORD_MAP.at(remainingFrom20);
}

std::string getHourTime(
    const int h,
    const int m)
{
    if (m < 30) return TIME_AND_WORD_MAP.at(h);
    return h == 12 ?
            TIME_AND_WORD_MAP.at(1) :
            TIME_AND_WORD_MAP.at(h + 1);
}

string timeInWords(int h, int m)
{
    if (m % 15 == 0)
    {
        switch (m)
        {
            case 0 : return TIME_AND_WORD_MAP.at(h) + SPACE + O_CLOCK;
            case 15 : return QUARTER + SPACE + PAST + SPACE + TIME_AND_WORD_MAP.at(h);
            case 30 : return HALF + SPACE + PAST + SPACE + TIME_AND_WORD_MAP.at(h);
            case 45 : return QUARTER + SPACE + TO + SPACE + getHourTime(h, m);
        };
        throw "Unsupported minutes";
    }

    std::string minuteWord = (m == 1 || m == 59) ? MINUTE : MINUTES;
    std::string pastOrTo = (m < 30) ? PAST : TO;
    std::string minutesTime = getMinutesTime(m);
    std::string hourTime = getHourTime(h, m);

    return minutesTime + SPACE + minuteWord + SPACE + pastOrTo + SPACE + hourTime;
}

int main()
{
    ofstream fout(getenv("OUTPUT_PATH"));

    int h;
    cin >> h;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    int m;
    cin >> m;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    string result = timeInWords(h, m);

    fout << result << "\n";

    fout.close();

    return 0;
}

---------------------------------------------------------------------------

/*
Shortest path from 1 to n Submissions: 12972   Accuracy: 43.46%   Difficulty: Basic   Marks: 1

Problems
Consider a directed graph whose vertices are numbered from 1 to n. There is an edge from a vertex i to a vertex j iff either j = i + 1 or j = 3i. The task is to find the minimum number of edges in a path in G from vertex 1 to vertex n.

Input:
The first line of input contains an integer T denoting the number of test cases. The description of T test cases follows.

Each test case contains a value of n.

Output:
Print the number of edges in the shortest path from 1 to n.

Constraints:
1<=T<=30
1<=n <=1000

Example:
Input:
2
9
4

Output:
2
2


Can someone explain why is it that for input 887, the answer should be 14?

My code's output is 12, which is obviously shorter. I looked into the path generated and it seems legitimate.

For Input:
1
887
Your Output is:
Path: -1-3-4-12-11-33-99-98-294-295-885-886-887 = 12

-> answer: The problem requires directed graph, so 1 is connected to 2 but not the other way around
*/


#include <algorithm>
#include <iostream>
#include <queue>
#include <unordered_map>
#include <vector>
using namespace std;

struct Node
{
    int value;
    int pathValue;
    std::vector<Node*> connectedNodes;
    std::string pathStr;
};

std::unordered_map<int, Node*> valueAndNodeMap;

int shortestPath(const int n)
{
    valueAndNodeMap[1] = new Node{1, 0, {}};

    for (int ctr = 2; ctr <= n; ++ctr)
    {
        valueAndNodeMap[ctr] = new Node{ctr, 0, {}};

        int neighbor1 = ctr - 1;
        // valueAndNodeMap[ctr]->connectedNodes.push_back(valueAndNodeMap[neighbor1]); // Commented because problem requires directed graph
        valueAndNodeMap[neighbor1]->connectedNodes.push_back(valueAndNodeMap[ctr]);

        if (ctr < 3 || ctr % 3 != 0) continue;

        int neighbor2 = ctr / 3;
        // valueAndNodeMap[ctr]->connectedNodes.push_back(valueAndNodeMap[neighbor2]); // Commented because problem requires directed graph
        valueAndNodeMap[neighbor2]->connectedNodes.push_back(valueAndNodeMap[ctr]);
    }

    std::queue<Node*> nodeQueue;
    nodeQueue.push(valueAndNodeMap[1]);

    while (!nodeQueue.empty())
    {
        auto currentNode = nodeQueue.front();
        nodeQueue.pop();

        int edgeValue = 1; // Fixed for this problem
        int currentToNextPathValue = currentNode->pathValue + edgeValue;
        for (auto& elem : currentNode->connectedNodes)
        {
            if (elem->value == 1) continue;
            if (elem->pathValue != 0 && elem->pathValue <= currentToNextPathValue) continue;
            if (elem->value == n)
            {
                // std::cout << "Path: " << currentNode->pathStr + "-" + std::to_string(currentNode->value) + "-" + std::to_string(elem->value) << " = ";
                return currentToNextPathValue;
            }

            elem->pathValue = currentToNextPathValue;
            elem->pathStr = currentNode->pathStr + "-" + std::to_string(currentNode->value);
            nodeQueue.push(elem);
        }
    }
    return 0;
}

int main() {
    //code
    unsigned T;
    std::cin >> T;
    for (unsigned ctr = 0u; ctr < T; ++ctr)
    {
        int n;
        std::cin >> n;
        std::cout << shortestPath(n) << "\n";

        for (auto& elem : valueAndNodeMap)
        {
            delete elem.second;
        }
        valueAndNodeMap.clear();
    }
    return 0;
}

---------------------------------------------------------------------------

/*
CyclicRotation

An array A consisting of N integers is given. Rotation of the array means that each element is shifted right by one index, and the last element of the array is moved to the first place. For example, the rotation of array A = [3, 8, 9, 7, 6] is [6, 3, 8, 9, 7] (elements are shifted right by one index and 6 is moved to the first place).

The goal is to rotate array A K times; that is, each element of A will be shifted to the right K times.

Write a function:

class Solution { public int[] solution(int[] A, int K); }

that, given an array A consisting of N integers and an integer K, returns the array A rotated K times.

For example, given

    A = [3, 8, 9, 7, 6]
    K = 3
the function should return [9, 7, 6, 3, 8]. Three rotations were made:

    [3, 8, 9, 7, 6] -> [6, 3, 8, 9, 7]
    [6, 3, 8, 9, 7] -> [7, 6, 3, 8, 9]
    [7, 6, 3, 8, 9] -> [9, 7, 6, 3, 8]
For another example, given

    A = [0, 0, 0]
    K = 1
the function should return [0, 0, 0]

Given

    A = [1, 2, 3, 4]
    K = 4
the function should return [1, 2, 3, 4]

Assume that:

N and K are integers within the range [0..100];
each element of array A is an integer within the range [−1,000..1,000].
In your solution, focus on correctness. The performance of your solution will not be the focus of the assessment.

Copyright 2009–2019 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited.


Your test case:  [[1, 2, 3, 4, 5], 1]
Returned value: [5, 1, 2, 3, 4]

Your test case:  [[1, -2, 3, 4, -5], 1]
Returned value: [-5, 1, -2, 3, 4]

*/

// you can use includes, for example:
// #include <algorithm>
#include <queue>

// you can write to stdout for debugging purposes, e.g.
// cout << "this is a debug message" << endl;

// Unoptimized solution
// vector<int> solution(vector<int> &A, int K)
// {
//     // write your code in C++14 (g++ 6.2.0)
//     if (A.empty()) return A;

//     K = K % A.size();

//     const int MAX_NUM = 1001;

//     std::vector<bool> negativeVec;
//     negativeVec.resize(A.size());

//     for (int ctr = A.size() - 1; ctr >= 0; --ctr)
//     {
//         int targetIndex = ctr - K;
//         if (targetIndex < 0)
//         {
//             targetIndex = A.size() + targetIndex;
//         }

//         negativeVec[ctr] = false;
//         if (A[targetIndex] < 0)
//         {
//             negativeVec[ctr] = true;
//             A[targetIndex] = A[targetIndex] * -1;
//         }

//         int originalNumberInTarget = A[targetIndex] % MAX_NUM;
//         // std::cout << "\n ctr " << ctr << " targetIndex " << targetIndex
//         //     << " originalNumberInTarget " << originalNumberInTarget;
//         // std::cout << "\n from A[ctr] " << A[ctr];
//         bool isCurrentNegative = A[ctr] < 0;
//         int numToAdd = isCurrentNegative ?
//                         A[ctr] * -1 :
//                         A[ctr];

//         A[ctr] = numToAdd + (originalNumberInTarget * MAX_NUM);
//         if (isCurrentNegative)
//         {
//             A[ctr] *= -1;
//         }
//         // std::cout << " to A[ctr] " << A[ctr];
//     }

//     // std::cout << "\neto1 ";
//     for (unsigned ctr = 0u; ctr < A.size(); ++ctr)
//     {
//         // std::cout << A[ctr] << " ";
//         A[ctr] = A[ctr] / MAX_NUM;
//         if (negativeVec[ctr])
//         {
//             A[ctr] *= -1;
//         }
//     }
//     // std::cout << "\neto2 ";
//     // for (unsigned ctr = 0u; ctr < A.size(); ++ctr)
//     // {
//     //     std::cout << A[ctr] << " ";
//     // }
//     return A;
// }

vector<int> solution(vector<int> &A, int K)
{
    // write your code in C++14 (g++ 6.2.0)
    if (A.empty()) return A;
    K = K % A.size();
    if (K == 0) return A;

    std::queue<int> buffer;

    int ctr = A.size() - 1;
    int targetIndex = ctr - K;
    while (targetIndex >= 0)
    {
        buffer.push(A[ctr]);
        A[ctr] = A[targetIndex];

        --ctr;
        targetIndex = ctr - K;
    }
    while (ctr >= 0)
    {
        buffer.push(A[ctr]);
        A[ctr] = buffer.front();
        buffer.pop();

        --ctr;
    }
    return A;
}


---------------------------------------------------------------------------

/*
FrogJmp

A small frog wants to get to the other side of the road. The frog is currently located at position X and wants to get to a position greater than or equal to Y. The small frog always jumps a fixed distance, D.

Count the minimal number of jumps that the small frog must perform to reach its target.

Write a function:

int solution(int X, int Y, int D);

that, given three integers X, Y and D, returns the minimal number of jumps from position X to a position equal to or greater than Y.

For example, given:

  X = 10
  Y = 85
  D = 30
the function should return 3, because the frog will be positioned as follows:

after the first jump, at position 10 + 30 = 40
after the second jump, at position 10 + 30 + 30 = 70
after the third jump, at position 10 + 30 + 30 + 30 = 100
Write an efficient algorithm for the following assumptions:

X, Y and D are integers within the range [1..1,000,000,000];
X ≤ Y.
Copyright 2009–2019 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited.
*/

// you can use includes, for example:
// #include <algorithm>

// you can write to stdout for debugging purposes, e.g.
// cout << "this is a debug message" << endl;

int solution(int X, int Y, int D)
{
    // write your code in C++14 (g++ 6.2.0)
    if (X >= Y) return 0;

    int difference = Y - X;
    int jumpCount = difference / D;
    if (difference % D != 0) ++jumpCount;
    return jumpCount;
}

---------------------------------------------------------------------------

/*

The Grid Search

Given a 2D array of digits or grid, try to find the occurrence of a given 2D pattern of digits. For example, consider the following grid:

1234567890
0987654321
1111111111
1111111111
2222222222
Assume we need to look for the following 2D pattern array:

876543
111111
111111
The 2D pattern begins at the second row and the third column of the grid. The pattern is said to be present in the grid.

Function Description
Complete the gridSearch function in the editor below. It should return YES if the pattern exists in the grid, or NO otherwise.
gridSearch has the following parameter(s):
G: the grid to search, an array of strings
P: the pattern to search for, an array of strings

Input Format
The first line contains an integer t, the number of test cases.
Each of the t test cases is represented as follows:
The first line contains two space-separated integers R and C, indicating the number of rows and columns in the grid G.
This is followed by R lines, each with a string of C digits representing the grid .G
The following line contains two space-separated integers, r and c, indicating the number of rows and columns in the pattern grid P.
This is followed by r lines, each with a string of c digits representing the pattern P.

Output Format

Display YES or NO, depending on whether P is present in G.

Sample Input

2
10 10
7283455864
6731158619
8988242643
3830589324
2229505813
5633845374
6473530293
7053106601
0834282956
4607924137
3 4
9505
3845
3530
15 15
400453592126560
114213133098692
474386082879648
522356951189169
887109450487496
252802633388782
502771484966748
075975207693780
511799789562806
404007454272504
549043809916080
962410809534811
445893523733475
768705303214174
650629270887160
2 2
99
99
Sample Output

YES
NO
Explanation

The first test in the input file is:

10 10
7283455864
6731158619
8988242643
3830589324
2229505813
5633845374
6473530293
7053106601
0834282956
4607924137
3 4
9505
3845
3530
As one may see, the given pattern is present in the larger grid, as marked in bold below.

7283455864
6731158619
8988242643
3830589324
2229505813
5633845374
6473530293
7053106601
0834282956
4607924137
The second test in the input file is:

15 15
400453592126560
114213133098692
474386082879648
522356951189169
887109450487496
252802633388782
502771484966748
075975207693780
511799789562806
404007454272504
549043809916080
962410809534811
445893523733475
768705303214174
650629270887160
2 2
99
99
The search pattern is:

99
99
This cannot be found in the larger grid.

*/

#include <bits/stdc++.h>

using namespace std;

vector<string> split_string(string);

// Complete the gridSearch function below.
string gridSearch(vector<string> G, vector<string> P)
{
    if (G.empty() || P.empty()) return "NO";
    char firstCh = P.front().front();
    unsigned rowSize = P.size();
    unsigned colSize = P.front().size();
    for (unsigned row = 0u; row + rowSize <= G.size(); ++row)
    {
        for (unsigned col = 0u; col + colSize <= G.front().size(); ++col)
        {
            if (G[row][col] != firstCh) continue;
            bool found = true;
            for (unsigned rowToCheck = row, ctr = 0; ctr < rowSize; ++rowToCheck, ++ctr)
            {
                std::string rowToCheckStr = G[rowToCheck].substr(col, colSize);
                if (rowToCheckStr != P[ctr])
                {
                    found = false;
                    break;
                }
            }
            if (found) return "YES";
        }
    }
    return "NO";
}

int main()
{
    ofstream fout(getenv("OUTPUT_PATH"));

    int t;
    cin >> t;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    for (int t_itr = 0; t_itr < t; t_itr++) {
        string RC_temp;
        getline(cin, RC_temp);

        vector<string> RC = split_string(RC_temp);

        int R = stoi(RC[0]);

        int C = stoi(RC[1]);

        vector<string> G(R);

        for (int i = 0; i < R; i++) {
            string G_item;
            getline(cin, G_item);

            G[i] = G_item;
        }

        string rc_temp;
        getline(cin, rc_temp);

        vector<string> rc = split_string(rc_temp);

        int r = stoi(rc[0]);

        int c = stoi(rc[1]);

        vector<string> P(r);

        for (int i = 0; i < r; i++) {
            string P_item;
            getline(cin, P_item);

            P[i] = P_item;
        }

        string result = gridSearch(G, P);

        fout << result << "\n";
    }

    fout.close();

    return 0;
}

vector<string> split_string(string input_string) {
    string::iterator new_end = unique(input_string.begin(), input_string.end(), [] (const char &x, const char &y) {
        return x == y and x == ' ';
    });

    input_string.erase(new_end, input_string.end());

    while (input_string[input_string.length() - 1] == ' ') {
        input_string.pop_back();
    }

    vector<string> splits;
    char delimiter = ' ';

    size_t i = 0;
    size_t pos = input_string.find(delimiter);

    while (pos != string::npos) {
        splits.push_back(input_string.substr(i, pos - i));

        i = pos + 1;
        pos = input_string.find(delimiter, i);
    }

    splits.push_back(input_string.substr(i, min(pos, input_string.length()) - i + 1));

    return splits;
}

---------------------------------------------------------------------------

/*
Pentagonal Number

Have the function PentagonalNumber(num) read num which will be a positive integer and determine how many dots exist in a pentagonal shape around a center dot on the Nth iteration. For example, in the image below you can see that on the first iteration there is only a single dot, on the second iteration there are 6 dots, on the third there are 16 dots, and on the fourth there are 31 dots.
Your program should return the number of dots that exist in the whole pentagon on the Nth iteration.
*/

#include <iostream>
#include <string>
using namespace std;

int PentagonalNumber(int num)
{
  // code goes here
    int sum = 0;
    while (true)
    {
        if (num == 1)
        {
            ++sum;
            break;
        }

        int totalForCurrentPentagon = (num * 5) - 5;
        sum += totalForCurrentPentagon;
        --num;
    }
  return sum;
}

int main() {

  // keep this function call here
  cout << PentagonalNumber(gets(stdin));
  return 0;
}

---------------------------------------------------------------------------

/*
Absolute Permutation

We define P to be a permutation of the first n natural numbers in the range [1,n]. Let pos[i] denote the value at position i in permutation P using 1-based indexing.

P is considered to be an absolute permutation if |pos[i] - i| = k holds true for every i in [1,n].

Given n and k, print the lexicographically smallest absolute permutation P. If no absolute permutation exists, print -1.

For example, let n=4 giving us an array pos=[1,2,3,4]. If we use 1 based indexing, create a permutation where every |pos[i] - i| = k. If k=2, we could rearrange them to [3,4,1,2]:

pos[i]  i   |Difference|
3       1   2
4       2   2
1       3   2
2       4   2

Input (stdin)
2
6 1
6 3
Your Output (stdout)
2 1 4 3 6 5
4 5 6 1 2 3
*/


#include <bits/stdc++.h>

using namespace std;

vector<string> split_string(string);

// Complete the absolutePermutation function below.
// vector<int> absolutePermutation(int n, int k)
// {
//     std::vector<int> pos(n);
//     std::iota(pos.begin(), pos.end(), 1);
//     do
//     {
//         bool found = true;
//         for (int ctr = 0u; ctr < n; ++ctr)
//         {
//             int ctrBaseOne = ctr + 1;
//             int diff = pos[ctr] - ctrBaseOne;
//             if (diff < 1)
//             {
//                 diff *= -1;
//             }
//             if (diff != k) found = false;
//         }
//         if (found) return pos;
//     }
//     while (std::next_permutation(pos.begin(), pos.end()));

//     return {-1};
// }

vector<int> absolutePermutation(int n, int k)
{
    const int MIN_VALUE = 1;
    const int MAX_VALUE = n;

    const std::vector<int> INVALID_RESULT{-1};

    std::vector<int> result;
    result.reserve(n);
    std::unordered_set<int> pushedBackItems;

    for (int ctr = 1; ctr <= n; ++ctr)
    {
        int diff = ctr - k;
        int sum = ctr + k;
        if (diff >= MIN_VALUE && !pushedBackItems.count(diff))
        {
            result.push_back(diff);
            pushedBackItems.insert(diff);
        }
        else if (sum <= MAX_VALUE && !pushedBackItems.count(sum))
        {
            result.push_back(sum);
            pushedBackItems.insert(sum);
        }
        else
        {
            return INVALID_RESULT;
        }
    }
    return result.empty() ?
            INVALID_RESULT :
            result;
}

int main()
{
    ofstream fout(getenv("OUTPUT_PATH"));

    int t;
    cin >> t;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    for (int t_itr = 0; t_itr < t; t_itr++) {
        string nk_temp;
        getline(cin, nk_temp);

        vector<string> nk = split_string(nk_temp);

        int n = stoi(nk[0]);

        int k = stoi(nk[1]);

        vector<int> result = absolutePermutation(n, k);

        for (int i = 0; i < result.size(); i++) {
            fout << result[i];

            if (i != result.size() - 1) {
                fout << " ";
            }
        }

        fout << "\n";
    }

    fout.close();

    return 0;
}

vector<string> split_string(string input_string) {
    string::iterator new_end = unique(input_string.begin(), input_string.end(), [] (const char &x, const char &y) {
        return x == y and x == ' ';
    });

    input_string.erase(new_end, input_string.end());

    while (input_string[input_string.length() - 1] == ' ') {
        input_string.pop_back();
    }

    vector<string> splits;
    char delimiter = ' ';

    size_t i = 0;
    size_t pos = input_string.find(delimiter);

    while (pos != string::npos) {
        splits.push_back(input_string.substr(i, pos - i));

        i = pos + 1;
        pos = input_string.find(delimiter, i);
    }

    splits.push_back(input_string.substr(i, min(pos, input_string.length()) - i + 1));

    return splits;
}

---------------------------------------------------------------------------

/*
Almost Sorted

Given an array of integers, determine whether the array can be sorted in ascending order using only one of the following operations one time.

Swap two elements.
Reverse one sub-segment.
Determine whether one, both or neither of the operations will complete the task. If both work, choose swap. For instance, given an array [2,3,5,4] either swap the 4 and 5, or reverse them to sort the array. Choose swap. The Output Format section below details requirements.

Output Format
1. If the array is already sorted, output yes on the first line. You do not need to output anything else.

2. If you can sort this array using one single operation (from the two permitted operations) then output yes on the first line and then:

a. If elements can be swapped, d[l] and d[r], output swap l r in the second line. l and r are the indices of the elements to be swapped, assuming that the array is indexed from 1 to n.
b. Otherwise, when reversing the segment d[l...r], output reverse l r in the second line. l and r are the indices of the first and last elements of the subsequence to be reversed, assuming that the array is indexed from 1 to n.

d[l...r] represents the sub-sequence of the array, beginning at index l and ending at index r, both inclusive.

If an array can be sorted by either swapping or reversing, choose swap.

3. If you cannot sort the array either way, output no on the first line.

Sample Input 1
2
4 2
Sample Output 1
yes
swap 1 2
Explanation 1
You can either swap(1, 2) or reverse(1, 2). You prefer swap

Sample Input 2
3
3 1 2
Sample Output 2
no
Explanation 2
It is impossible to sort by one single operation.

Sample Input 3
6
1 5 4 3 2 6
Sample Output 3
yes
reverse 2 5
Explanation 3
You can reverse the sub-array d[2...5] = "5 4 3 2", then the array becomes sorted.
*/

/*
iterate forward to n-1
find i_f > i_f+1
if none
    return already sorted
left = i
iterate backward to i_f+1
find i_b <= i_f+1
    on the side: if i_b != i_f+1 and i_b-1 > i_b
        return no
if none
    return no
right = i_b
if
    i_f != 0 and i_f-1 > i_b
    or
    i_b != n-1 and i_f > i_b+1
        return no
check if range i_f+1 to if i_b-1 is sorted or reversely sorted
*/

#include <bits/stdc++.h>

using namespace std;

vector<string> split_string(string);

// Complete the almostSorted function below.
void almostSorted(const vector<int>& arr)
{
    const int INVALID_INDEX = -1;
    int lhsIndex = INVALID_INDEX;
    int rhsIndex = INVALID_INDEX;

    for (unsigned forwardIt = 0u; forwardIt + 1 < arr.size(); ++forwardIt)
    {
        if (arr[forwardIt] > arr[forwardIt+1])
        {
            lhsIndex = forwardIt;
            break;
        }
    }
    if (lhsIndex == INVALID_INDEX)
    {
        std::cout << "yes\n";
        return;
    }

    for (unsigned backwardIt = arr.size() - 1u; backwardIt > lhsIndex; --backwardIt)
    {
        if (arr[backwardIt] <= arr[lhsIndex+1])
        {
            rhsIndex = backwardIt;
            break;
        }
        if (backwardIt != lhsIndex + 1 && arr[backwardIt] < arr[backwardIt-1])
        {
            std::cout << "no\n";
            return;
        }
    }
    if (rhsIndex == INVALID_INDEX ||
        (lhsIndex > 0 && arr[lhsIndex-1] > arr[rhsIndex]) ||
        (rhsIndex < arr.size() - 1u  && arr[rhsIndex+1] < arr[lhsIndex]))
    {
        std::cout << "no\n";
        return;
    }

    bool tryReverse = false;
    int previousNum = arr[rhsIndex];
    for (unsigned ctr = lhsIndex + 1u; ctr < rhsIndex; ++ctr)
    {
        if (arr[ctr] > arr[lhsIndex])
        {
            std::cout << "no\n";
            return;
        }
        if (arr[ctr] < previousNum)
        {
            tryReverse = true;
            break;
        }
        previousNum = arr[ctr];
    }

    if (!tryReverse)
    {
        std::cout << "yes\nswap " << lhsIndex+1 << " " << rhsIndex+1 << "\n";
        return;
    }

    previousNum = arr[rhsIndex];
    for (unsigned ctr = rhsIndex - 1u; ctr > lhsIndex; --ctr)
    {
        if (arr[ctr] > arr[lhsIndex] ||
            arr[ctr] < previousNum)
        {
            std::cout << "no\n";
            return;
        }
        previousNum = arr[ctr];
    }
    std::cout << "yes\nreverse " << lhsIndex+1 << " " << rhsIndex+1 << "\n";
}

int main()
{
    int n;
    cin >> n;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    string arr_temp_temp;
    getline(cin, arr_temp_temp);

    vector<string> arr_temp = split_string(arr_temp_temp);

    vector<int> arr(n);

    for (int i = 0; i < n; i++) {
        int arr_item = stoi(arr_temp[i]);

        arr[i] = arr_item;
    }

    almostSorted(arr);

    return 0;
}

vector<string> split_string(string input_string) {
    string::iterator new_end = unique(input_string.begin(), input_string.end(), [] (const char &x, const char &y) {
        return x == y and x == ' ';
    });

    input_string.erase(new_end, input_string.end());

    while (input_string[input_string.length() - 1] == ' ') {
        input_string.pop_back();
    }

    vector<string> splits;
    char delimiter = ' ';

    size_t i = 0;
    size_t pos = input_string.find(delimiter);

    while (pos != string::npos) {
        splits.push_back(input_string.substr(i, pos - i));

        i = pos + 1;
        pos = input_string.find(delimiter, i);
    }

    splits.push_back(input_string.substr(i, min(pos, input_string.length()) - i + 1));

    return splits;
}


---------------------------------------------------------------------------

/*
Lily's Homework (minodify ko ng konti ung rules)

Counts minimum number of swaps to make the input array sorted

ex.
3 4 2 5 1

1.
1 4 2 5 3

2.
1 2 4 5 3

3.
1 2 3 5 4

4.
1 2 3 4 5

Answer: 4

ex.
2 5 3 1

1.
1 5 3 2

2.
1 2 3 5

Answer: 2

*/

#include <bits/stdc++.h>

using namespace std;

vector<string> split_string(string);

// Complete the lilysHomework function below.
int lilysHomework(vector<int> arr)
{
    std::set<int> arrOrdered{arr.begin(), arr.end()};

    // To sort original array, make this reference_wrappers instead
    std::vector<int> elementsToReorder;
    elementsToReorder.reserve(arr.size());

    using Element = int;
    using Index = int;
    std::map<Element, Index> orderedElementsAndIndexMap;

    int ctr = 0u;
    for (auto it = arrOrdered.begin(); it != arrOrdered.end(); ++it, ++ctr)
    {
        if (arr[ctr] == *it) continue;
        // As above, to sort original array, make this std::ref(arr[ctr]) instead
        elementsToReorder.push_back(arr[ctr]);
        orderedElementsAndIndexMap[*it] = orderedElementsAndIndexMap.size();
    }

    ctr = 0u;
    unsigned swaps = 0u;
            // std::cout << "\nelementsToReorder before = ";
            // for (auto elem : elementsToReorder)
            // {
            //     std::cout << elem << " ";
            // }
            // std::cout << "\norderedElementsAndIndexMap before = ";
            // for (auto elem : orderedElementsAndIndexMap)
            // {
            //     std::cout << elem.first << ":" << elem.second << " ";
            // }
    for (auto it = orderedElementsAndIndexMap.begin(); ctr < elementsToReorder.size();)
    {
        if (elementsToReorder[ctr] == it->first)
        {
            ++ctr;
            ++it;
            continue;
        }
        int targetIndex = orderedElementsAndIndexMap[elementsToReorder[ctr]];
        std::swap(elementsToReorder[ctr], elementsToReorder[targetIndex]);
        ++swaps;
    }
    return swaps;
}

int main()
{
    ofstream fout(getenv("OUTPUT_PATH"));

    int n;
    cin >> n;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    string arr_temp_temp;
    getline(cin, arr_temp_temp);

    vector<string> arr_temp = split_string(arr_temp_temp);

    vector<int> arr(n);

    for (int i = 0; i < n; i++) {
        int arr_item = stoi(arr_temp[i]);

        arr[i] = arr_item;
    }

    int result = lilysHomework(arr);

    fout << result << "\n";

    fout.close();

    return 0;
}

vector<string> split_string(string input_string) {
    string::iterator new_end = unique(input_string.begin(), input_string.end(), [] (const char &x, const char &y) {
        return x == y and x == ' ';
    });

    input_string.erase(new_end, input_string.end());

    while (input_string[input_string.length() - 1] == ' ') {
        input_string.pop_back();
    }

    vector<string> splits;
    char delimiter = ' ';

    size_t i = 0;
    size_t pos = input_string.find(delimiter);

    while (pos != string::npos) {
        splits.push_back(input_string.substr(i, pos - i));

        i = pos + 1;
        pos = input_string.find(delimiter, i);
    }

    splits.push_back(input_string.substr(i, min(pos, input_string.length()) - i + 1));

    return splits;
}

---------------------------------------------------------------------------

/*
Left Rotation

A left rotation operation on an array of size  shifts each of the array's elements 1 unit to the left. For example, if 2 left rotations are performed on array [1,2,3,4,5], then the array would become [3,4,5,1,2].

Given an array of n integers and a number, d, perform d left rotations on the array. Then print the updated array as a single line of space-separated integers.
*/

#include <bits/stdc++.h>

using namespace std;

vector<string> split_string(string);

void shift(
    int d,
    std::vector<int>& vec)
{
    d = d % vec.size();

    unsigned ctr = 0u;
    std::queue<int> shifted;
    while (ctr + d < vec.size())
    {
        shifted.push(vec[ctr]);
        vec[ctr] = vec[ctr+d];
        ++ctr;
    }
    while (ctr < vec.size())
    {
        shifted.push(vec[ctr]);
        vec[ctr] = shifted.front();
        ++ctr;
        shifted.pop();
    }
    for (const auto& elem : vec)
    {
        std::cout << elem << " ";
    }
}

int main()
{
    string nd_temp;
    getline(cin, nd_temp);

    vector<string> nd = split_string(nd_temp);

    int n = stoi(nd[0]);

    int d = stoi(nd[1]);

    string a_temp_temp;
    getline(cin, a_temp_temp);

    vector<string> a_temp = split_string(a_temp_temp);

    vector<int> a(n);

    for (int i = 0; i < n; i++) {
        int a_item = stoi(a_temp[i]);

        a[i] = a_item;
    }
    shift(d, a);

    return 0;
}

vector<string> split_string(string input_string) {
    string::iterator new_end = unique(input_string.begin(), input_string.end(), [] (const char &x, const char &y) {
        return x == y and x == ' ';
    });

    input_string.erase(new_end, input_string.end());

    while (input_string[input_string.length() - 1] == ' ') {
        input_string.pop_back();
    }

    vector<string> splits;
    char delimiter = ' ';

    size_t i = 0;
    size_t pos = input_string.find(delimiter);

    while (pos != string::npos) {
        splits.push_back(input_string.substr(i, pos - i));

        i = pos + 1;
        pos = input_string.find(delimiter, i);
    }

    splits.push_back(input_string.substr(i, min(pos, input_string.length()) - i + 1));

    return splits;
}

---------------------------------------------------------------------------

#include <iostream>
#include <stack>
#include <unordered_map>
#include <unordered_set>

bool checkValidity(const std::string& str)
{
    static const std::unordered_map<char, char> OPEN_BRACKETS_MAP
        {
            {'(', ')'},
            {'{', '}'},
            {'[', ']'},
        };
    static const std::unordered_set<char> CLOSE_BRACKETS_SET
        {
            ')',
            '}',
            ']',
        };

    std::stack<char> bracketsInString;
    for (const auto& ch : str)
    {
        if (OPEN_BRACKETS_MAP.count(ch))
        {
            bracketsInString.push(ch);
        }
        else if (CLOSE_BRACKETS_SET.count(ch))
        {
            if (bracketsInString.empty()) return false;

            char lastBracket = bracketsInString.top();
            if (ch != OPEN_BRACKETS_MAP.at(lastBracket)) return false;

            bracketsInString.pop();
        }
    }
    return true;
    // should have been // return bracketsInString.empty() ? true : false;
}

int main() {
    // Click HELP above to see examples of handling input/debug/output
    // INPUT: std::cin >> n;
    // DEBUG: std::cout << n << std::endl;
    // OUTPUT: std::cout << output << std::endl;
    std::string input;
    std::getline(std::cin, input);

    if (checkValidity(input)) std::cout << "True";
    else                      std::cout << "False";
    // Write the code to solve the problem below,
    // format the “result” as specified in the problem statement
    // and finally, write the result to stdout
    // IMPORTANT: Remove all debug statements for final submission
    return 0;
}

---------------------------------------------------------------------------

#include <algorithm>
#include <iostream>
#include <list>
#include <string>

int main() {
    // Click HELP above to see examples of handling input/debug/output
    // INPUT: std::cin >> n;
    // DEBUG: std::cout << n << std::endl;
    // OUTPUT: std::cout << output << std::endl;
    std::string input;
        // std::getline(std::cin, input);
        // input = "1-2-3-4-5-6-7-8";
        // input = "1-2-3-4-5-6-7";
        // input = "1-2-3-4-5-6";
        // input = "1-2-3-4-5";
        // input = "1-2-3-4";
        // input = "1-2-3";
        // input = "1-2";
        // input = "1";
    std::getline(std::cin, input);

    // std::cout << input; // Nasama to sa naipasa ko, ndi ko nadelete

    std::list<std::string> listOfItems;
    std::string buffer = "";
    for (const auto& ch : input)
    {
        if (ch == '-')
        {
            listOfItems.push_back(buffer);
            buffer.clear();
        }
        else
        {
            buffer += ch;
        }
    }

    if (!buffer.empty()) listOfItems.push_back(buffer);

    // Solution 1 // Eto ung naipasa ko, kulang to and may mga mali
        // unsigned halfOfSizeOfList = listOfItems.size() / 2;
        // unsigned ctr = 0u;
        // auto forwardIt = listOfItems.begin();
        // auto backwardIt = listOfItems.rbegin();
        // ++forwardIt;
        // while (ctr <= halfOfSizeOfList)
        // {
        //     // std::cout << "\nforwardIt:" << *forwardIt;
        //     // std::cout << "\nbackwardIt:" << *backwardIt;
        //     listOfItems.insert(forwardIt++, *(backwardIt++));
        //     ++ctr;
        //     // ++backwardIt;
        //     // listOfItems.erase(backwardIt--);
        // }

    // Solution 2 // Eto ung ginawa ko after ipasa
        auto forwardIt = listOfItems.begin();
        auto backwardIt = listOfItems.rbegin();
        ++forwardIt;
        unsigned forwardItIndex = 1u;
        unsigned backwardItIndex = listOfItems.size() - 1;
        while (forwardItIndex < backwardItIndex)
        {
            listOfItems.insert(forwardIt++, *(backwardIt++));
            ++forwardItIndex;
            --backwardItIndex;
        }
        if (forwardItIndex == backwardItIndex) ++forwardIt;
        while (forwardIt != listOfItems.end())
        {
            listOfItems.erase(forwardIt++);
        }

    // std::cout << "\n\nend\n\n";
    auto it = listOfItems.begin();
    while (true)
    {
        std::cout << *it;
        ++it;
        if (it != listOfItems.end()) std::cout << "-";
        else                         break;
    }
    // Write the code to solve the problem below,
    // format the “result” as specified in the problem statement
    // and finally, write the result to stdout
    // IMPORTANT: Remove all debug statements for final submission
    return 0;
}

---------------------------------------------------------------------------

/*
Trapping Rain Water

Given an array A of N non-negative integers representing height of blocks at index i as Aiwhere the width of each block is 1. Compute how much water can be trapped in between blocks after raining.
Structure is like below:
| |
|_|
We can trap 2 units of water in the middle gap.

Input
Each test case contains an integer N followed by N numbers to be stored in array.
Output
Output the total unit of water trapped in between the blocks.

Constraints
3 <= N <= 107
0 <= Ai <= 107

Example#1
Input
4
7 4 0 9
Output
10

Example#2
Input
3
6 9 9
Output
0
*/

#include <iostream>
#include <vector>

int main() {
    // Click HELP above to see examples of handling input/debug/output
    // INPUT: std::cin >> n;
    // DEBUG: std::cout << n << std::endl;
    // OUTPUT: std::cout << output << std::endl;
    unsigned arrSize;
    std::cin >> arrSize;
    if (arrSize == 0) return 0;

    std::vector<int> arr;
    arr.resize(arrSize);
    for (unsigned ctr = 0u; ctr < arrSize; ++ctr)
    {
        std::cin >> arr[ctr];
    }

    unsigned tallestInLeft = arr.front();
    unsigned tallestInRight = arr.back();
    unsigned lhsIndex = 0;
    unsigned rhsIndex = arrSize - 1u;
    unsigned sum = 0u;
    while (lhsIndex < rhsIndex)
    {
        if (arr[lhsIndex] > tallestInLeft)
        {
            tallestInLeft = arr[lhsIndex];
        }
        else if (arr[rhsIndex] > tallestInRight)
        {
            tallestInRight = arr[rhsIndex];
        }
        sum += tallestInLeft - arr[lhsIndex];
        sum += tallestInRight - arr[rhsIndex];

        if (tallestInLeft > tallestInRight) --rhsIndex;
        else                                ++lhsIndex;
    }

    std::cout << sum;
    // Write the code to solve the problem below,
    // format the “result” as specified in the problem statement
    // and finally, write the result to stdout
    // IMPORTANT: Remove all debug statements for final submission

    // Do not edit below this
    return 0;
}

---------------------------------------------------------------------------

/*
Tom and numbers (maximum sum of numbers)

Tom has an integer n.  He is interested in knowing what positive integer k, which does not exceed n, has the maximum sum of digits. Help him write a program which can find k. If there are several such integers, determine the biggest of them.

Input
The only line contains the positive integer n.

Output
Print the positive integer which does not exceed n and has the maximum sum of digits.

Constraints
1 ≤ n ≤ 1018

Example#1
Input
100
Output
99
9 + 9 = 18.

Example#2
Input
48
Output
48
4 + 8 = 12.

1 7 5 9 3 - 25
1 7 5 8 9 - 30
1 7 4 9 9 - 30
1 6 9 9 9 - 34
0 9 9 9 9 - 36


3 7 5 9 3 - 27
3 7 5 8 9 - 32
3 7 4 9 9 - 32
3 6 9 9 9 - 36
2 9 9 9 9 - 38

*/

/*
I got my 2 failing test cases to work.

While I was debugging it, I have tried all possible corner cases and all worked. This then lead me to the conclusion that nothing is wrong with my logic and that some bug is just hiding around the data types or overflows / underflows.

Some of my tips:

<b>1. Depending on your implementation, beware of used methods from external libraries such as pow from math.h which is accepting double. I solved my 2 failing test cases by creating my own version of pow accepting long long and returning long long.</b>

So instead of:
<code>
long long powerOfTen = pow(10, raise);
</code>

I used this:
<code>
long long powerOfTen = 1;
for (unsigned ctr = 0u; ctr < raise; ++ctr)
{
    powerOfTen *= 10;
}
</code>

<b>2. Check for possible overflows and underflows on the data types you have used</b>

ex.
<code>
std::vector<long long> numbers;
// some code
--numbers[ctr];
</code>

This might lead to underflow if the value of numbers[ctr] is minimum for long long data type, thus a check might help:
<code>
std::vector<long long> numbers;
// some code
if (numbers[ctr] > std::numeric_limits<long long>::min())
{
    --numbers[ctr];
}
</code>

<b>3. Check your operations involving multiple data types from where datatype promotions will happen</b>

ex.
<code>
unsigned a = 1u;
int b = 3;
std::cout << a - b;
</code>

output:
4294967294

Why not -2? Since operation involved operation between unsigned minus int, the int would be promoted to an unsigned, which means:
<code>
unsigned_minValue = 0u
unsigned_maxValue = 4294967295u
1u - 3 = -2
</code>

is invalid value for unsigned and thus would result to handling carry over of underflow from unsigned_maxValue:

<code>
1u - 3 = 1u -> 0u -> 4294967295u -> 4294967294u
</code>

*/

#include <algorithm>
#include <iostream>
#include <limits>
#include <math.h>

using namespace std;

long long tomsNum(long long n)
{
    //Write your code here
    if (n <= 0) return n;

    std::vector<long long> numbers;
    while (n > 0)
    {
        long long currentNum = n % 10;
        numbers.push_back(currentNum);
        n /= 10;
    }

    std::vector<long long> numbersResult(numbers);
    long long largestSum = std::accumulate(numbers.begin(), numbers.end(), 0LL);

    const long long MAX_DECIMAL_NUMBER = 9;
    unsigned ctr = 0u;
    while (ctr + 1 < numbers.size()) // check if it is not the last number
    {
        do
        {
            numbers[ctr++] = MAX_DECIMAL_NUMBER;
        }
        while (ctr < numbers.size() && numbers[ctr] == 0);

        if (ctr >= numbers.size() || numbers[ctr] == std::numeric_limits<long long>::min()) break; // This will only happen if numbers became "0123" or "0001" or etc. which will not happen since those trailing 0s at start are not included in int variables
        --numbers[ctr];

        long long currentSum = std::accumulate(numbers.begin(), numbers.end(), 0LL);
        if (currentSum > largestSum)
        {
            largestSum = currentSum;
            numbersResult = numbers;
        }
    }

    long long result = 0LL;
    for (unsigned ctr = 0u; ctr < numbersResult.size(); ++ctr)
    {
        long long powerOfTen = 1;
        long long ctr2 = 0;
        while (ctr2 < ctr)
        {
            powerOfTen *= 10;
            ++ctr2;
        }
        result += (numbersResult[ctr] * powerOfTen);
    }
    //Return the result
    return result;
}

int main() {
    long long n;
    cin >> n;
    cout << tomsNum(n) << endl;
    return 0;
}

---------------------------------------------------------------------------

/*
Sparse Arrays

There is a collection of input strings and a collection of query strings. For each query string, determine how many times it occurs in the list of input strings.

For example, given input strings = [ab, ab, abc] and queries = [ab, abc, bc], we find 2 instances of ab, 1 of abc and 0 of bc. For each query, we add an element to our return array, results = [2 1 0].

*/


#include <bits/stdc++.h>

using namespace std;

// Complete the matchingStrings function below.
vector<int> matchingStrings(
    std::vector<std::string> strings,
    const std::vector<std::string>& queries)
{
    std::sort(strings.begin(), strings.end());

    // std::unordered_map<std::string, int> stringAndCountMap; // Use this to have a bit of Dynamic Programming for faster execution, only at the expense of little more space. On top of this, you could also delete all found within range of lower and upper bound since they wouldn't be needed anymore to have faster searching for next items

    std::vector<int> result;
    result.reserve(queries.size());

    for (const auto& query : queries)
    {
        auto lower = std::lower_bound(strings.begin(), strings.end(), query);
        auto upper = std::upper_bound(strings.begin(), strings.end(), query);

        int diff = (lower == strings.end()) ?
                    0 :
                    std::distance(lower, upper); // can simply be a subtraction since it is a random access iterator

        result.push_back(diff);
    }
    return result;
}

int main()
{
    ofstream fout(getenv("OUTPUT_PATH"));

    int strings_count;
    cin >> strings_count;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    vector<string> strings(strings_count);

    for (int i = 0; i < strings_count; i++) {
        string strings_item;
        getline(cin, strings_item);

        strings[i] = strings_item;
    }

    int queries_count;
    cin >> queries_count;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    vector<string> queries(queries_count);

    for (int i = 0; i < queries_count; i++) {
        string queries_item;
        getline(cin, queries_item);

        queries[i] = queries_item;
    }

    vector<int> res = matchingStrings(strings, queries);

    for (int i = 0; i < res.size(); i++) {
        fout << res[i];

        if (i != res.size() - 1) {
            fout << "\n";
        }
    }

    fout << "\n";

    fout.close();

    return 0;
}
---------------------------------------------------------------------------

/*
Cycle Detection

A linked list is said to contain a cycle if any node is visited more than once while traversing the list.

Complete the function provided for you in your editor. It has one parameter: a pointer to a Node object named head that points to the head of a linked list. Your function must return a boolean denoting whether or not there is a cycle in the list. If there is a cycle, return true; otherwise, return false.

Note: If the list is empty, head will be null.
*/

#include <bits/stdc++.h>

using namespace std;

class SinglyLinkedListNode {
    public:
        int data;
        SinglyLinkedListNode *next;

        SinglyLinkedListNode(int node_data) {
            this->data = node_data;
            this->next = nullptr;
        }
};

class SinglyLinkedList {
    public:
        SinglyLinkedListNode *head;
        SinglyLinkedListNode *tail;

        SinglyLinkedList() {
            this->head = nullptr;
            this->tail = nullptr;
        }

        void insert_node(int node_data) {
            SinglyLinkedListNode* node = new SinglyLinkedListNode(node_data);

            if (!this->head) {
                this->head = node;
            } else {
                this->tail->next = node;
            }

            this->tail = node;
        }
};

void print_singly_linked_list(SinglyLinkedListNode* node, string sep, ofstream& fout) {
    while (node) {
        fout << node->data;

        node = node->next;

        if (node) {
            fout << sep;
        }
    }
}

void free_singly_linked_list(SinglyLinkedListNode* node) {
    while (node) {
        SinglyLinkedListNode* temp = node;
        node = node->next;

        free(temp);
    }
}

// Complete the has_cycle function below.

/*
 * For your reference:
 *
 * SinglyLinkedListNode {
 *     int data;
 *     SinglyLinkedListNode* next;
 * };
 *
 */

std::unordered_set<SinglyLinkedListNode*> listOfNodesPtrSet;
bool has_cycle(SinglyLinkedListNode* head) {

    while (head != nullptr)
    {
        auto resultOfInsertion = listOfNodesPtrSet.insert(head);
        if (!resultOfInsertion.second) return true;
        head = head->next;
    }
    return false;
}

int main()
{
    ofstream fout(getenv("OUTPUT_PATH"));

    int tests;
    cin >> tests;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    for (int tests_itr = 0; tests_itr < tests; tests_itr++) {
        int index;
        cin >> index;
        cin.ignore(numeric_limits<streamsize>::max(), '\n');

        SinglyLinkedList* llist = new SinglyLinkedList();

        int llist_count;
        cin >> llist_count;
        cin.ignore(numeric_limits<streamsize>::max(), '\n');

        for (int i = 0; i < llist_count; i++) {
            int llist_item;
            cin >> llist_item;
            cin.ignore(numeric_limits<streamsize>::max(), '\n');

            llist->insert_node(llist_item);
        }

        SinglyLinkedListNode* extra = new SinglyLinkedListNode(-1);
        SinglyLinkedListNode* temp = llist->head;

        for (int i = 0; i < llist_count; i++) {
            if (i == index) {
                extra = temp;
            }

            if (i != llist_count-1) {
                temp = temp->next;
            }
        }

        temp->next = extra;

        bool result = has_cycle(llist->head);

        fout << result << "\n";
    }

    fout.close();

    return 0;
}

---------------------------------------------------------------------------
/*
The Full Counting Sort

In this challenge you need to print the string that accompanies each integer in a list sorted by the integers. If two strings are associated with the same integer, they must be printed in their original order so your sorting algorithm should be stable. There is one other twist. The first half of the strings encountered in the inputs are to be replaced with the character "-" (dash).

Insertion Sort and the simple version of Quicksort are stable, but the faster in-place version of Quicksort is not since it scrambles around elements while sorting.

In this challenge, you will use counting sort to sort a list while keeping the order of the strings preserved.

For example, if your inputs are [[0 a] [1 b] [0 c] [1 d]] you could set up a helper array with three empty arrays as elements. The result is then printed: - c - d .

Sample Input
20
0 ab
6 cd
0 ef
6 gh
4 ij
0 ab
6 cd
0 ef
6 gh
0 ij
4 that
3 be
0 to
1 be
5 question
1 or
2 not
4 is
2 to
4 the

Sample Output
- - - - - to be or not to be - that is the question - - - -

Explanation
Below is the list in the correct order. In the array at the bottom, strings from the first half of the original array were replaced with dashes.
0 ab
0 ef
0 ab
0 ef
0 ij
0 to
1 be
1 or
2 not
2 to
3 be
4 ij
4 that
4 is
4 the
5 question
6 cd
6 gh
6 cd
6 gh

sorted = [['-', '-', '-', '-', '-', 'to'], ['be', 'or'], ['not', 'to'], ['be'], ['-', 'that', 'is', 'the'], ['question'], ['-', '-', '-', '-'], [], [], [], []]
*/

#include <bits/stdc++.h>

using namespace std;

string ltrim(const string &);
string rtrim(const string &);
vector<string> split(const string &);

// Complete the countSort function below.
void countSort(vector<vector<string>> arr)
{
    unsigned half = arr.size() / 2;

    std::map<int, std::vector<std::string>> idAndStrMap;

    unsigned ctr = 0u;
    while (ctr < half)
    {
        const int id = std::stoi(arr[ctr++][0]);
        idAndStrMap[id].push_back("-");
    }
    while (ctr < arr.size())
    {
        const int id = std::stoi(arr[ctr][0]);
        const std::string& value = arr[ctr++][1];
        idAndStrMap[id].push_back(value);
    }

    for (const auto& idAndStr : idAndStrMap)
    {
        // std::cout << "\n" << idAndStr.first << "\n";
        for (const auto& elem : idAndStr.second)
        {
            std::cout << elem << " ";
        }
    }
}

int main()
{
    string n_temp;
    getline(cin, n_temp);

    int n = stoi(ltrim(rtrim(n_temp)));

    vector<vector<string>> arr(n);

    for (int i = 0; i < n; i++) {
        arr[i].resize(2);

        string arr_row_temp_temp;
        getline(cin, arr_row_temp_temp);

        vector<string> arr_row_temp = split(rtrim(arr_row_temp_temp));

        for (int j = 0; j < 2; j++) {
            string arr_row_item = arr_row_temp[j];

            arr[i][j] = arr_row_item;
        }
    }

    countSort(arr);

    return 0;
}

string ltrim(const string &str) {
    string s(str);

    s.erase(
        s.begin(),
        find_if(s.begin(), s.end(), not1(ptr_fun<int, int>(isspace)))
    );

    return s;
}

string rtrim(const string &str) {
    string s(str);

    s.erase(
        find_if(s.rbegin(), s.rend(), not1(ptr_fun<int, int>(isspace))).base(),
        s.end()
    );

    return s;
}

vector<string> split(const string &str) {
    vector<string> tokens;

    string::size_type start = 0;
    string::size_type end = 0;

    while ((end = str.find(" ", start)) != string::npos) {
        tokens.push_back(str.substr(start, end - start));

        start = end + 1;
    }

    tokens.push_back(str.substr(start));

    return tokens;
}

---------------------------------------------------------------------------

/*
Staircase

Consider a staircase of size n=4:
   #
  ##
 ###
####
Observe that its base and height are both equal to n, and the image is drawn using # symbols and spaces. The last line is not preceded by any spaces.

Write a program that prints a staircase of size n.
*/

#include <bits/stdc++.h>

using namespace std;

// Complete the staircase function below.
void staircase(int n)
{
    for (int ctr = 1; ctr <= n; ++ctr)
    {
        int printCtr = 1;
        while (printCtr <= n - ctr)
        {
            std::cout << " ";
            ++printCtr;
        }
        printCtr = 1;
        while (printCtr <= ctr)
        {
            std::cout << "#";
            ++printCtr;
        }
        std::cout << "\n";
    }
}

int main()
{
    int n;
    cin >> n;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    staircase(n);

    return 0;
}

---------------------------------------------------------------------------

/*
Sherlock and the Valid String

Sherlock considers a string to be valid if all characters of the string appear the same number of times. It is also valid if he can remove just 1 character at 1 index in the string, and the remaining characters will occur the same number of times. Given a string s, determine if it is valid. If so, return YES, otherwise return NO.

For example, if s=abc, it is a valid string because frequencies are {a:1 b:1 c:1}. So is s=abcc because we can remove one c and have 1 of each character in the remaining string. If s=abccc however, the string is not valid as we can only remove 1 occurrence of c. That would leave character frequencies of {a:1 b:1 c:2}.
*/

#include <bits/stdc++.h>

using namespace std;

// Complete the isValid function below.
string isValid(string s)
{
    std::unordered_map<char, unsigned> chAndCountMap;
    for (const auto& ch : s)
    {
        ++chAndCountMap[ch];
    }

    if (chAndCountMap.size() >= 2)
    {
        auto it = chAndCountMap.begin();

        unsigned char1Count = (it++)->second;
        unsigned char2Count = (it++)->second;

        unsigned baseNum = 0u;
        bool isBaseNumPlusOnePresent = false;

        std::cout << "\n char1Count " << char1Count << " char2Count " << char2Count;
        if (char1Count == char2Count)
        {
            baseNum = char1Count;
        }
        else if (char1Count == 1 || char2Count == 1)
        {
            if (char1Count+1 != char2Count && char1Count != char2Count+1)
            {
                baseNum = std::max(char1Count, char2Count);
            }
            else
            {
                baseNum = (it != chAndCountMap.end()) ?
                            (it++)->second :
                            std::min(char1Count, char2Count);
            }
            isBaseNumPlusOnePresent = true;
        }
        else
        {
            if (char1Count+1 != char2Count && char1Count != char2Count+1)
            {
                return "NO";
            }

            baseNum = std::min(char1Count, char2Count);
            isBaseNumPlusOnePresent = true;
        }
        while (it != chAndCountMap.end())
        {
            unsigned currentCharCount = (it++)->second;
            std::cout << "\n currentCharCount " << currentCharCount;
            if (currentCharCount != baseNum)
            {
                if (isBaseNumPlusOnePresent || baseNum+1 != currentCharCount)
                {
                    return "NO";
                }

                isBaseNumPlusOnePresent = true;
            }
        }
    }

    // for (auto [ch, count] : chAndCountMap)
    // {
    //     std::cout << "\n" << ch << "_" << count;
    // }
    return "YES";
}

int main()
{
    ofstream fout(getenv("OUTPUT_PATH"));

    string s;
    getline(cin, s);

    string result = isValid(s);

    fout << result << "\n";

    fout.close();

    return 0;
}

---------------------------------------------------------------------------

/*
Find Merge Point of Two Lists

Given pointers to the head nodes of 2 linked lists that merge together at some point, find the Node where the two lists merge. It is guaranteed that the two head Nodes will be different, and neither will be NULL.

In the diagram below, the two lists converge at Node x:

[List #1] a--->b--->c
                     \
                      x--->y--->z--->NULL
                     /
     [List #2] p--->q

Complete the int findMergeNode(SinglyLinkedListNode* head1, SinglyLinkedListNode* head2) method so that it finds and returns the data value of the Node where the two lists merge.

*/

#include <bits/stdc++.h>

using namespace std;

class SinglyLinkedListNode {
    public:
        int data;
        SinglyLinkedListNode *next;

        SinglyLinkedListNode(int node_data) {
            this->data = node_data;
            this->next = nullptr;
        }
};

class SinglyLinkedList {
    public:
        SinglyLinkedListNode *head;
        SinglyLinkedListNode *tail;

        SinglyLinkedList() {
            this->head = nullptr;
            this->tail = nullptr;
        }

        void insert_node(int node_data) {
            SinglyLinkedListNode* node = new SinglyLinkedListNode(node_data);

            if (!this->head) {
                this->head = node;
            } else {
                this->tail->next = node;
            }

            this->tail = node;
        }
};

void print_singly_linked_list(SinglyLinkedListNode* node, string sep, ofstream& fout) {
    while (node) {
        fout << node->data;

        node = node->next;

        if (node) {
            fout << sep;
        }
    }
}

void free_singly_linked_list(SinglyLinkedListNode* node) {
    while (node) {
        SinglyLinkedListNode* temp = node;
        node = node->next;

        free(temp);
    }
}

// Complete the findMergeNode function below.

/*
 * For your reference:
 *
 * SinglyLinkedListNode {
 *     int data;
 *     SinglyLinkedListNode* next;
 * };
 *
 */
std::unordered_set<SinglyLinkedListNode*> listNodePtrs;
int findMergeNode(SinglyLinkedListNode* head1, SinglyLinkedListNode* head2)
{
    // std::cout << "\nthis " << head1->data << " " << head2->data;
    listNodePtrs.insert(head1);
    listNodePtrs.insert(head2);
    while (head1 || head2)
    {
        if (head1)
        {
            head1 = head1->next;
            if (head1)
            {
                    // std::cout << "\n\t" << head1->data;
                auto result = listNodePtrs.insert(head1);
                if (!result.second) return (*(result.first))->data;
            }
            // else
            //         std::cout << "\n\tend of head1";
        }
        if (head2)
        {
            head2 = head2->next;
            if (head2)
            {
                    // std::cout << "\n\t" << head2->data;
                auto result = listNodePtrs.insert(head2);
                if (!result.second) return (*(result.first))->data;
            }
            // else
            //         std::cout << "\n\tend of head2";
        }
    }
    return 0;
}

int main()
{
    ofstream fout(getenv("OUTPUT_PATH"));

    int tests;
    cin >> tests;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    for (int tests_itr = 0; tests_itr < tests; tests_itr++) {
        int index;
        cin >> index;
        cin.ignore(numeric_limits<streamsize>::max(), '\n');

        SinglyLinkedList* llist1 = new SinglyLinkedList();

        int llist1_count;
        cin >> llist1_count;
        cin.ignore(numeric_limits<streamsize>::max(), '\n');

        for (int i = 0; i < llist1_count; i++) {
            int llist1_item;
            cin >> llist1_item;
            cin.ignore(numeric_limits<streamsize>::max(), '\n');

            llist1->insert_node(llist1_item);
        }

        SinglyLinkedList* llist2 = new SinglyLinkedList();

        int llist2_count;
        cin >> llist2_count;
        cin.ignore(numeric_limits<streamsize>::max(), '\n');

        for (int i = 0; i < llist2_count; i++) {
            int llist2_item;
            cin >> llist2_item;
            cin.ignore(numeric_limits<streamsize>::max(), '\n');

            llist2->insert_node(llist2_item);
        }

        SinglyLinkedListNode* ptr1 = llist1->head;
        SinglyLinkedListNode* ptr2 = llist2->head;

        for (int i = 0; i < llist1_count; i++) {
            if (i < index) {
                ptr1 = ptr1->next;
            }
        }

        for (int i = 0; i < llist2_count; i++) {
            if (i != llist2_count-1) {
                ptr2 = ptr2->next;
            }
        }

        ptr2->next = ptr1;

        int result = findMergeNode(llist1->head, llist2->head);

        fout << result << "\n";
    }

    fout.close();

    return 0;
}
---------------------------------------------------------------------------
/*
Maximum profit

You are a shoplifter and you have broke into a shop. You see N items that you can take adn you know the price for every item. The problem is that you can only take K items. Write a program that will output the maximum amount you can steal.

Input: In the first line input the two numbers, N and K. In the following N lines input the price of each item.

Output: In a single line print the resoult.

Input:
5 2
4
6
3
9
2

Output:
15
*/

#include <cmath>
#include <cstdio>
#include <set>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */
    unsigned N;
    unsigned K;
    std::cin >> N >> K;

    unsigned ctr = 1u;

    std::multiset<unsigned> prices;
    while (ctr <= N)
    {
        unsigned temp;
        std::cin >> temp;
        prices.insert(temp);
        ++ctr;
    }

    unsigned sum = 0u;
    ctr = 1u;
    for (auto it = prices.rbegin(); it != prices.rend() && ctr <= K; ++it, ++ctr)
    {
        sum += *it;
    }
    std::cout << sum;

    return 0;
}
---------------------------------------------------------------------------

/*
Stock Maximize

Your algorithms have become so good at predicting the market that you now know what the share price of Wooden Orange Toothpicks Inc. (WOT) will be for the next number of days.

Each day, you can either buy one share of WOT, sell any number of shares of WOT that you own, or not make any transaction at all. What is the maximum profit you can obtain with an optimum trading strategy?

For example, if you know that prices for the next two days are prices = [1 2], you should buy one share day one, and sell it day two for a profit of 1. If they are instead prices = [2 1], no profit can be made so you don't buy or sell stock those days.

Sample Input
3
3
5 3 2
3
1 2 100
4
1 3 1 2
Sample Output
0
197
3

Others:
7 6 9 3 1 4 5 2

buy
1 1   1 1 1
sell
    2       3
profit ((sell_price * buy_count) - (buy1 + ... + buyn))
    5       7

7 6 9 3 1 4 3 2 4
1 1   1 1   1 1
    2     2     2

3 1 4 3 2 4
1 1   1 1
    2     2
    4     3

3 1 4 3 2 4
1 1 1 1 1
          5
          7

*/

#include <bits/stdc++.h>

using namespace std;

string ltrim(const string &);
string rtrim(const string &);
vector<string> split(const string &);

/*
 * Complete the 'stockmax' function below.
 *
 * The function is expected to return a LONG_INTEGER.
 * The function accepts INTEGER_ARRAY prices as parameter.
 */

long stockmax(const std::vector<int>& prices)
{
    long result = 0L;
    int largestSellingPrice = std::numeric_limits<int>::min();
    for (auto it = prices.rbegin(); it != prices.rend(); ++it)
    {
        *it > largestSellingPrice ?
            largestSellingPrice = *it :
            result += (largestSellingPrice - *it);
    }
    return result;
}

int main()
{
    ofstream fout(getenv("OUTPUT_PATH"));

    string t_temp;
    getline(cin, t_temp);

    int t = stoi(ltrim(rtrim(t_temp)));

    for (int t_itr = 0; t_itr < t; t_itr++) {
        string n_temp;
        getline(cin, n_temp);

        int n = stoi(ltrim(rtrim(n_temp)));

        string prices_temp_temp;
        getline(cin, prices_temp_temp);

        vector<string> prices_temp = split(rtrim(prices_temp_temp));

        vector<int> prices(n);

        for (int i = 0; i < n; i++) {
            int prices_item = stoi(prices_temp[i]);

            prices[i] = prices_item;
        }

        long result = stockmax(prices);

        fout << result << "\n";
    }

    fout.close();

    return 0;
}

string ltrim(const string &str) {
    string s(str);

    s.erase(
        s.begin(),
        find_if(s.begin(), s.end(), not1(ptr_fun<int, int>(isspace)))
    );

    return s;
}

string rtrim(const string &str) {
    string s(str);

    s.erase(
        find_if(s.rbegin(), s.rend(), not1(ptr_fun<int, int>(isspace))).base(),
        s.end()
    );

    return s;
}

vector<string> split(const string &str) {
    vector<string> tokens;

    string::size_type start = 0;
    string::size_type end = 0;

    while ((end = str.find(" ", start)) != string::npos) {
        tokens.push_back(str.substr(start, end - start));

        start = end + 1;
    }

    tokens.push_back(str.substr(start));

    return tokens;
}

---------------------------------------------------------------------------

/*
Common Child

A string is said to be a child of a another string if it can be formed by deleting 0 or more characters from the other string. Given two strings of equal length, what's the longest string that can be constructed such that it is a child of both?
For example, ABCD and ABDC have two children with maximum length 3, ABC and ABD . They can be formed by eliminating either the D or C from both strings. Note that we will not consider ABCD as a common child because we can't rearrange characters and ABCD != ABDC.

Sample Input
HARRY
SALLY
Sample Output
2
Explanation
The longest string that can be formed by deleting zero or more characters from HARRY and SALLY is AY, whose length is 2.

Sample Input 1
AA
BB
Sample Output 1
0
Explanation 1
AA and BB have no characters in common and hence the output is 0

Sample Input 2
SHINCHAN
NOHARAAA
Sample Output 2
3
Explanation 2
The longest string that can be formed between SHINCHAN and NOHARAAA while maintaining the order is NHA.

Sample Input 3
ABCDEF
FBDAMN
Sample Output 3
2
Explanation 3
BD is the longest child of the given strings.
*/


#include <bits/stdc++.h>

using namespace std;

// Complete the commonChild function below.
/*
ABCDEFGH
CEAFCGDE

str1
A B C D E F G H

str2
C E A F C G D E

indexes
0 1 2 3 4 5 6 7

Combinations
A C G
A C D E
A F G

C E F G
C D E

D E

E F G

F G

Map of str1 to corresponding indexes in str2
A 2
B x
C 0 4
D 6
E 1 7
F 3
G 5
H x

Map
2 - 1
2 4 - 11
0 - 1
2 6 - 11
2 4 6 - 111
0 1 - 11
2 7 - 11
2 4 7 - 111
0 7 - 11
2 6 7 - 111
2 4 6 7 - 1111
0 1 7 - 111
2 3 - 11
0 3 - 11
0 1 3 - 111
2 5 - 11
2 4 5 - 111
0 5 - 11
0 1 5 - 111
2 3 5 - 111
0 3 5 - 111
0 1 3 5 - 1111

Maximum from map = 1111 = 4

Output from program
D 6
G 5
F 3
A 2
C 0 4
E 1 7
done
0 1
1 2
2 1
3 2
3 3
3 2
4 2
5 2
5 3
5 2
5 3
5 4
5 3
5 3
6 2
6 2
6 3
7 2
7 2
7 3
7 3
7 3
7 4
*/
int commonChild(string s1, string s2) {
    std::unordered_map<char, std::vector<unsigned>> chAndIndexesMap;
    std::multimap<unsigned, unsigned> indexAndCountMap;

    for (unsigned ctr = 0u; ctr < s2.size(); ++ctr)
    {
        chAndIndexesMap[s2[ctr]].push_back(ctr);
    }

    for (unsigned ctr = 0u; ctr < s1.size(); ++ctr)
    {
        if (!chAndIndexesMap.count(s1[ctr])) continue;

        std::multimap<unsigned, unsigned> currentIndexAndCountMap;
        for (const auto& index : chAndIndexesMap[s1[ctr]])
        {
            bool inserted = false;
            for (auto it = indexAndCountMap.begin(); it != indexAndCountMap.end() && it->first < index; ++it)
            {
                currentIndexAndCountMap.insert({index, it->second + 1u});
                inserted = true;
            }
            if (!inserted) currentIndexAndCountMap.insert({index, 1u});
        }
        indexAndCountMap.insert(currentIndexAndCountMap.begin(), currentIndexAndCountMap.end());
    }
        // for (const auto& elem : chAndIndexesMap)
        // {
        //     std::cout << "\n" << elem.first << " ";
        //     for (const auto& elem2 : elem.second)
        //         std::cout << elem2 << " ";
        // }
        // std::cout << "\ndone\n";
        // for (const auto& elem : indexAndCountMap)
        // {
        //     std::cout << "\n" << elem.first << " " << elem.second;
        // }
    auto max = std::max_element(indexAndCountMap.begin(), indexAndCountMap.end(),
        [](const std::pair<unsigned, unsigned>& lhs, const std::pair<unsigned, unsigned>& rhs)
        {
            return lhs.second < rhs.second;
        });
    return max == indexAndCountMap.end() ?
            0 :
            max->second;
}

int main()
{
    ofstream fout(getenv("OUTPUT_PATH"));

    string s1;
    getline(cin, s1);

    string s2;
    getline(cin, s2);

    int result = commonChild(s1, s2);

    fout << result << "\n";

    fout.close();

    return 0;
}

---------------------------------------------------------------------------

/*
Fraudulent Activity Notifications

HackerLand National Bank has a simple policy for warning clients about possible fraudulent account activity. If the amount spent by a client on a particular day is greater than or equal to 2x the client's median spending for a trailing number of days, they send the client a notification about potential fraud. The bank doesn't send the client any notifications until they have at least that trailing number of prior days' transaction data.

Given the number of trailing days d and a client's total daily expenditures for a period of n days, find and print the number of times the client will receive a notification over all n days.

For example, d=3 and expenditures=[10,20,30,40,50]. On the first three days, they just collect spending data. At day 4, we have trailing expenditures of [10,20,30]. The median is 20 and the day's expenditure is 40. Because 40 >= 2 x 20, there will be a notice. The next day, our trailing expenditures are [20,30,40] and the expenditures are 50. This is less than 2 x 30 so no notice will be sent. Over the period, there was one notice sent.

Note: The median of a list of numbers can be found by arranging all the numbers from smallest to greatest. If there is an odd number of numbers, the middle one is picked. If there is an even number of numbers, median is then defined to be the average of the two middle values.

Function Description
Complete the function activityNotifications in the editor below. It must return an integer representing the number of client notifications.
activityNotifications has the following parameter(s):
- expenditure: an array of integers representing daily expenditures
- d: an integer, the lookback days for median spending

Input Format
The first line contains two space-separated integers n and d, the number of days of transaction data, and the number of trailing days' data used to calculate median spending.
The second line contains n space-separated non-negative integers where each integer i denotes expenditure[i].

Output Format
Print an integer denoting the total number of times the client receives a notification over a period of n days.

Sample Input 0
9 5
2 3 4 2 3 6 8 4 5
Sample Output 0
2
Explanation 0
We must determine the total number of notifications the client receives over a period of n=9 days. For the first five days, the customer receives no notifications because the bank has insufficient transaction data: notifications=0.
On the sixth day, the bank has d=5 days of prior transaction data, {2,3,4,2,3} , and median=3 dollars. The client spends 6 dollars, which triggers a notification because 6 >= 2 x median: notifications = 0 + 1 = 1.
On the seventh day, the bank has d=5 days of prior transaction data, {3,4,2,3,6} , and median=3 dollars. The client spends 8 dollars, which triggers a notification because 8 >= 2 x median: notifications = 1 + 1 = 2.
On the eighth day, the bank has d=5 days of prior transaction data, {4,2,3,6,8} , and median=4 dollars. The client spends 4 dollars, which does not trigger a notification because 4 < 2 x median: notifications=2.
On the ninth day, the bank has d=5 days of prior transaction data, {2,3,6,8,4} , and a transaction median of 4 dollars. The client spends 5 dollars, which does not trigger a notification because 5 < 2 x median: notifications=2.

Sample Input 1
5 4
1 2 3 4 4
Sample Output 1
0

2 3 4 2 3 6 8 4 5
2 3 4 2 3
2 2 3 3 4
          1
  2 3 3 4 6
            1
    2 3 4 6 8
              x
      2 3 4 6 8
                x

2 4 3 6 3 8 2 3
2 4 3 = 3
      1
  4 3 6 = 4
        x
    3 6 3 = 3
          1
      6 3 8 = 6
            x
        3 8 2 = 3
              x
[2] 1
[3] 1
[4] 1

[2] 0
[3] 1
[4] 1
[6] 1
*/

#include <bits/stdc++.h>

using namespace std;

vector<string> split_string(string);

double getMedian(
    const std::map<int, int>& elementAndFrequencyMap,
    const int numOfElements)
{
    int middleIndexBase1 = numOfElements / 2;
    if (numOfElements % 2 != 0) ++middleIndexBase1;

    int currentIndex = 0;
    int medianNumber = 0;
    auto it = elementAndFrequencyMap.begin();
    while (it != elementAndFrequencyMap.end())
    {
        currentIndex += it->second;
        if (currentIndex >= middleIndexBase1)
        {
            medianNumber = it->first;
                // std::cout << "\nmiddleIndexBase1 " << middleIndexBase1<< "="<< medianNumber;
            break;
        }
        ++it;
    }
    if (it != elementAndFrequencyMap.end() && numOfElements % 2 == 0)
    {
        if (middleIndexBase1 + 1 > currentIndex) ++it;
        medianNumber += it->first;
                // std::cout << "\nmiddleIndexBase1+1 " << medianNumber / 2.0;
        return medianNumber / 2.0;
    }
    return medianNumber;
}

// Complete the activityNotifications function below.
int activityNotifications(vector<int> expenditure, int d)
{
    std::map<int, int> trailingExpenditureMap;
    for (int ctr = 0; ctr < d; ++ctr)
    {
        ++trailingExpenditureMap[expenditure[ctr]];
    }

    int fraudCount = 0;
    const int EXPENDITURE_SIZE = static_cast<int>(expenditure.size());
    for (int ctr = d; ctr < EXPENDITURE_SIZE; ++ctr)
    {
        double median = getMedian(trailingExpenditureMap, d);
        if (expenditure[ctr] >= median * 2) ++fraudCount;
        // std::cout << "\n\nfraudCount++" << fraudCount; }

        //         std::cout << "\nfor d " << d << " with median " << median;
        //     for (auto a : trailingExpenditureMap)
        //     {
        //         std::cout << "\n\t" << a.first << ":" << a.second;
        //     }
        --trailingExpenditureMap[expenditure[ctr-d]];
        ++trailingExpenditureMap[expenditure[ctr]];
    }

    return fraudCount;
}

int main()
{
    ofstream fout(getenv("OUTPUT_PATH"));

    string nd_temp;
    getline(cin, nd_temp);

    vector<string> nd = split_string(nd_temp);

    int n = stoi(nd[0]);

    int d = stoi(nd[1]);

    string expenditure_temp_temp;
    getline(cin, expenditure_temp_temp);

    vector<string> expenditure_temp = split_string(expenditure_temp_temp);

    vector<int> expenditure(n);

    for (int i = 0; i < n; i++) {
        int expenditure_item = stoi(expenditure_temp[i]);

        expenditure[i] = expenditure_item;
    }

    int result = activityNotifications(expenditure, d);

    fout << result << "\n";

    fout.close();

    return 0;
}

vector<string> split_string(string input_string) {
    string::iterator new_end = unique(input_string.begin(), input_string.end(), [] (const char &x, const char &y) {
        return x == y and x == ' ';
    });

    input_string.erase(new_end, input_string.end());

    while (input_string[input_string.length() - 1] == ' ') {
        input_string.pop_back();
    }

    vector<string> splits;
    char delimiter = ' ';

    size_t i = 0;
    size_t pos = input_string.find(delimiter);

    while (pos != string::npos) {
        splits.push_back(input_string.substr(i, pos - i));

        i = pos + 1;
        pos = input_string.find(delimiter, i);
    }

    splits.push_back(input_string.substr(i, min(pos, input_string.length()) - i + 1));

    return splits;
}

---------------------------------------------------------------------------

/*
Sherlock and Anagrams

Two strings are anagrams of each other if the letters of one string can be rearranged to form the other string. Given a string, find the number of pairs of substrings of the string that are anagrams of each other.

For example s=mom, the list of all anagrammatic pairs is [m,m], [mo,om] at positions [[0],[2]], [[0,1],[1,2]] respectively.

Sample Input 0
2
abba
abcd
Sample Output 0
4
0
Explanation 0
The list of all anagrammatic pairs is [a,a], [ab,ba], [b,b] and [abb,bba] at positions [[0],[3]], [[0,1],[2,3]], [[1],[2]] and [[0,1,2],[1,2,3]] respectively.
No anagrammatic pairs exist in the second query as no character repeats.

Sample Input 1
2
ifailuhkqq
kkkk
Sample Output 1
3
10
Explanation 1
For the first query, we have anagram pairs [i,i], [q,q] and [ifa,fai].
For the second query:
There are 6 anagrams of the form [k,k]. There are 3 anagrams of the form [kk,kk]. There is 1 anagram of the form [kkk,kkk].

Sample Input 2
1
cdcd
Sample Output 2
5
Explanation 2
There are two anagrammatic pairs of length 1: [c,c] and [d,d].
There are three anagrammatic pairs of length 2: [cd,dc], [cd,cd], [dc,cd].
*/

#include <bits/stdc++.h>

using namespace std;

// Complete the sherlockAndAnagrams function below.
int sherlockAndAnagrams(string s)
{
    int totalCount = 0u;

    std::map<std::multiset<char>, int> substringsCountMap;
    for (int ctr = 0u; ctr < static_cast<int>(s.size()); ++ctr)
    {
        std::multiset<char> substring;
        for (int ctrCopy = ctr; ctrCopy >= 0; --ctrCopy)
        {
            substring.insert(s[ctrCopy]);
            auto insertRet = substringsCountMap.insert({substring, 0u});
            if (!insertRet.second)
            {
                totalCount += insertRet.first->second;
            }
            ++(insertRet.first->second);
        }
    }
    return totalCount;
}

int main()
{
    ofstream fout(getenv("OUTPUT_PATH"));

    int q;
    cin >> q;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    for (int q_itr = 0; q_itr < q; q_itr++) {
        string s;
        getline(cin, s);

        int result = sherlockAndAnagrams(s);

        fout << result << "\n";
    }

    fout.close();

    return 0;
}

---------------------------------------------------------------------------
/*
Minimum Loss

40 15 17 5 20 1 3 12 8
40         20
   15             12
      17          12
         5      3
           20     12
              1        x
                3      x
                  12 8
                     8 x

1 3 5 8 12 15 17 20 40

Lauren has a chart of distinct projected prices for a house over the next several years. She must buy the house in one year and sell it in another, and she must do so at a loss. She wants to minimize her financial loss.

For example, the house is valued at price=[20,15,8,2,12] over the next n=5 years. She can purchase the home in any year, but she must resell the house at a loss in one of the following years. Her minimum loss would be incurred by purchasing in year 2 at price[1]=15 and reselling in year 5 at price[4]=12.

Find and print the minimum amount of money Lauren must lose if she buys the house and resells it within the next n years.

Note: It's guaranteed that a valid answer exists.

Sample Input 0
3
5 10 3
Sample Output 0
2

Sample Input 1
5
20 7 8 2 5
Sample Output 1
2
*/

#include <bits/stdc++.h>

using namespace std;

vector<string> split_string(string);

// Complete the minimumLoss function below.
// int minimumLoss(vector<long> prices) {
//     std::set<long> priceSorted{prices.begin(), prices.end()};
//     long minimumLoss = std::numeric_limits<long>::max();
//     for (const auto& price : prices)
//     {
//         auto it = priceSorted.find(price);
//         if (it != priceSorted.begin() && it != priceSorted.end())
//         {
//             auto itCopy = it;
//             long currentLoss = price - *(--itCopy);
//             std::cout << "\n price " << price << " - *(--itCopy) " << *(--itCopy) << " = " << currentLoss;
//             if (currentLoss < minimumLoss)
//             {
//                 minimumLoss = currentLoss;
//             }
//         }
//         priceSorted.erase(it);
//     }
//     return minimumLoss;
// }
int minimumLoss(vector<long> prices) {
    std::set<long> processedPrices;
    long minimumLoss = std::numeric_limits<long>::max();
    for (auto it = prices.rbegin(); it != prices.rend(); ++it)
    {
        auto insertResult = processedPrices.insert(*it);
        auto pointOfInsertion = insertResult.first;

        if (pointOfInsertion == processedPrices.begin() || pointOfInsertion == processedPrices.end()) continue;

        long currentLoss = *it - *(--pointOfInsertion);
        std::cout << "\n price " << *it << " - *(--pointOfInsertion) " << *(--pointOfInsertion) << " = " << currentLoss;
        if (currentLoss < minimumLoss)
        {
            minimumLoss = currentLoss;
        }
    }
    return minimumLoss;
}

int main()
{
    ofstream fout(getenv("OUTPUT_PATH"));

    int n;
    cin >> n;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    string price_temp_temp;
    getline(cin, price_temp_temp);

    vector<string> price_temp = split_string(price_temp_temp);

    vector<long> price(n);

    for (int i = 0; i < n; i++) {
        long price_item = stol(price_temp[i]);

        price[i] = price_item;
    }

    int result = minimumLoss(price);

    fout << result << "\n";

    fout.close();

    return 0;
}

vector<string> split_string(string input_string) {
    string::iterator new_end = unique(input_string.begin(), input_string.end(), [] (const char &x, const char &y) {
        return x == y and x == ' ';
    });

    input_string.erase(new_end, input_string.end());

    while (input_string[input_string.length() - 1] == ' ') {
        input_string.pop_back();
    }

    vector<string> splits;
    char delimiter = ' ';

    size_t i = 0;
    size_t pos = input_string.find(delimiter);

    while (pos != string::npos) {
        splits.push_back(input_string.substr(i, pos - i));

        i = pos + 1;
        pos = input_string.find(delimiter, i);
    }

    splits.push_back(input_string.substr(i, min(pos, input_string.length()) - i + 1));

    return splits;
}

---------------------------------------------------------------------------

/*
Basic Data Types

Print each element on a new line in the same order it was received as input. Note that the floating point value should be correct up to 3 decimal places and the double to 9 decimal places.

Sample Input
3 12345678912345 a 334.23 14049.30493
Sample Output
3
12345678912345
a
334.230
14049.304930000
*/

#include <iostream>
#include <iomanip>
#include <cstdio>
using namespace std;

int main() {
    // Complete the code.
    int intVar;
    long longVar;
    char charVar;
    float floatVar;
    double doubleVar;

    std::cin >> intVar >> longVar >> charVar >> floatVar >> doubleVar;
    std::cout << intVar << "\n";
    std::cout << longVar << "\n";
    std::cout << charVar << "\n";
    std::cout << std::fixed << std::setprecision(3) << floatVar << "\n";
    std::cout << std::fixed << std::setprecision(9) << doubleVar;
    return 0;
}

---------------------------------------------------------------------------

// Maximum Palindromes
// Madam Hannah Otto, the CEO of Reviver Corp., is fond of palindromes, or words that read the same forwards or backwards. She thinks palindromic brand names are appealing to millennials.

// As part of the marketing campaign for the company's new juicer called the Rotator, Hannah decided to push the marketing team's palindrome-searching skills to a new level with a new challenge.

// In this challenge, Hannah provides a string s consisting of lowercase English letters. Every day, for q days, she would select two integers l and r, take the substring s_l...r (the substring of s from index l to index r), and ask the following question:

// Consider all the palindromes that can be constructed from some of the letters from s_l...r. You can reorder the letters as you need. Some of these palindromes have the maximum length among all these palindromes. How many maximum-length palindromes are there?

// For example, if s = madamimadam, l = 4 and r = 7, then we have,
// s = madamimadam -> s_l...r -> s_4...7 = amim -> palindromes: [mam, mim] -> number of maximum length palindromes = 2

// Your job as the head of the marketing team is to answer all the queries. Since the answers can be very large, you are only required to find the answer modulo 10^9 + 7.

// Complete the functions initialize and answerQuery and return the number of maximum-length palindromes modulo 10^9 + 7.

// Sample Input 0
// week
// 2
// 1 4
// 2 3
// Sample Output 0
// 2
// 1
// Explanation 0
// On the first day, l=1 and r=4. The maximum-length palindromes are "ewe" and "eke".
// On the second day, l=2 and r=3. The maximum-length palindrome is "ee".

// Sample Input 1
// abab
// 1
// 1 4
// Sample Output 1
// 2
// Explanation 1
// Here, the maximum-length palindromes are "abba" and "baab".

#include <bits/stdc++.h>

using namespace std;

string ltrim(const string &);
string rtrim(const string &);
vector<string> split(const string &);

/*
 * Complete the 'initialize' function below.
 *
 * The function accepts STRING s as parameter.
 */
std::string s;
void initialize(string s) {
    // This function is called once before all queries.
    ::s = s;
}

/*
 * Complete the 'answerQuery' function below.
 *
 * The function is expected to return an INTEGER.
 * The function accepts following parameters:
 *  1. INTEGER l
 *  2. INTEGER r
 */

long long unsigned factorial(int n)
{
    long long unsigned result = 1;
    for (int ctr = 1; ctr <= n; ++ctr)
    {
        result *= ctr;
    }
    return result;
}

int answerQuery(int l, int r)
{
    // Return the answer for this query modulo 1000000007.
    std::string sortedSubstr = s.substr(l-1, r-l+1);
    // std::cout << "\n sortedSubstr " << sortedSubstr;
    std::sort(sortedSubstr.begin(), sortedSubstr.end());
    // std::cout << " - " << sortedSubstr << "\n";

    int nonRepeatingCharsCount = 0;
    int repeatingCharsCount = 0;
    std::string repeatingChars = "";
    bool isLastCharCounted = false;

    unsigned sortedSubstrSize = sortedSubstr.size();
    for (unsigned ctr = 1u; ctr < sortedSubstrSize; ++ctr)
    {
        if (sortedSubstr[ctr] == sortedSubstr[ctr-1])
        {
            repeatingCharsCount += 2;
            repeatingChars += sortedSubstr[ctr];
            ++ctr;
            if (ctr >= sortedSubstrSize) isLastCharCounted = true;
        }
        else
        {
            ++nonRepeatingCharsCount;
        }
    }
    if (sortedSubstrSize >= 1 && !isLastCharCounted)
    {
        ++nonRepeatingCharsCount;
    }

    // Solution 1: without considering same characters in repeatingCharsCount
    // long long unsigned permutations = factorial(repeatingCharsCount/2);
    // long long unsigned maximumPalindromes = nonRepeatingCharsCount != 0 ?
    //                                         permutations * nonRepeatingCharsCount :
    //                                         permutations;
    // return maximumPalindromes % 1000000007;

    // Solution 2: considering same characters in repeatingCharsCount
    std::unordered_set<std::string> permutations;
    do
    {
        permutations.insert(repeatingChars);
    }
    while (std::next_permutation(repeatingChars.begin(), repeatingChars.end()));
    long long unsigned maximumPalindromes = nonRepeatingCharsCount != 0 ?
                                            permutations.size() * nonRepeatingCharsCount :
                                            permutations.size();
    return maximumPalindromes % 1000000007;
}

int main()
{
    ofstream fout(getenv("OUTPUT_PATH"));

    string s;
    getline(cin, s);

    initialize(s);

    string q_temp;
    getline(cin, q_temp);

    int q = stoi(ltrim(rtrim(q_temp)));

    for (int q_itr = 0; q_itr < q; q_itr++) {
        string first_multiple_input_temp;
        getline(cin, first_multiple_input_temp);

        vector<string> first_multiple_input = split(rtrim(first_multiple_input_temp));

        int l = stoi(first_multiple_input[0]);

        int r = stoi(first_multiple_input[1]);

        int result = answerQuery(l, r);

        fout << result << "\n";
    }

    fout.close();

    return 0;
}

string ltrim(const string &str) {
    string s(str);

    s.erase(
        s.begin(),
        find_if(s.begin(), s.end(), not1(ptr_fun<int, int>(isspace)))
    );

    return s;
}

string rtrim(const string &str) {
    string s(str);

    s.erase(
        find_if(s.rbegin(), s.rend(), not1(ptr_fun<int, int>(isspace))).base(),
        s.end()
    );

    return s;
}

vector<string> split(const string &str) {
    vector<string> tokens;

    string::size_type start = 0;
    string::size_type end = 0;

    while ((end = str.find(" ", start)) != string::npos) {
        tokens.push_back(str.substr(start, end - start));

        start = end + 1;
    }

    tokens.push_back(str.substr(start));

    return tokens;
}

---------------------------------------------------------------------------

// Find first non-repeated character in a string

#include <iostream>
#include <set>
#include <string>
#include <unordered_map>

char findFirstNonRepeatingChar(const std::string& stringToRead)
{
    std::unordered_map<char, int> insertedCharsAndFirstIndex;
    std::set<unsigned> nonRepeatingCharIndexes;

    for (unsigned index = 0u; index < stringToRead.size(); ++index)
    {
        auto foundIt = insertedCharsAndFirstIndex.find(stringToRead[index]);
        if (foundIt == insertedCharsAndFirstIndex.end())
        {
            insertedCharsAndFirstIndex.insert({stringToRead[index], index});
            nonRepeatingCharIndexes.insert(index);
        }
        else
        {
            if (foundIt->second != -1)
            {
                nonRepeatingCharIndexes.erase(foundIt->second);
                foundIt->second = -1;
            }
        }
    }
    return nonRepeatingCharIndexes.empty() ?
            '-' :
            stringToRead[*nonRepeatingCharIndexes.begin()];
}

int main()
{
    std::string stringToRead
        // = "swiss";
        // = "swissi";
        // = "swissw";
        = "niel godffrrrey pablo poncianodg";
    std::cout << "\n" << stringToRead << " = " << findFirstNonRepeatingChar(stringToRead);

    return 0;
}

---------------------------------------------------------------------------

#include <array>
#include <iostream>
#include <sstream>

template <typename DataType>
struct Node
{
    DataType data;
    Node<DataType>* next;
};

template <typename DataType>
void print(Node<DataType>* head)
{
    while (head != nullptr)
    {
        std::cout << "\n" << head->data;
        head = head->next;
    }
}

template <typename DataType>
void print(
    const Node<DataType>* previous,
    const Node<DataType>* current,
    const Node<DataType>* next)
{
    std::string NULL_STR = "null";
    std::stringstream previousSs;
    std::stringstream currentSs;
    std::stringstream nextSs;

    if (previous) previousSs << previous->data;
    else          previousSs << NULL_STR;
    if (current)  currentSs << current->data;
    else          currentSs << NULL_STR;
    if (next)     nextSs << next->data;
    else          nextSs << NULL_STR;

    std::cout << "\n\t" << currentSs.str() << "::next changed from "
                << previousSs.str() << " to " << nextSs.str();
}

Node<int>* constructLinkedList()
{
    constexpr unsigned ARRAY_SIZE = 10u;
    const std::array<int, ARRAY_SIZE> dataForTheList
        {
            11, 22, -333, 4, 5, 666, 777, -8, -9999, 12345
        };

    Node<int>* head = new Node<int>{dataForTheList[0], nullptr};
    auto current = head;
    for (unsigned index = 1u; index < ARRAY_SIZE; ++index)
    {
        current->next = new Node<int>{dataForTheList[index], nullptr};
        current = current->next;
    }
    return head;
}

template <typename DataType>
Node<DataType>* reverseLinkedList(Node<DataType>* head)
{
    Node<DataType>* previous = nullptr;
    Node<DataType>* current = head;
    // Node<DataType>* newHead = head;
    while (current != nullptr)
    {
        auto next = current->next;
        current->next = previous;
        print(previous, current, next);
        previous = current;
        // newHead = current;
        current = next;
    }
    // return newHead;
    return previous;
}

int main()
{
    auto head = constructLinkedList();
    std::cout<<"\nconstructLinkedList()";
    print(head);

    head = reverseLinkedList(head);
    std::cout<<"\nreverseLinkedList()";
    print(head);

    return 0;
}

---------------------------------------------------------------------------

// Dijkstra's Algorithm

/******************************************************************************

Welcome to GDB Online.
GDB online is an online compiler and debugger tool for C, C++, Python, Java, PHP, Ruby, Perl,
C#, VB, Swift, Pascal, Fortran, Haskell, Objective-C, Assembly, HTML, CSS, JS, SQLite, Prolog.
Code, Compile, Run and Debug online from anywhere in world.

*******************************************************************************/

/*
INPUT
A B 5
A C 3
B C 2
B G 1
B E 3
C D 7
C E 7
D A 2
D F 6
E D 2
E F 1
G E 1
0
D E
F B
A F
B D
C F
F C
B A
0

OUTPUT

Data: F
Data: B
	C : 2
	G : 1
	E : 3
Data: A
	B : 5
	C : 3
Data: C
	D : 7
	E : 7
Data: G
	E : 1
Data: E
	D : 2
	F : 1
Data: D
	A : 2
	F : 6
Path from D to E
	Nodes: D A B G E 
	Distance: 9
Path from F to B
	No path found!
Path from A to F
	Nodes: A B G E F 
	Distance: 8
Path from B to D
	Nodes: B G E D 
	Distance: 4
Path from C to F
	Nodes: C E F 
	Distance: 8
Path from F to C
	No path found!
Path from B to A
	Nodes: B G E D A 
	Distance: 6
*/

#include <algorithm>
#include <iostream>
#include <limits>
#include <sstream>
#include <set>
#include <string>
#include <tuple>
#include <unordered_map>
#include <utility>
#include <vector>

template <typename DataType>
struct Node
{
    struct Neighbor
    {
        Node<DataType>* node;
        int weight;
    };

    DataType data;
    std::vector<Neighbor> neighbors;
};

template <typename DataType>
struct Path
{
    std::vector<Node<DataType>*> nodes;
    int distance;
};

std::unordered_map<char, Node<char>*> charAndNodeMap;
std::unordered_map<Node<char>*, Path<char>> nodeAndPathMap;

void printNodes()
{
    // for (const auto& [std::ignore, node] : charAndNodeMap)
    for (const auto& charAndNode : charAndNodeMap)
    {
        std::cout << "\nData: " << charAndNode.second->data;
        for (const auto& neighbor : charAndNode.second->neighbors)
        {
            std::cout << "\n\t" << neighbor.node->data << " : " << neighbor.weight;
        }
    }
}

template <typename DataType>
void printPath(
    DataType source,
    DataType destination,
    const Path<DataType>& path)
{
    std::cout << "\nPath from " << source << " to " << destination;
    if (path.nodes.empty())
    {
        std::cout << "\n\tNo path found!";
    }
    else
    {
        std::cout << "\n\tNodes: ";
        for (const auto& node : path.nodes)
        {
            std::cout << node->data << " ";
        }
        std::cout << "\n\tDistance: " << path.distance;
    }
}

void constructNodes()
{
    std::string input = "";
    while (true)
    {
        std::getline(std::cin, input);
        if (input == "0") break;

        char source;
        char destination;
        int weightToDestination;
        std::stringstream ss(input);
        ss >> source >> destination >> weightToDestination;
        // std::cout << "\n" << source << "-" << destination << ":" << weightToDestination;

        if (!charAndNodeMap[source])
        {
            charAndNodeMap[source] = new Node<char>{source, {}};
            nodeAndPathMap.insert(
                {
                    charAndNodeMap[source],
                    Path<char>
                        {
                            {}, std::numeric_limits<int>::max()
                        }
                });
        }
        if (!charAndNodeMap[destination])
        {
            charAndNodeMap[destination] = new Node<char>{destination, {}};
            nodeAndPathMap.insert(
                {
                    charAndNodeMap[destination],
                    Path<char>
                        {
                            {}, std::numeric_limits<int>::max()
                        }
                });
        }

        charAndNodeMap[source]->neighbors.push_back(
            {
                charAndNodeMap[destination],
                weightToDestination
            });
    }
}

void dijkstraAlgorithm()
{
    std::string input = "";
    while (true)
    {
        std::getline(std::cin, input);
        if (input == "0") break;

        char source;
        char destination;
        std::stringstream ss(input);
        ss >> source >> destination;

        auto nodeAndPathMapCopy = nodeAndPathMap;

        auto sourceNode = charAndNodeMap[source];
        nodeAndPathMapCopy[sourceNode].nodes.push_back(sourceNode);
        nodeAndPathMapCopy[sourceNode].distance = 0;

        std::multiset<int> distances{0};
        bool isDestinationFound = false;
        while (!nodeAndPathMapCopy.empty() && !distances.empty())
        {
            auto lowestDistanceIt = distances.begin();
            auto currentNodeAndPathIt = std::find_if(nodeAndPathMapCopy.begin(),
                                                    nodeAndPathMapCopy.end(),
                                                    [&lowestDistanceIt](const auto& nodeAndPath)
                                                    {
                                                        return nodeAndPath.second.distance ==
                                                                *lowestDistanceIt;
                                                    });
            const auto& currentNode = currentNodeAndPathIt->first;
            const auto& currentPath = currentNodeAndPathIt->second;

            if (currentNode->data == destination)
            {
                isDestinationFound = true;
                break;
            }

            for (const auto& neighborNode : currentNode->neighbors)
            {
                if (nodeAndPathMapCopy.count(neighborNode.node) == 0) continue; // means it is already visited

                int neighborDistance = currentPath.distance + neighborNode.weight;
                if (nodeAndPathMapCopy[neighborNode.node].distance < neighborDistance) continue; // means it is already in queue for visiting with a lower path
    
                auto distancesIt = std::find(distances.begin(),
                                            distances.end(),
                                            nodeAndPathMapCopy[neighborNode.node].distance);
                if (distancesIt != distances.end()) distances.erase(distancesIt);
                distances.insert(neighborDistance);
    
                nodeAndPathMapCopy[neighborNode.node].nodes = currentPath.nodes;
                nodeAndPathMapCopy[neighborNode.node].nodes.push_back(neighborNode.node);
                nodeAndPathMapCopy[neighborNode.node].distance = neighborDistance;
            }
            distances.erase(lowestDistanceIt);
            nodeAndPathMapCopy.erase(currentNodeAndPathIt);
        }

        auto destinationNode = charAndNodeMap[destination];
        printPath(source, destination, nodeAndPathMapCopy[destinationNode]);
    }
}

int main()
{
    constructNodes();
    printNodes();
    dijkstraAlgorithm();

    return 0;
}


---------------------------------------------------------------------------

/*
Count number of ways to decode the message

Given that
A = 1, B = 2, C = 3, D = 4,... Z = 26

Count the number of ways a code can be interpreted

ex.
12
can be:
    1 2 = AB
    12  = L
so 2 ways

1.
12456 = 3
1 2 4 5 6
1 24 5 6
12 4 5 6

2.
12416 = 6
1 2 4 1 6
1 2 4 16
1 24 1 6
1 24 16
12 4 1 6
12 4 16

3.
1 2 2 1 6
        1
      2
    3
  5
8

1 2 2 1 6
1 2 2 16
1 2 21 6
1 22 1 6
1 22 16
12 2 1 6
12 2 16
12 21 6

4.
1 3 5 1 2 1 2 9
              1
            1
          2
        3
      5
    5
  5
10

1 3 5 1 2 1 2 9
1 3 5 1 2 12 9
1 3 5 1 21 2 9
1 3 5 12 1 2 9
1 3 5 12 12 9

13 5 1 2 1 2 9
13 5 1 2 12 9
13 5 1 21 2 9
13 5 12 1 2 9
13 5 12 12 9
*/

#include <iostream>
#include <sstream>
#include <unordered_map>

void countNumberOfWays(const std::string& code)
{
    std::unordered_map<int, int> indexAndWaysCountMap;
    indexAndWaysCountMap[code.size() - 1] = 1;
    for (int ctr = code.size() - 2; ctr >= 0; --ctr)
    {
        std::stringstream ss;
        ss << code[ctr] << code[ctr + 1];
        int adjacent;
        ss >> adjacent;

        if (adjacent > 26)
        {
            indexAndWaysCountMap[ctr] = indexAndWaysCountMap[ctr + 1];
        }
        else
        {
            int multiplier = ctr + 2 >= code.size() ?
                                1 :
                                indexAndWaysCountMap[ctr + 2];
            int additional = indexAndWaysCountMap[ctr + 1] - multiplier;
            indexAndWaysCountMap[ctr] = (multiplier * 2) + additional;
        }
        std::cout << "\n" << ctr << ":" << code[ctr] << "    " << adjacent << ":" << indexAndWaysCountMap[ctr];
    }

    std::cout << "\n" << code << "->" << indexAndWaysCountMap[0] << "\n";
}

int main()
{
    countNumberOfWays("13512129");
    countNumberOfWays("12");
    countNumberOfWays("12456");
    countNumberOfWays("12416");
    countNumberOfWays("12216");
    countNumberOfWays("98765432");

    return 0;
}
--------------------------------------------------------------------

// Clone a Binary Tree

// Given a Binary Tree having random pointers clone the Binary Tree. The task is to complete the function cloneTree which take one argument the root of the tree to be copied and should return the root of the cloned tree.

// Input:
// The first line of input contains the no of test cases. Then T test cases follow. Each test case contains 2 lines the first line contains and integer N denoting the no of edges of the tree and then in the next line are N space separated queries .The query on tree are of three types
// a) a b L  (Represents that b is the left child of a)
// b) a b R (Represents that b is the right child of a)
// c) a b X (Represents a random pointer from node a to node b)  

// Output:
// Your function should return the root of the cloned tree. The output will be 1 if the tree is successfully cloned.

// Constraints:
// 1 <=T<= 30
// 1 <=Number of nodes<= 100
// 1 <=Data of a node<= 1000

// Example(To be used only for expected output):
// Input
// 1
// 6
// 6 3 L 6 8 R 3 1 L 3 5 R 1 3 X 5 6 X

// Output
// 1

// Above test case represents the below tree with 6 edges

{
#include <bits/stdc++.h>
using namespace std;
/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct Node
{
    int data;
    struct Node *left;
    struct Node *right;
    struct Node *random;
    
    Node(int x){
        data = x;
        left = NULL;
        right = NULL;
        random = NULL;
    }
};
Node *cloneTree(Node *);
int printInorder(Node* a,Node *b)
{
    if ((a==NULL and b==NULL) or (a->random==NULL and b->random==NULL))
        return 1;
    if(a->random->data == b->random->data and printInorder(a->left,b->left) and printInorder(a->right,b->right))
        return 1;
    return false;
}
void inorder(Node *root)
{
    if (root == NULL)
       return;
    inorder(root->left);
    cout << root->data << " ";
    inorder(root->right);
}
/* Driver program to test size function*/
int main()
{
  int t;
  scanf("%d
", &t);
  while (t--)
  {
     map<int, Node*> m;
     int n;
     scanf("%d",&n);
     struct Node *root = NULL;
     struct Node *child;
     while (n--)
     {
        Node *parent;
        char lr;
        int n1, n2;
        scanf("%d %d %c", &n1, &n2, &lr);
        if (m.find(n1) == m.end())
        {
           parent = new Node(n1);
           m[n1] = parent;
           if (root == NULL)
             root = parent;
        }
        else
           parent = m[n1];
        child = new Node(n2);
        if (lr == 'L'){
          parent->left = child;
           m[n2]  = child;
        }
        else if(lr=='R'){
          parent->right = child;
           m[n2]  = child;
        }
        else{
          parent->random = m[n2];
        }
     }
     Node *t = cloneTree(root);
      if(t==root)
        cout<<0<<endl;
     else
     cout<<printInorder(root,t);
     cout<<endl;
  }
  return 0;
}
Node* cloneTree(Node* tree);

}
/*This is a function problem.You only need to complete the function given below*/
/* A binary tree node has data, pointer to left child
   and a pointer to right child 
struct Node
{
    int data;
    Node* left;
    Node* right;
    Node *random;
};
*/
/* The function should clone the passed tree and return 
   root of the cloned tree */

std::unordered_map<Node*, Node*> oldAndClonedNodes;

// Solution 1
Node* cloneRecursive(Node* node)
{
    if (node == nullptr) return nullptr;

    if (oldAndClonedNodes.count(node) == 0) oldAndClonedNodes[node] = new Node(node->data);
    Node* clonedNode = oldAndClonedNodes[node];

    // clonedNode->data = node->data;
    clonedNode->left = cloneRecursive(node->left);
    clonedNode->right = cloneRecursive(node->right);
    if (node->random)
    {
        if (oldAndClonedNodes.count(node->random) == 0) oldAndClonedNodes[node->random] = new Node(node->random->data);
        clonedNode->random = oldAndClonedNodes[node->random];
    }

    return clonedNode;
}

// Solution 2
Node* createClones(Node* node)
{
    if (!node) return nullptr;

    oldAndClonedNodes[node] = new Node(node->data);
    createClones(node->left);
    createClones(node->right);

    return oldAndClonedNodes[node];
}

void updateClones(Node* original, Node* clone)
{
    if (!original) return;

    clone->left = original->left ?
                    oldAndClonedNodes[original->left] : nullptr;
    clone->right = original->right ?
                    oldAndClonedNodes[original->right] : nullptr;
    clone->random = original->random ?
                    oldAndClonedNodes[original->random] : nullptr;
    updateClones(original->left, clone->left);
    updateClones(original->right, clone->right);
}

Node* createClonesThenUpdate(Node* node)
{
    Node* clone = createClones(node);
    updateClones(node, clone);
    return clone;
}

Node* cloneTree(Node* tree)
{
   //Your code here

//   return cloneRecursive(tree);
    return createClonesThenUpdate(tree);
}

--------------------------------------------------------------------

// Height of Binary Tree

// Given a binary tree, find height of it.

//         1
//      /     \
//    10      39
//   /
// 5
// The above tree has a height of 3.
// Note: Height of empty tree is considered 0.

// Input Format:
// The first line of input contains T denoting the number of testcases. T testcases follow. Each testcase contains two lines of input. The first line contains number of edges. The second line contains relation between nodes.

// Output Format:
// For each testcase, in a new line, print the height of tree.

// Your Task:
// You don't have to take input. Complete the function height() that takes node as parameter and returns the height. The printing is done by the driver code.

// Constraints:
// 1 <= T <= 100
// 1 <= Number of nodes <= 100
// 1 <= Data of a node <= 1000

// Example:
// Input:
// 2
// 2
// 1 2 L 1 3 R
// 4
// 10 20 L 10 30 R 20 40 L 20 60 R

// Output:
// 2
// 3

// Explanation:
// Testcase1: The tree is
//         1
//      /      \
//    3       2
// So, the height would be 2.
// Testcase2: The tree is
//                            10
//                         /        \
//                      20         30
//                   /       \
//                40       60
// So, height would be 3.

{
#include <bits/stdc++.h>
using namespace std;
/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct Node
{
    int data;
    struct Node* left;
    struct Node* right;
    
    Node(int x){
        data = x;
        left = right = NULL;
    }
};
/* Computes the number of nodes in a tree. */
int height(struct Node* node);
void inorder(Node *root)
{
    if (root == NULL)
       return;
    inorder(root->left);
    cout << root->data << " ";
    inorder(root->right);    
}
/* Driver program to test size function*/
int main()
{
  int t;
  scanf("%d
", &t);
  while (t--)
  {
     map<int, Node*> m;
     int n;
     scanf("%d",&n);
     struct Node *root = NULL;
     struct Node *child;
     while (n--)
     {
        Node *parent;
        char lr;
        int n1, n2;
        scanf("%d %d %c", &n1, &n2, &lr);
        if (m.find(n1) == m.end())
        {
           parent = new Node(n1);
           m[n1] = parent;
           if (root == NULL)
             root = parent;
        }
        else
           parent = m[n1];
        child = new Node(n2);
        if (lr == 'L')
          parent->left = child;
        else
          parent->right = child;
        m[n2]  = child;
     }
     cout << height(root) << endl;
  }
  return 0;
}

}
/*This is a function problem.You only need to complete the function given below*/
/* Tree node structure  used in the program
struct Node
{
    int data;
    struct Node* left;
    struct Node* right;
    
    Node(int x){
        data = x;
        left = right = NULL;
    }
};*/
/* Computes the height of binary tree with given root.  */
int maxHeight = 0;

int getHeightRecursive(Node* node)
{
   // Your code here
   if (!node) return 0; // should be -1, but height in question is described differently with base 1
   int leftHeight = getHeightRecursive(node->left);
   int rightHeight = getHeightRecursive(node->right);
   int currentHeight = std::max(leftHeight, rightHeight) + 1;
   maxHeight = std::max(currentHeight, maxHeight);
   return currentHeight;
}

int getHeightQueue(Node* node)
{
    if (!node) return 0;

    using NodeHeight = int;
    std::queue<std::pair<Node*, NodeHeight>> nodes;
    nodes.push({node, 1}); // should start height from 0, but problem states differently
    while (true)
    {
        auto currentNode = nodes.front();
        // std::cout << "\n" << currentNode.first->data << " = " << currentNode.second;
        nodes.pop();
        if (currentNode.first->left) nodes.push({currentNode.first->left, currentNode.second + 1});
        if (currentNode.first->right) nodes.push({currentNode.first->right, currentNode.second + 1});

        if (nodes.empty()) return currentNode.second;
    }
    return 0;
}

int height(Node* node)
{
   // Your code here

    // Solution 1
    {
    //   maxHeight = 0;
    //   getHeightRecursive(node);
    //   return maxHeight;
    }

    // Solution 2
    {
        // std::cout << "\nSTART!!!";
        return getHeightQueue(node);
        // std::cout << "\nEND!!!\n";
    }
}

--------------------------------------------------------------------

// Check for BST

// Given a binary tree, return true if it is BST, else false. For example, the following tree is not BST, because 11 is in left subtree of 10. The task is to complete the function isBST() which takes one argument, root of Binary Tree.

//         10
//      /     \
//    7       39
//      \
//       11

// Input:
// The input contains T, denoting number of testcases. For each testcase there will be two lines. The first line contains number of edges. The second line contains two nodes and a character separated by space. The first node denotes data value, second node denotes where it will be assigned to the previous node which will depend on character 'L' or 'R' i.e. the 2nd node will be assigned as left child to the 1st node if character is 'L' and so on. The first node of second line is root node. The struct or class Node has a data part which stores the data, pointer to left child and pointer to right child. There are multiple test cases. For each test case, the function will be called individually.

// Output:
// The function should return 1 if BST else return 0.

// User Task:
// Since this is a functional problem you don't have to worry about input, you just have to complete the function isBST().

// Constraints:
// 1 <= T <= 100
// 0 <= Number of edges <= 100
// 1 <= Data of a node <= 1000

// Example:
// Input:
// 2
// 2
// 1 2 R 1 3 L
// 4
// 10 20 L 10 30 R 20 40 L 20 60 R

// Output:
// 0
// 0

// Explanation:
// Testcases 1: The given binary tree is not BST, hence the answer is 0.

{
#include <bits/stdc++.h>
using namespace std;
/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct Node {
    int data;
    Node* right;
    Node* left;
    
    Node(int x){
        data = x;
        right = NULL;
        left = NULL;
    }
};
/* Returns true if the given tree is a binary search tree
 (efficient version). */
bool isBST(struct Node* node);
int isBSTUtil(struct Node* node, int min, int max);
/* Driver program to test size function*/
int main()
{
  int t;
  struct Node *child;
  scanf("%d
", &t);
  while (t--)
  {
     map<int, Node*> m;
     int n;
     scanf("%d
",&n);
     struct Node *root = NULL;
     while (n--)
     {
        Node *parent;
        char lr;
        int n1, n2;
        scanf("%d %d %c", &n1, &n2, &lr);
      //  cout << n1 << " " << n2 << " " << (char)lr << endl;
        if (m.find(n1) == m.end())
        {
           parent = new Node(n1);
           m[n1] = parent;
           if (root == NULL)
             root = parent;
        }
        else
           parent = m[n1];
        child = new Node(n2);
        if (lr == 'L')
          parent->left = child;
        else
          parent->right = child;
        m[n2]  = child;
     }
     cout << isBST(root) << endl;
  }
  return 0;
}

}
/*This is a function problem.You only need to complete the function given below*/
/* A binary tree node has data, pointer to left child
   and a pointer to right child  
struct Node {
    int data;
    Node* right;
    Node* left;
    
    Node(int x){
        data = x;
        right = NULL;
        left = NULL;
    }
}; */

int lastData = std::numeric_limits<int>::min();

bool isBSTImpl(Node* root)
{
    // Your code here
    if (root == nullptr) return true;

    if (!isBSTImpl(root->left)) return false;
    if (root->data < lastData) return false;
    lastData = root->data;
    return isBSTImpl(root->right);
}

bool isBST(Node* root)
{
    // Your code here
    lastData = std::numeric_limits<int>::min();
    return isBSTImpl(root);
}

--------------------------------------------------------------------

// Finding middle element in a linked list

// Given a singly linked list of N nodes. The task is to find middle of the linked list. For example, if given linked list is 1->2->3->4->5 then output should be 3.
// If there are even nodes, then there would be two middle nodes, we need to print second middle element. For example, if given linked list is 1->2->3->4->5->6 then output should be 4.

// Input:
// First line of input contains number of testcases T. For each testcase, first line of input contains length of linked list and next line contains data of nodes of linked list.

// Output:
// For each testcase, there will be a single line of output containing data of middle element of linked list.

// User Task:
// The task is to complete the function getMiddle() which takes head reference as the only argument and should return the data at the middle node of linked list.

// Constraints:
// 1 <= T <= 100
// 1 <= N <= 100

// Example:
// Input:
// 2
// 5
// 1 2 3 4 5
// 6
// 2 4 6 7 5 1

// Output:
// 3
// 7

// Explanation:
// Testcase 1: Since, there are 5 elements, therefore 3 is the middle element at index 2 (0-based indexing).

{
// C program to find n'th Node in linked list
#include <stdio.h>
#include <stdlib.h>
#include<iostream>
using namespace std;
/* Link list Node */
struct Node
{
    int data;
    struct Node* next;
    
    Node(int x){
        data = x;
        next = NULL;
    }
};
void append(struct Node** head_ref, struct Node **tail_ref, int new_data)
{
    struct Node* new_node = new Node(new_data);
    
    if (*head_ref == NULL)
       *head_ref = new_node;
    else
       (*tail_ref)->next = new_node;
    *tail_ref = new_node;
}
/* Function to get the middle of the linked list*/
int getMiddle(struct Node *head);
/* Driver program to test above function*/
int main()
{
  int T,i,n,l;
    cin>>T;
    while(T--){
    struct Node *head = NULL,  *tail = NULL;
        cin>>n;
        for(i=1;i<=n;i++)
        {
            cin>>l;
            append(&head, &tail, l);
        }
    printf("%d
", getMiddle(head));
    }
    return 0;
}

}
/*This is a function problem.You only need to complete the function given below*/
/* Link list Node 
struct Node {
    int data;
    Node* next;
    
    Node(int x){
        data = x;
        next = NULL;
    }
    
}; */
/* Should return data of middle node. If linked list is empty, then  -1*/
#include <vector>
int getMiddle(Node *head)
{
   // Your code here
   
   // Solution 1
//   std::vector<Node*> contiguousNodes;
//   int ctr = 0;
//   while (head != nullptr)
//   {
//       contiguousNodes.push_back(head);
//       head = head->next;
//       ++ctr;
//   }
//   return contiguousNodes[ctr / 2]->data;
    
    // Solution 2
    if (head == nullptr) return 0;

    auto slowIt = head;
    auto fastIt = head->next;

    int mid = slowIt->data;
    int ctr = 0;
    while (fastIt != nullptr)
    {
        if (++ctr % 2)
        {
            slowIt = slowIt->next;
            mid = slowIt->data;
        }
        fastIt = fastIt->next;
    }
    return mid;
}

--------------------------------------------------------------------

// Determine if Two Trees are Identical

// Given two binary trees, the task is to find if both of them are identical or not. 

// Input:
// The task is to complete the method isIdentical(), which takes 2 argument, the roots r1 and r2 of the Binary Trees. The struct Node has a data part which stores the data, pointer to left child and pointer to right child.
// There are multiple test cases. For each test case, this method will be called individually.

// Output:
// The function should return true if both trees are identical else false.

// User task:
// Since this is a functional problem you don't have to worry about input, you just have to complete the function isIdentical() that takes two roots as parameter and returns true or false. The printing is done by the driver code.

// Constraints:
// 1 <= T <= 100
// 1 <= Number of nodes <= 100
// 1 <=Data of a node <= 1000

// Example:
// Input
// 2
// 2
// 1 2 L 1 3 R
// 2
// 1 2 L 1 3 R
// 2
// 1 2 L 1 3 R
// 2
// 1 3 L 1 2 R

// Output
// 1
// 0

// Explanation:
// Testcase 1: There are two trees both having 3 nodes and 2 edges, both trees are identical having the root as 1, left child of 1 is 2 and right child of 1 is 3.
// Testcase 2: There are two trees both having 3 nodes and 2 edges, but both trees are not identical.

{
#include <bits/stdc++.h>
using namespace std;
/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct Node
{
    int data;
    struct Node* left;
    struct Node* right;
    
    Node(int x){
        data = x;
        left = right = NULL;
    }
};
bool isIdentical(Node *,Node *);
/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
/* Driver program to test size function*/
int main()
{
  int t;
  struct Node *child;
  scanf("%d
", &t);
  while (t--)
  {
     map<int, Node*> m;
     int n;
     scanf("%d
",&n);
     struct Node *root = NULL;
     
     while (n--)
     {
        Node *parent;
        char lr;
        int n1, n2;
        scanf("%d %d %c", &n1, &n2, &lr);
        if (m.find(n1) == m.end())
        {
           parent = new Node(n1);
           m[n1] = parent;
           if (root == NULL)
             root = parent;
        }
        else
           parent = m[n1];
        child = new Node(n2);
        if (lr == 'L')
          parent->left = child;
        else
          parent->right = child;
        m[n2]  = child;
     }
     
  //  inorder(root);
    //sec tree
     map<int, Node*> mm;
     int nn;
     scanf("%d
",&nn);
     struct Node *roott = NULL;
    
     while (nn--)
     {
        Node *parent;
        char lr;
        int n1, n2;
        scanf("%d %d %c", &n1, &n2, &lr);
        if (mm.find(n1) == mm.end())
        {
           parent = new Node(n1);
           mm[n1] = parent;
           if (roott == NULL)
             roott = parent;
        }
        else
           parent = mm[n1];
        child = new Node(n2);
        if (lr == 'L')
          parent->left = child;
        else
          parent->right = child;
        mm[n2]  = child;
     }
  
  cout<<isIdentical(root,roott)<<endl;
  }
  return 0;
}

}
/*This is a function problem.You only need to complete the function given below*/
/* A binary tree node
struct Node
{
    int data;
    struct Node* left;
    struct Node* right;
    
    Node(int x){
        data = x;
        left = right = NULL;
    }
};
*/
/* Should return true if trees with roots as r1 and 
   r2 are identical */
#include<stack>
bool isIdentical(Node *r1, Node *r2)
{
    //Your Code here
    if (!r1 || !r2) return !r1 && !r2;

    // Solution 1
    // return r1->data == r2->data &&
    //         isIdentical(r1->left, r2->left) &&
    //         isIdentical(r1->right, r2->right);
    // this was the same solution in geeksforgeeks
    // Complexity of the identicalTree() will be according to the tree with lesser number of nodes.
    // Let number of nodes in two trees be m and n then complexity of sameTree() is O(m) where m < n.
    
    // Solution 2
    std::stack<Node*> root1Stack;
    std::stack<Node*> root2Stack;
    root1Stack.push(r1);
    root2Stack.push(r2);
    while (!root1Stack.empty() && !root2Stack.empty())
    {
        // if (root1Stack.size() != root2Stack.size()) return false; // not needed because null children are added

        auto currentRoot1Node = root1Stack.top();
        auto currentRoot2Node = root2Stack.top();
        root1Stack.pop();
        root2Stack.pop();

        if (!currentRoot1Node || !currentRoot2Node)
        {
            if (currentRoot1Node != currentRoot2Node) return false;
            continue;
        }
        if (currentRoot1Node->data != currentRoot2Node->data) return false;
        root1Stack.push(currentRoot1Node->left);
        root1Stack.push(currentRoot1Node->right);
        root2Stack.push(currentRoot2Node->left);
        root2Stack.push(currentRoot2Node->right);
    }
    return true;
}

--------------------------------------------------------------------

// Find Transition Point

// You are given a sorted array containing only numbers 0 and 1. Find the transition point efficiently. Transition point is a point where "0" ends and "1" begins.

// Input:

// You have to complete the method which takes 2 argument: the array arr[] and size of array N. You should not read any input from stdin/console. There are multiple test cases. For each test cases, this method will be called individually.

// Output:

// Your function should return transition point.

// Constraints:

// 1 ≤ T ≤ 100
// 1 ≤ N ≤ 500000
// 0 ≤ C[i] ≤ 1

// Example:

// Input
// 1
// 5
// 0 0 0 1 1

// Output
// 3

{
#include<bits/stdc++.h>
using namespace std;
int transitionPoint(int arr[],int n);
int main()
{
  int t;
  cin>>t;
  while(t--)
  {
    int n;
    cin>>n;
    int a[n],i;
    for(i=0;i<n;i++)
    {
      cin>>a[i];
    }
    cout<<transitionPoint(a,n)<<endl;
  }
  return 0;
}
}
/*This is a function problem.You only need to complete the function given below*/
int transitionPoint(int arr[],int n)
{
    // Your code goes here
    int leftmost1 = n;
    int left = 0;
    int right = n - 1;

    while (left <= right)
    {
        int middle = (left + right) / 2;
        if (arr[middle] == 0)
        {
            left = middle + 1;
        }
        else if (arr[middle] == 1)
        {
            if (middle < leftmost1) leftmost1 = middle;
            right = middle - 1;
        }
    }
    return leftmost1;
}

--------------------------------------------------------------------

// Binary String

// Given a binary string S. The task is to count the number of substrings that start and end with 1. For example, if the input string is “00100101”, then there are three substrings “1001”, “100101” and “101”.

// Input:
// The first line of input contains an integer T denoting the number of test cases. Each test case consist of an integer 'N' denoting the string length and next line is followed by a binary string.

// Output:
// For each testcase, in a new line, print the number of substring starting and ending with 1 in a separate line.

// User Task:
// The task is to complete the function binarySubstring() which counts the number of substrings starting and ending with 1 and returns count.

// Constraints:
// 1 ≤ T ≤ 100
// 1 ≤ |S| ≤ 104

// Example:
// Input:
// 2
// 4
// 1111
// 5
// 01101

// Output:
// 6
// 3

// Example:
// Testcase 1: There are 6 substrings from the given string. They are 11, 11, 11, 111, 111, 1111.
// Testcase 2: There 3 substrings from the given string. They are 11, 101, 1101.

// 10010100001001
// 4 10010100001001
// 3 10100001001
// 2 100001001
// 1 1001

// 101101
// 3
// 2
// 1

// 10100101000
// 3
// 2
// 1

{
#include<bits/stdc++.h>
using namespace std;
//Position this line where user code will be pasted.
int main()
{
    int t,n,count;
    string a;
    cin>>t;
    while(t--)
    {
        count = 0;
        cin >> n;
        cin >> a;
        
        cout << binarySubstring(n, a) << endl;
    }
}

}
/*This is a function problem.You only need to complete the function given below*/
/*  Function to count the number of substrings 
*   starting and ending with 1
*   n: size of string
*   a: input string
*/
long binarySubstring(int n, string a){
    
    // Your code here
    int countOf1 = 0;
    for (const auto& ch : a)
    {
        if (ch == '1') ++countOf1;
    }
    return ((countOf1 - 1) * (1 + (countOf1 - 1))) / 2;
}

--------------------------------------------------------------------

// Sort a stack

// Given a stack, the task is to sort it such that the top of the stack has the greatest element.

// Input:
// The first line of input will contains an integer T denoting the no of test cases . Then T test cases follow. Each test case contains an integer N denoting the size of the stack. Then in the next line are N space separated values which are pushed to the the stack. 

// Output:
// For each test case output will be the popped elements from the sorted stack.

// Constraints:
// 1<=T<=100
// 1<=N<=100

// Example(To be used only for expected output):
// Input:
// 2
// 3
// 3 2 1
// 5
// 11 2 32 3 41

// Output:
// 3 2 1
// 41 32 11 3 2

// Explanation:
// For first test case stack will be
// 1
// 2
// 3
// After sorting 
// 3
// 2 
// 1

// When elements  popped : 3 2 1

{
#include<bits/stdc++.h>
using namespace std;
class SortedStack{
public:
  stack<int> s;
  void sort();
};
void printStack(stack<int> s)
{
    while (!s.empty())
    {
        printf("%d ", s.top());
        s.pop();
    }
    printf("
");
}
int main()
{
int t;
cin>>t;
while(t--)
{
  SortedStack *ss = new SortedStack();
  int n;
  cin>>n;
  for(int i=0;i<n;i++)
  {
  int k;
  cin>>k;
  ss->s.push(k);
  }
  ss->sort();
  printStack(ss->s);
}
}
}
/*This is a function problem.You only need to complete the function given below*/
/*The structure of the class is
class SortedStack{
public:
  stack<int> s;
  void sort();
};
*/
/* The below method sorts the stack s 
you are required to complete the below method */
void SortedStack :: sort()
{
   //Your code here
   std::multiset<int> sorted;
   while (!s.empty())
   {
       sorted.insert(s.top());
       s.pop();
   }
   for (const auto& elem : sorted)
   {
       s.push(elem);
   }
}

/*
really logical and nice but inefficient solution from editorial, uses recursive function call stack as
temporary holder + insertion sort idea

The idea of the solution is to hold all values in Function Call Stack until the stack becomes empty.
When the stack becomes empty, insert all held items one by one in sorted order.
Here sorted order is important.

Algorithm
We can use below algorithm to sort stack elements:

sortStack(stack S)
    if stack is not empty:
        temp = pop(S);  
        sortStack(S); 
        sortedInsert(S, temp);
Below algorithm is to insert element is sorted order:

sortedInsert(Stack S, element)
    if stack is empty OR element > top element
        push(S, elem)
    else
        temp = pop(S)
        sortedInsert(S, element)
        push(S, temp)
*/

--------------------------------------------------------------------

// The Celebrity Problem

// You are in a party of N people, where only one person is known to everyone. Such a person may be present in the party, if yes, (s)he doesn’t know anyone in the party. Your task is to find the stranger (celebrity) in party.
// You will be given a square matrix M[][] where if an element of row i and column j  is set to 1 it means ith person knows jth person. You need to complete the function getId() which finds the id of the celebrity if present else return -1. The function getId() takes two arguments, the square matrix M and its size N.

// Note: Expected time complexity is O(N) with constant extra space.

// Input:
// The first line of input contains an element T denoting the number of test cases. Then T test cases follow. Each test case consist of 2 lines. The first line of each test case contains a number denoting the size of the matrix M. Then in the next line are space separated values of the matrix M.

// Output:
// For each test case output will be the id of the celebrity if present (0 based index). Else -1 will be printed.

// User Task:
// The task is to complete the function getId() which returns the Id of celebrity if present, else -1.

// Constraints:
// 1 <= T <= 50
// 2 <= N <= 501
// 0 <= M[][] <= 1

// Example:
// Input (To be used only for expected output) :
// 2
// 3
// 0 1 0 0 0 0 0 1 0
// 2
// 0 1 1 0

// Output :
// 1
// -1

// Explanation :
// For the above test case the matrix will look like
// 0 1 0 
// 0 0 0
// 0 1 0
// Here,  the celebrity is the person with index 1 ie id 1

// From comments: consider both cases .i.e celebrity know himself and not know

{
#include<bits/stdc++.h>
using namespace std;
#define MAX 501
int getId(int M[MAX][MAX],int n);
int main()
{
    int T;
    cin>>T;
    int M[MAX][MAX];
    while(T--)
    {
        int N;
        cin>>N;
        memset(M,0,sizeof M);
        for(int i=0;i<N;i++)
        {
            for(int j=0;j<N;j++)
            {
                cin>>M[i][j];
            }
        }
        cout<<getId(M,N)<<endl;
    }
}

}
/*This is a function problem.You only need to complete the function given below*/
// The task is to complete this function
// M[][]: input matrix
// n: size of matrix (n*n)
int getId(int M[MAX][MAX], int n)
{
    //Your code here
    // wrong
    // for (int col = 0; col < n; ++col)
    // {
    //     bool isCurrentColKnownToAll = true;
    //     for (int row = 0; row < n; ++row)
    //     {
    //         if (M[row][col] == 1 || col == row) continue;
    //         isCurrentColKnownToAll = false;
    //         break;
    //     }
    //     if (isCurrentColKnownToAll)
    //     {
    //         return col;
    //     }
    // }
    // return -1;
    bool isPotentialCelebrityFound = false;
    int potentialCelebrity = 0;
    for (int row = 0; !isPotentialCelebrityFound && row < n; ++row)
    {
        bool areAllZeros = true;
        for (int col = 0; areAllZeros && col < n; ++col)
        {
            if (row == col) continue;
            if (M[row][col] == 1) areAllZeros = false;
        }
        if (areAllZeros)
        {
            isPotentialCelebrityFound = true;
            potentialCelebrity = row;
        }
    }
    if (!isPotentialCelebrityFound) return -1;
    for (int row = 0; row < n; ++row)
    {
        if (row == potentialCelebrity) continue;
        if (M[row][potentialCelebrity] == 0) return -1;
    }
    return potentialCelebrity;
}

// pwede tong divide and conquer, kasi pedeng idivide mo by groups of 2, kunin potential celebrity,
// then recursively do it to the remaining groups

--------------------------------------------------------------------

// Activity Selection

// Given N activities with their start and finish times. Select the maximum number of activities that can be performed by a single person, assuming that a person can only work on a single activity at a time.

// Note : The start time and end time of two activities may coincide.

// Input:
// The first line contains T denoting the number of testcases. Then follows description of testcases. First line is N number of activities then second line contains N numbers which are starting time of activies.Third line contains N finishing time of activities.

// Output:
// For each test case, output a single number denoting maximum activites which can be performed in new line.

// Constraints:
// 1<=T<=50
// 1<=N<=1000
// 1<=A[i]<=100

// Example:
// Input:
// 2
// 6
// 1 3 2 5 8 5
// 2 4 6 7 9 9
// 4
// 1 3 2 5
// 2 4 3 6

// Output:
// 4
// 4

// Input
// 1 10
// 2 5
// 4 6
// 3 7
// 5 8
// 7 9
// 8 11
// problem (| is occupied while / is the last)
  // 1           |
  // 2 |         |
  // 3 |   |     |
  // 4 | | |     |
  // 5 / | | |   |
  // 6   / | |   |
  // 7     / | | |
  // 8       / | | |
  // 9         / | |
  // 0           / |
  // 1             /
// solution
  // 1
  // 2 |
  // 3 |
  // 4 |
  // 5 / |
  // 6   |
  // 7   |
  // 8   / |
  // 9     |
  // 0     |
  // 1     /

#include <algorithm>
#include <iostream>
#include <list>
#include <vector>

struct ActivityTime
{
    int start;
    int end;
};

// Solution 1 - efficient
int main()
{
  //code
  int testCasesCount;
  std::cin >> testCasesCount;
  while (testCasesCount-- > 0)
  {
      int activitiesCount;
      std::cin >> activitiesCount;
      
      std::vector<int> startTimes;
      std::vector<int> finishTimes;
      startTimes.reserve(activitiesCount);
      finishTimes.reserve(activitiesCount);

      for (int ctr = 0; ctr < activitiesCount; ++ctr)
      {
          int temp;
          std::cin >> temp;
          startTimes.push_back(temp);
      }
      for (int ctr = 0; ctr < activitiesCount; ++ctr)
      {
          int temp;
          std::cin >> temp;
          finishTimes.push_back(temp);
      }

      std::list<ActivityTime> activityTimes;
      for (int ctr = 0; ctr < activitiesCount; ++ctr)
      {
          activityTimes.push_back({startTimes[ctr], finishTimes[ctr]});
      }
      activityTimes.sort([](const ActivityTime& lhs, const ActivityTime& rhs)
                          {
                              return lhs.end < rhs.end;
                          });

        std::vector<std::vector<ActivityTime>> possibleActivities;
        for (auto it = activityTimes.begin(); it != activityTimes.end(); ++it)
        {
            // Solution 1 // this is why I used list, because I will do a lot of erasures in container
            // possibleActivities.push_back({*it});
            // for (auto itChecker = std::next(it, 1); itChecker != activityTimes.end(); )
            // {
            //     if (itChecker->end == it->end)
            //     {
            //         possibleActivities.back().push_back(*itChecker);
            //         auto currentIt = itChecker++;
            //         activityTimes.erase(currentIt);
            //     }
            //     else if (itChecker->start < it->end)
            //     {
            //         auto currentIt = itChecker++;
            //         activityTimes.erase(currentIt);
            //     }
            //     else
            //     {
            //         ++itChecker;
            //     }
            // }
            
            // Solution 2
            if (possibleActivities.empty() ||
                it->start >= possibleActivities.back().back().end)
            {
                possibleActivities.push_back({*it});
            }
        }
        std::cout << possibleActivities.size() << "\n";
  }
}

// Solution 2 - inefficient
// void backtrack(
//     std::vector<ActivityTime> activityTimes,
//     std::vector<ActivityTime> possibleActivities,
//     unsigned& maxActivities)
// {
//         // std::cout<<"\nactivityTimes passed";
//         // for (auto a : activityTimes) std::cout << "\n\t" <<a.start<<"-"<<a.end;
//         // std::cout<<"\npossibleActivities passed";
//         // for (auto a : possibleActivities) std::cout << "\n\t" <<a.start<<"-"<<a.end;
//     int ctr = 0;
//     for (auto it = activityTimes.begin(); it != activityTimes.end(); ++it, ++ctr)
//     {
//         if (!possibleActivities.empty() && possibleActivities.back().end > it->start) continue;

//         possibleActivities.push_back(*it);
//         if (possibleActivities.size() > maxActivities) maxActivities = possibleActivities.size();
        
//         auto activityTimesCopy = activityTimes;
//         activityTimesCopy.erase(activityTimesCopy.begin() + ctr);
//         backtrack(activityTimesCopy, possibleActivities, maxActivities);
        
//         possibleActivities.pop_back();
//     }
// }

// int main()
// {
//  //code
//  int testCasesCount;
//  std::cin >> testCasesCount;
//  while (testCasesCount-- > 0)
//  {
//      int activitiesCount;
//      std::cin >> activitiesCount;
      
//      std::vector<int> startTimes;
//      std::vector<int> finishTimes;
//      startTimes.reserve(activitiesCount);
//      finishTimes.reserve(activitiesCount);

//      for (int ctr = 0; ctr < activitiesCount; ++ctr)
//      {
//          int temp;
//          std::cin >> temp;
//          startTimes.push_back(temp);
//      }
//      for (int ctr = 0; ctr < activitiesCount; ++ctr)
//      {
//          int temp;
//          std::cin >> temp;
//          finishTimes.push_back(temp);
//      }

//      std::vector<ActivityTime> activityTimes;
//      for (int ctr = 0; ctr < activitiesCount; ++ctr)
//      {
//          activityTimes.push_back({startTimes[ctr], finishTimes[ctr]});
//      }
//      std::sort(activityTimes.begin(), activityTimes.end(),
//                  [](const ActivityTime& lhs, const ActivityTime& rhs)
//                  {
//                      return lhs.start < rhs.start;
//                  });
//         // std::cout<<"\nactivityTimes sorted";
//         // for (auto a : activityTimes) std::cout << "\n\t" <<a.start<<"-"<<a.end;
//     unsigned maxActivities = 0;
//     backtrack(activityTimes, {}, maxActivities);
//     std::cout << maxActivities << "\n";
//  }
// }

--------------------------------------------------------------------

// Find Missing And Repeating

// Given an unsorted array of size N of positive integers. One number 'A' from set {1, 2, …N} is missing and one number 'B' occurs twice in array. Find these two numbers.

// Note: If you find multiple answers then print the Smallest number found. Also, expected solution is O(n) time and constant extra space.

// Input:
// The first line of input contains an integer T denoting the number of test cases. The description of T test cases follows. The first line of each test case contains a single integer N denoting the size of array. The second line contains N space-separated integers A1, A2, ..., AN denoting the elements of the array.

// Output:
// Print B, the repeating number followed by A which is missing in a single line.

// Constraints:
// 1 ≤ T ≤ 100
// 1 ≤ N ≤ 106
// 1 ≤ A[i] ≤ N

// Example:
// Input:
// 2
// 2
// 2 2
// 3 
// 1 3 3

// Output:
// 2 1
// 3 2

// Explanation:
// Testcase 1: Repeating number is 2 and smallest positive missing number is 1.
// Testcase 2: Repeating number is 3 and smallest positive missing number is 2.

#include <cmath> 
#include <iostream>
#include <vector>

int main()
{
    int testCasesCount;
    std::cin >> testCasesCount;
    while (testCasesCount-- > 0)
    {
        int length;
        std::cin >> length;
        std::vector<int> numbers;
        numbers.resize(length);
        for (int ctr = 0; ctr < length; ++ctr)
            std::cin >> numbers[ctr];

        int smallestRepeatingNumber = length + 1;
        for (const auto& number : numbers)
        {
            int positiveNumber = std::abs(number);
            if (numbers[positiveNumber - 1] > 0)
                numbers[positiveNumber - 1] *= -1;
            else
                if (positiveNumber < smallestRepeatingNumber)
                    smallestRepeatingNumber = positiveNumber;
        }
        int index = 0;
        for (auto numbersIt = numbers.begin(); numbersIt != numbers.end(); ++numbersIt, ++index)
            if (*numbersIt > 0)
            {
                std::cout << smallestRepeatingNumber << " " << index + 1 << "\n";
                break;
            }
    }
    return 0;
}

/*
direct Python translation

#code

for _ in range(int(input())):
    length = int(input())
    numbers = list(map(int, input().split()))

    smallestRepeatingNumber = length + 1
    for number in numbers:
        positiveNumber = abs(number)
        if numbers[positiveNumber - 1] > 0:
            numbers[positiveNumber - 1] *= -1
        else:
            if positiveNumber < smallestRepeatingNumber:
                smallestRepeatingNumber = positiveNumber
    for index, number in enumerate(numbers):
        if number > 0:
            print(smallestRepeatingNumber, index + 1)
            break

# from editorial, I also thought about this but not fully applicable to this problem because
# the problem clearly states that there could be multiple missing and repeating numbers
# 1. Let x be the missing and y be the repeating element.
# 2. Get the sum of all numbers using formula S = n(n+1)/2 – x + y
# 3. Get product of all numbers using formula P = 1*2*3*…*n * y / x
# 4. The above two steps give us two equations, we can solve the equations and get the values of x and y.\
# ex.
#     5 2 3 1 3

#     S = 14
#     P = 90
    
#     14 = n(n+1)/2 - x + y
#     90 = 1*2*3*4*5 * y / x
    
#     get y
#         x = n(n+1)/2 - 14 + y
#         x = 1*2*3*4*5 * y / 90
        
#         n(n+1)/2 - 14 + y = 1*2*3*4*5 * y / 90
#         5(5+1)/2 - 14 + y = 1*2*3*4*5 * y / 90
#         1 + y = 120y / 90
#         90 + 90y = 120y
#         30y = 90
#         y = 3
#     get x
#         x = 1*2*3*4*5 * y / 90
#         x = 120 * 3 / 90
#         x = 4
*/

--------------------------------------------------------------------

// Most frequent word in an array of strings

// Given an array containing N words consisting of lowercase characters. Your task is to find the most frequent word in the array. If multiple words have same frequency, then print the word whose first occurence occurs last in the array as compared to the other strings with same frequency.

// Input:
// The first line of the input contains a single integer T, denoting the number of test cases. Then T test case follows. Each test case contains 2 lines, the size of array N and N words separated by spaces.

// Output:
// For each testcase, output the most frequent word.

// Constraints:
// 1 <= T <= 100
// 1 <= N <= 1000

// Example:
// Input:
// 3
// 3
// geeks for geeks
// 2
// hello world
// 3
// world wide fund

// Output:
// geeks
// world
// fund

// Explanation:
// Testcase 1: "geeks" comes 2 times.
// Testcase 2: "hello" and "world" both have 1 frequency. We print world as it comes last in the input array.

// 1
// 10
// a b c d a b c d e f
// = d

#include <iostream>
#include <map>
#include <unordered_map>
#include <vector>

int main() {
  //code
  
  int testCasesCount;
  std::cin >> testCasesCount;
  while (testCasesCount-- > 0)
  {
     // std::cout << "\nnewtestcase";
      int size;
      std::cin >> size;

      std::vector<std::string> words;
      words.resize(size);
      for (int ctr = 0; ctr < size; ++ctr)
      {
          std::cin >> words[ctr];
      }

        // if (size == 725)
        // {
        //     std::cout << "v\n";
        //     continue;
        // }
        // else if (size == 767)
        // {
        //     std::cout << "y\n";
        //     continue;
        // }

      std::unordered_map<std::string, unsigned> wordsCount;
      unsigned maxCount = 0;
      for (const auto& word : words)
      {
          ++wordsCount[word];
          if (wordsCount[word] > maxCount) maxCount = wordsCount[word];
      }
    //  for (auto reverseIt = words.rbegin(); reverseIt != words.rend(); ++reverseIt)
    //  {
    //      if (wordsCount[*reverseIt] == maxCount)
    //      {
    //          std::cout << *reverseIt << "\n";
    //          break;
    //      }
    //  }
    // for (auto wordCount : wordsCount)std::cout << "\n\t" <<wordCount.first << " = " << wordCount.second  << " " << size;
        std::map<int, std::string> firstIndexOfWordsWithMaxCount;
      for (int ctr = 0; ctr < size; ++ctr)
      {
         // std::cout << "\n\t" << words[ctr] << " = " << wordsCount[words[ctr]];
          if (wordsCount[words[ctr]] == maxCount)
          {
             // std::cout << "\n\t\tupdating maxcount for " << words[ctr];
              wordsCount[words[ctr]] = 0;
              firstIndexOfWordsWithMaxCount.insert({ctr, words[ctr]});
          }
      }
      std::cout << firstIndexOfWordsWithMaxCount.rbegin()->second << "\n";
  }
  return 0;
}

--------------------------------------------------------------------

// Max length chain

// You are given N pairs of numbers. In every pair, the first number is always smaller than the second number. A pair (c, d) can follow another pair (a, b) if b < c. Chain of pairs can be formed in this fashion. Your task is to complete the function maxChainLen which returns an integer denoting the longest chain which can be formed from a given set of pairs. 

// Input:
// The first line of input contains an integer T denoting the no of test cases then T test cases follow .Then T test cases follow . The first line of input contains an integer N denoting the no of pairs . In the next line are 2*N space separated values denoting N pairs.

// Output:
// For each test case output will be the length of the longest chain formed.

// Constraints:
// 1<=T<=100
// 1<=N<=100

// Example(To be used only for expected output):
// Input
// 2
// 5
// 5  24 39 60 15 28 27 40 50 90
// 2
// 5 10 1 11 

// Output
// 3
// 1
// ​
// Explanation
// (i) the given pairs are {{5, 24}, {39, 60}, {15, 28}, {27, 40}, {50, 90} },the longest chain that can be formed is of length 3, and the chain is {{5, 24}, {27, 40}, {50, 90}}
// (ii) The max length chain possible is only of length one.

{
#include <bits/stdc++.h>
using namespace std;
struct val{
    int first;
    int second;
};
int maxChainLen(struct val p[],int n);
int main() {
    // your code goes here
    int t;
    cin>>t;
    while(t--)
    {
        int n;
        cin>>n;
        val p[n];
        for(int i=0;i<n;i++)
        {
            cin>>p[i].first>>p[i].second;
        }
        
        cout<<maxChainLen(p,n)<<endl;
    }
    return 0;
}
}
/*This is a function problem.You only need to complete the function given below*/
/*
The structure to use is as follows
struct val{
    int first;
    int second;
};*/
/*You are required to complete this method*/
#include <algorithm>
#include <deque>
int maxChainLen(struct val p[],int n)
{
//Your code here
    std::sort(p, p + n,
                [](const val lhs, const val rhs)
                {
                    return lhs.first < rhs.first;
                });
    std::deque<val> chain;
    chain.push_back(p[0]);
    for (int ctr = 1; ctr < n; ++ctr)
    {
        if (p[ctr].first > chain.back().second)
        {
            chain.push_back(p[ctr]);
        }
        else if (p[ctr].second < chain.back().second)
        {
            chain.pop_back();
            chain.push_back(p[ctr]);
        }
    }
    return chain.size();
}

--------------------------------------------------------------------

// Rat in a Maze Problem

// Consider a rat placed at (0, 0) in a square matrix m[][] of order n and has to reach the destination at (n-1, n-1). Your task is to complete the function printPath() which returns a sorted array of strings denoting all the possible directions which the rat can take to reach the destination at (n-1, n-1). The directions in which the rat can move are 'U'(up), 'D'(down), 'L' (left), 'R' (right).

// Input:
// The first line of input contains an integer T denoting the no of test cases. Then T test cases follow. Each test case contains two lines. The first line contains an integer n denoting the size of the square matrix. The next line contains n*n space separated values of the matrix m where 0's represents blocked paths and 1 represent valid paths.

// Output:
// For each test case output will be space separated sorted strings denoting all directions, which the rat could take to reach the destination.

// User Task:
// Since this is functional problem you don't have to worry about input, you just have to complete the function printPath()

// Constraints:
// 1 <= T <= 10
// 2 <= n <= 10
// 0 <= m[][] <= 1

// Example
// Input:
// 2
// 4
// 1 0 0 0 1 1 0 1 0 1 0 0 0 1 1 1
// 4
// 1 0 0 0 1 1 0 1 1 1 0 0 0 1 1 1

// Output:
// DRDDRR
// DDRDRR DRDDRR

// Explanation:
// Testcase 2: The given input is in the form
// 1 0 0 0
// 1 1 0 1
// 1 1 0 0
// 0 1 1 1
// For the above matrix the rat can reach the destination at (3, 3) from (0, 0) by two paths ie DRDDRR and DDRDRR when printed in sorted order we get DDRDRR DRDDRR.

{
#include <bits/stdc++.h>
using namespace std;
#define MAX 100
vector<string> printPath(int m[MAX][MAX], int n);
int main() {
  // your code goes here
  int t;
  cin>>t;
  while(t--){
  int n;
  cin>>n;
  
  int m[100][100];
  for(int i=0;i<n;i++)
  {
    for(int j=0;j<n;j++)
    {
      cin>>m[i][j];
    }
  }
  
  vector<string> res = printPath(m,n);
  for(int i=0;i<res.size();i++)
  cout<<res[i]<<" ";
  cout<<endl;
}
  return 0;
}

}
/*This is a function problem.You only need to complete the function given below*/
/*The function returns a sorted array of strings which represents
the directions mouse will take to reach the destination.
You are required to complete the below method. */
struct Coordinate
{
    int row;
    int col;
    
    bool operator==(const Coordinate& other) const
    {
        return row == other.row && col == other.col;
    }
    
    bool operator<(const Coordinate& other) const
    {
        return row < other.row;
    }

    struct Hasher
    {
        size_t operator()(const Coordinate& coordinate) const
        {
            return std::hash<int>()(coordinate.row) ^
                    std::hash<int>()(coordinate.col);
        }
    };
};

struct CoordinatePath
{
    std::unordered_set<Coordinate, Coordinate::Hasher> path;
    // std::set<Coordinate> path;
    std::string direction;
};

static const std::vector<char> DIRECTIONS{'U', 'D', 'L', 'R'}; // or make this in order of DLRU so that no need of the sorting of the final results in "set"

void getPossiblePaths(
    int m[MAX][MAX],
    int n,
    const Coordinate& currentCoordinate,
    CoordinatePath coordinatePath,
    std::set<std::string>& possiblePaths)
{
    // std::cout << "\n\tcurrentCoordinate " << currentCoordinate.row << " " << currentCoordinate.col << " " << coordinatePath.direction;
    // for (auto a : coordinatePath.path)
    // {
    //     std::cout <<"\n\t"<<a.row << " " << a.col;
    // }

    for (const auto& dir : DIRECTIONS)
    {
        auto nextCoordinate = currentCoordinate;
        switch (dir)
        {
            case 'U': --nextCoordinate.row; break;
            case 'D': ++nextCoordinate.row; break;
            case 'L': --nextCoordinate.col; break;
            case 'R': ++nextCoordinate.col; break;
        }

        if (nextCoordinate.row < 0 || nextCoordinate.row >= n ||
            nextCoordinate.col < 0 || nextCoordinate.col >= n ||
            m[nextCoordinate.row][nextCoordinate.col] == 0 ||
            coordinatePath.path.count(nextCoordinate) > 0)
        {
            // std::cout << "\n\t\tskipping nextCoordinate" << nextCoordinate.row << " " << nextCoordinate.col;
            continue;
        }
        else if (nextCoordinate.row == n - 1 && nextCoordinate.col == n - 1)
        {
            std::string currentPath = coordinatePath.direction;
            currentPath.push_back(dir);
            // std::cout << "\n\t\tFOUND!!! nextCoordinate" << nextCoordinate.row << " " << nextCoordinate.col << " " << currentPath;
            possiblePaths.insert(currentPath);
            return;
        }

        coordinatePath.path.insert(nextCoordinate);
        coordinatePath.direction.push_back(dir);
        // std::cout << "\n\t\tprocessing nextCoordinate" << nextCoordinate.row << " " << nextCoordinate.col << " " << coordinatePath.direction;
        getPossiblePaths(m, n, nextCoordinate, coordinatePath, possiblePaths);
        coordinatePath.path.erase(nextCoordinate);
        coordinatePath.direction.pop_back();
    }
}

std::vector<std::string> printPath(int m[MAX][MAX], int n)
{
    //Your code here
    std::set<std::string> possiblePaths;
    Coordinate firstCoordinate{0, 0};
    getPossiblePaths(m, n, firstCoordinate, CoordinatePath{{firstCoordinate}, ""}, possiblePaths);
    return {possiblePaths.begin(), possiblePaths.end()};
    // for (const auto& path : possiblePaths)
    // {
    //     std::cout << path << "\n";
    // }
}

--------------------------------------------------------------------

// Maximum Index

// Given an array A[] of N positive integers. The task is to find the maximum of j - i subjected to the constraint of A[i] <= A[j].

// Input:
// The first line contains an integer T, depicting total number of test cases.  Then T test case follows. First line of each test case contains an integer N denoting the size of the array. Next line contains N space separated integeres denoting the elements of the array.

// Output:
// Print the maximum difference of the indexes i and j in a separtate line.

// Constraints:
// 1 ≤ T ≤ 1000
// 1 ≤ N ≤ 107
// 0 ≤ A[i] ≤ 1018

// Example:
// Input:
// 1
// 9
// 34 8 10 3 2 80 30 33 1

// Output:
// 6

// Explanation:
// Testcase 1:  In the given array A[1] < A[7] satisfying the required condition(A[i] <= A[j]) thus giving the maximum difference of j - i which is 6(7-1).


// Solution 1, ndi to nagok
// #include <algorithm>
// #include <iostream>
// #include <map>
// #include <vector>

// int main()
// {
//   int testCasesCount;
//   std::cin >> testCasesCount;
//   while (testCasesCount-- > 0)
//   {
//       int size;
//       std::cin >> size;

//       std::vector<int> inputs;
//       inputs.resize(size);
//       for (int ctr = 0; ctr < size; ++ctr)
//           std::cin >> inputs[ctr];

//      std::multimap<int, int> sortedInputsWithIndexes;
//      for (int ctr = 0; ctr < size; ++ctr)
//           sortedInputsWithIndexes.insert({inputs[ctr], ctr});

//      int smallestIndex = sortedInputsWithIndexes.begin()->second;
//      int largestDifference = (size - 1) * -1;

//      for (auto it = sortedInputsWithIndexes.begin(); it != sortedInputsWithIndexes.end(); ++it)
//      {
//          if (it == sortedInputsWithIndexes.begin()) continue;
//          largestDifference = std::max(largestDifference, it->second - smallestIndex);
//          smallestIndex = std::min(smallestIndex, it->second);
//      }

//      std::cout << largestDifference << "\n";
//   }
//   return 0;
// }


// Solution 2, brute force lang pero nagok
#include <algorithm>
#include <iostream>
#include <limits>
#include <vector>

int main()
{
  int testCasesCount;
  std::cin >> testCasesCount;
  while (testCasesCount-- > 0)
  {
      int size;
      std::cin >> size;
      
      std::vector<int> inputs;
      inputs.resize(size);
      for (int ctr = 0; ctr < size; ++ctr)
          std::cin >> inputs[ctr];

     int largestDifference = size == 1 ? 0 : std::numeric_limits<int>::min();
     for (int ctr = 0; ctr < size; ++ctr)
         for (int ctr2 = size - 1; ctr2 > ctr; --ctr2)
             if (inputs[ctr2] >= inputs[ctr])
             {
                 largestDifference = std::max(largestDifference, ctr2 - ctr);
                 break;
             }

     std::cout << largestDifference << "\n";
  }
  return 0;
}

// In Python, same as Solution 1, ndi nagok kasi memory error sa "sorted" kahit paghiwahiwalayin ng statement ung zip and sorted
// from itertools import count

// for _ in range(int(input())):
//     size = int(input())

//     inputs = map(int, input().split())
//     sortedInputsWithIndexes = sorted(zip(inputs, count(0))) # or # sorted(zip(inputs, count(0)), key = lambda x : x[0])

//     smallestIndex = sortedInputsWithIndexes[0][1]
//     largestDifference = (size - 1) * -1

//     for _, currentIndex in sortedInputsWithIndexes[1:]:
//         largestDifference = max(largestDifference, currentIndex - smallestIndex)
//         smallestIndex = min(smallestIndex, currentIndex)

//     print(largestDifference)

--------------------------------------------------------------------

// Relative Sorting

// Given two arrays A1[] and A2[] of size N and M respectively. The task is to sort A1 in such a way that the relative order among the elements will be same as those in A2. For the elements not present in A2, append them at last in sorted order. It is also given that the number of elements in A2[] are smaller than or equal to number of elements in A1[] and A2[] has all distinct elements.

// Note: Expected time complexity is O(N log(N)).

// Input:
// First line of input contains number of testcases. For each testcase, first line of input contains length of arrays N and M and next two line contains N and M elements respectively.

// Output:
// Print the relatively sorted array.

// Constraints:
// 1 ≤ T ≤ 100
// 1 ≤ N,M  ≤ 106
// 1 ≤ A1[], A2[] <= 106

// Example:
// Input:
// 1
// 11 4
// 2 1 2 5 7 1 9 3 6 8 8
// 2 1 8 3

// Output:
// 2 2 1 1 8 8 3 5 6 7 9

// Explanation:
// Testcase 1: Array elements of A1[] are sorted according to A1[].

#include <algorithm>
#include <iostream>
#include <map>
#include <unordered_map>
#include <vector>

// Solution 1
// int main()
// {
//  //code
//  int testCasesCount;
//  std::cin >> testCasesCount;
//  while (testCasesCount-- > 0)
//  {
//      int array1Size;
//      int array2Size;
//      std::cin >> array1Size >> array2Size;

//      std::vector<int> array1;
//      std::vector<int> array2;
//      array1.resize(array1Size);
//      array2.resize(array2Size);
//      for (int ctr = 0; ctr < array1Size; ++ctr)
//      {
//          std::cin >> array1[ctr];
//      }
//      for (int ctr = 0; ctr < array2Size; ++ctr)
//      {
//          std::cin >> array2[ctr];
//      }
      
//      std::map<int, int> numberAndCountMap;
//      for (const auto& number : array1)
//      {
//          ++numberAndCountMap[number];
//      }
//      for (const auto& number : array2)
//      {
//          if (numberAndCountMap.count(number) == 0) continue;
//          while (numberAndCountMap[number]-- > 0) std::cout << number << " ";
//      }
//      for (auto& pair : numberAndCountMap)
//      {
//          while (pair.second-- > 0) std::cout << pair.first << " ";
//      }
//      std::cout << "\n";
//  }
//  return 0;
// }

// Solution 2
// int main()
// {
//  //code
//  int testCasesCount;
//  std::cin >> testCasesCount;
//  while (testCasesCount-- > 0)
//  {
//      int array1Size;
//      int array2Size;
//      std::cin >> array1Size >> array2Size;

//      std::vector<int> array1;
//      std::vector<int> array2;
//      array1.resize(array1Size);
//      array2.resize(array2Size);
//      for (int ctr = 0; ctr < array1Size; ++ctr)
//      {
//          std::cin >> array1[ctr];
//      }
//      for (int ctr = 0; ctr < array2Size; ++ctr)
//      {
//          std::cin >> array2[ctr];
//      }

//      std::unordered_map<int, int> array2AndIndexMap;
//      for (int ctr = 0; ctr < array2Size; ++ctr)
//      {
//          array2AndIndexMap.insert({array2[ctr], ctr});
//      }
//      std::sort(array1.begin(), array1.end(),
//                  [&array2AndIndexMap](const int lhs, const int rhs)
//                  {
//                      if (array2AndIndexMap.count(lhs) > 0)
//                      {
//                          if (array2AndIndexMap.count(rhs) > 0)
//                          {
//                              return array2AndIndexMap[lhs] < array2AndIndexMap[rhs];
//                          }
//                          else
//                          {
//                              return true;
//                          }
//                      }
//                      else if (array2AndIndexMap.count(rhs) > 0)
//                      {
//                          return false;
//                      }
//                      return lhs < rhs;
//                  });
//      for (const auto& number : array1)
//      {
//          std::cout << number << " ";
//      }
//      std::cout << "\n";
//  }
//  return 0;
// }

// Solution 3
int main()
{
  //code
  int testCasesCount;
  std::cin >> testCasesCount;
  while (testCasesCount-- > 0)
  {
      int array1Size;
      int array2Size;
      std::cin >> array1Size >> array2Size;

      std::vector<int> array1;
      std::vector<int> array2;
      array1.resize(array1Size);
      array2.resize(array2Size);
      for (int ctr = 0; ctr < array1Size; ++ctr)
      {
          std::cin >> array1[ctr];
      }
      for (int ctr = 0; ctr < array2Size; ++ctr)
      {
          std::cin >> array2[ctr];
      }

      std::unordered_map<int, int> array2AndIndexMap;
      for (int ctr = 0; ctr < array2Size; ++ctr)
      {
          array2AndIndexMap.insert({array2[ctr], ctr});
      }
      auto divisionIt = std::partition(array1.begin(), array1.end(),
                                      [&array2AndIndexMap](const int number)
                                      {
                                          return array2AndIndexMap.count(number);
                                      });
      std::sort(array1.begin(), divisionIt,
                  [&array2AndIndexMap](const int lhs, const int rhs)
                  {
                      return array2AndIndexMap[lhs] < array2AndIndexMap[rhs];
                  });
      std::sort(divisionIt, array1.end());
      for (const auto& number : array1)
      {
          std::cout << number << " ";
      }
      std::cout << "\n";
  }
  return 0;
}

--------------------------------------------------------------------

Max Array Sum

Given an array of integers, find the subset of non-adjacent elements with the maximum sum. Calculate the sum of that subset.

For example, given an array arr=[-2,1,3,-4,5] we have the following possible subsets:
Subset      Sum
[-2, 3, 5]   6
[-2, 3]      1
[-2, -4]    -6
[-2, 5]      3
[1, -4]     -3
[1, 5]       6
[3, 5]       8

Our maximum subset sum is 8.

#include <bits/stdc++.h>

using namespace std;

vector<string> split_string(string);

// Complete the maxSubsetSum function below.

// Solution 1, incorrect due to separation of odd and even, could not handle case 4 1 2 4 which should be 4 + 4 = 8
// int getMaximumSumOfNonAdjacent(
//     const std::vector<int>& arr,
//     int startingIndex)
// {    
//     int maxSum = arr[startingIndex];
//     int previousSum = arr[startingIndex];

//     for (unsigned ctr = startingIndex + 2; ctr < arr.size(); ctr += 2)
//     {
//         int currentSum = previousSum + arr[ctr];
//         if (previousSum < 0)
//         {
//             previousSum = arr[ctr] < 0 ?
//                             std::max(previousSum, arr[ctr]) :
//                             arr[ctr];
//         }
//         else if (currentSum > previousSum)
//         {
//             previousSum = currentSum;
//         }

//         if (previousSum > maxSum) maxSum = previousSum;
//     }
//     return maxSum;
// }

// int maxSubsetSum(const std::vector<int>& arr)
// {
//     if (arr.empty()) return 0;

//     int evenStartPoint = 0;
//     int oddStartPoint = 1;

//     return std::max(
//             getMaximumSumOfNonAdjacent(arr, evenStartPoint),
//             getMaximumSumOfNonAdjacent(arr, oddStartPoint));
// }

int maxSubsetSum(const std::vector<int>& arr)
{
    std::vector<int> maxSumPerIndex;
    maxSumPerIndex.resize(arr.size());

    for (int index = arr.size() - 1; index >= 0; --index)
    {
        maxSumPerIndex[index] = arr[index];

        if (index + 2 >= arr.size()) continue;

        int extraSum = index + 3 < arr.size() ?
                        std::max(maxSumPerIndex[index + 2], maxSumPerIndex[index + 3]) :
                        maxSumPerIndex[index + 2];
        int newSum = arr[index] + extraSum;

        if (arr[index] < 0)
        {
            maxSumPerIndex[index] = extraSum < 0 ?
                                    std::max(arr[index], extraSum) :
                                    extraSum;
        }
        else if (newSum > arr[index])
        {
            maxSumPerIndex[index] = newSum;
        }
    }

    return maxSumPerIndex.size() > 1 ?
            std::max(maxSumPerIndex[0], maxSumPerIndex[1]) :
            maxSumPerIndex[0];
}

int main()
{
    ofstream fout(getenv("OUTPUT_PATH"));

    int n;
    cin >> n;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    string arr_temp_temp;
    getline(cin, arr_temp_temp);

    vector<string> arr_temp = split_string(arr_temp_temp);

    vector<int> arr(n);

    for (int i = 0; i < n; i++) {
        int arr_item = stoi(arr_temp[i]);

        arr[i] = arr_item;
    }

    int res = maxSubsetSum(arr);

    fout << res << "\n";

    fout.close();

    return 0;
}

vector<string> split_string(string input_string) {
    string::iterator new_end = unique(input_string.begin(), input_string.end(), [] (const char &x, const char &y) {
        return x == y and x == ' ';
    });

    input_string.erase(new_end, input_string.end());

    while (input_string[input_string.length() - 1] == ' ') {
        input_string.pop_back();
    }

    vector<string> splits;
    char delimiter = ' ';

    size_t i = 0;
    size_t pos = input_string.find(delimiter);

    while (pos != string::npos) {
        splits.push_back(input_string.substr(i, pos - i));

        i = pos + 1;
        pos = input_string.find(delimiter, i);
    }

    splits.push_back(input_string.substr(i, min(pos, input_string.length()) - i + 1));

    return splits;
}

--------------------------------------------------------------------

// Hash Tables: Ice Cream Parlor

// Each time Sunny and Johnny take a trip to the Ice Cream Parlor, they pool their money to buy ice cream. On any given day, the parlor offers a line of flavors. Each flavor has a cost associated with it.

// Given the value of money and the cost of each flavor for t trips to the Ice Cream Parlor, help Sunny and Johnny choose two distinct flavors such that they spend their entire pool of money during each visit. ID numbers are the 1- based index number associated with a cost. For each trip to the parlor, print the ID numbers for the two types of ice cream that Sunny and Johnny purchase as two space-separated integers on a new line. You must print the smaller ID first and the larger ID second.

// For example, there are n=5 flavors having cost=[2,1,3,5,6]. Together they have money=5 to spend. They would purchase flavor ID's 1 and 3 for a cost of 2+3=5. Use 1 based indexing for your response.

#include <bits/stdc++.h>

using namespace std;

vector<string> split_string(string);

// Complete the whatFlavors function below.
void whatFlavors(vector<int> costs, int money)
{
    std::unordered_map<int, int> flavorCostAndIdMap;
    for (unsigned index = 0; index < costs.size(); ++index)
    {
        if (flavorCostAndIdMap.count(money - costs[index]) == 0)
        {
            flavorCostAndIdMap.insert({costs[index], index + 1});
        }
        else
        {
            std::cout << flavorCostAndIdMap[money - costs[index]]
                        << " " << index + 1 << "\n";
            return;
        }
    }
}

int main()
{
    int t;
    cin >> t;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    for (int t_itr = 0; t_itr < t; t_itr++) {
        int money;
        cin >> money;
        cin.ignore(numeric_limits<streamsize>::max(), '\n');

        int n;
        cin >> n;
        cin.ignore(numeric_limits<streamsize>::max(), '\n');

        string cost_temp_temp;
        getline(cin, cost_temp_temp);

        vector<string> cost_temp = split_string(cost_temp_temp);

        vector<int> cost(n);

        for (int i = 0; i < n; i++) {
            int cost_item = stoi(cost_temp[i]);

            cost[i] = cost_item;
        }

        whatFlavors(cost, money);
    }

    return 0;
}

vector<string> split_string(string input_string) {
    string::iterator new_end = unique(input_string.begin(), input_string.end(), [] (const char &x, const char &y) {
        return x == y and x == ' ';
    });

    input_string.erase(new_end, input_string.end());

    while (input_string[input_string.length() - 1] == ' ') {
        input_string.pop_back();
    }

    vector<string> splits;
    char delimiter = ' ';

    size_t i = 0;
    size_t pos = input_string.find(delimiter);

    while (pos != string::npos) {
        splits.push_back(input_string.substr(i, pos - i));

        i = pos + 1;
        pos = input_string.find(delimiter, i);
    }

    splits.push_back(input_string.substr(i, min(pos, input_string.length()) - i + 1));

    return splits;
}

--------------------------------------------------------------------

// Greedy Florist

// A group of friends want to buy a bouquet of flowers. The florist wants to maximize his number of new customers and the money he makes. To do this, he decides he'll multiply the price of each flower by the number of that customer's previously purchased flowers plus 1. The first flower will be original price, (0 + 1) * original price, the next will be (1 + 1) * original price and so on.

// Given the size of the group of friends, the number of flowers they want to purchase and the original prices of the flowers, determine the minimum cost to purchase all of the flowers.

// For example, if there are k=3 friends that want to buy n=4 flowers that cost c=[1,2,3,4] each will buy one of the flowers priced [2,3,4] at the original price. Having each purchased x=1 flower, the first flower in the list, c[0], will now cost (current purchase + previous purchases) * c[0] = (1 + 1) * 1 = 2. The total cost will be (2 + 3 + 4) + (2) = 11.

// Sample Input 0
// 3 3
// 2 5 6
// Sample Output 0
// 13
// Explanation 0
// There are n=3 flowers with costs [c=[2,5,6] and k=3 people in the group. If each person buys one flower, the total cost of prices paid is 2+5+6=13 dollars. Thus, we print 13 as our answer.

// Sample Input 1
// 3 2
// 2 5 6
// Sample Output 1
// 15
// Explanation 1
// There are n=3 flowers with costs c=[2,5,6] and k=2 people in the group. We can minimize the total purchase cost like so:
// 1. The first person purchases 2 flowers in order of decreasing price; this means they buy the more expensive flower (c1=5) first at price p1=(0+1)*5=5 dollars and the less expensive flower (c0=2) second at price p0=(1+1)*2=4 dollars.
// 2. The second person buys the most expensive flower at price p2=(0+1)*6=6 dollars.
// We then print the sum of these purchases, which is 5+4+6=15, as our answer.

// Sample Input 2
// 5 3
// 1 3 5 7 9
// Sample Output 2
// 29

#include <bits/stdc++.h>

using namespace std;

vector<string> split_string(string);

// Complete the getMinimumCost function below.
int getMinimumCost(int k, std::vector<int> c)
{
    // Solution 1 // efficient
    // std::sort(c.begin(), c.end(), std::greater<int>());

    // int minimumCost = 0;
    // int multiplier = 0;

    // for (unsigned index = 0u; index < c.size(); ++index)
    // {
    //     if (index % k == 0) ++multiplier;
    //     minimumCost += (c[index] * multiplier);
    // }
    // return minimumCost;

    // Solution 2 // less efficient using max-heap due to the extra reordering of heap
    std::priority_queue<int> costsHeap(c.begin(), c.end());

    int minimumCost = 0;
    int multiplier = 0;

    for (unsigned ctr = 0; !costsHeap.empty(); ++ctr)
    {
        if (ctr % k == 0) ++multiplier;
        minimumCost += (costsHeap.top() * multiplier);
        costsHeap.pop();
    }
    return minimumCost;
}

int main()
{
    ofstream fout(getenv("OUTPUT_PATH"));

    string nk_temp;
    getline(cin, nk_temp);

    vector<string> nk = split_string(nk_temp);

    int n = stoi(nk[0]);

    int k = stoi(nk[1]);

    string c_temp_temp;
    getline(cin, c_temp_temp);

    vector<string> c_temp = split_string(c_temp_temp);

    vector<int> c(n);

    for (int i = 0; i < n; i++) {
        int c_item = stoi(c_temp[i]);

        c[i] = c_item;
    }

    int minimumCost = getMinimumCost(k, c);

    fout << minimumCost << "\n";

    fout.close();

    return 0;
}

vector<string> split_string(string input_string) {
    string::iterator new_end = unique(input_string.begin(), input_string.end(), [] (const char &x, const char &y) {
        return x == y and x == ' ';
    });

    input_string.erase(new_end, input_string.end());

    while (input_string[input_string.length() - 1] == ' ') {
        input_string.pop_back();
    }

    vector<string> splits;
    char delimiter = ' ';

    size_t i = 0;
    size_t pos = input_string.find(delimiter);

    while (pos != string::npos) {
        splits.push_back(input_string.substr(i, pos - i));

        i = pos + 1;
        pos = input_string.find(delimiter, i);
    }

    splits.push_back(input_string.substr(i, min(pos, input_string.length()) - i + 1));

    return splits;
}

--------------------------------------------------------------------

// Tree: Height of a Binary Tree

// The height of a binary tree is the number of edges between the tree's root and its furthest leaf.

#include <bits/stdc++.h>

using namespace std;

class Node {
    public:
        int data;
        Node *left;
        Node *right;
        Node(int d) {
            data = d;
            left = NULL;
            right = NULL;
        }
};

class Solution {
    public:
      Node* insert(Node* root, int data) {
            if(root == NULL) {
                return new Node(data);
            } else {
                Node* cur;
                if(data <= root->data) {
                    cur = insert(root->left, data);
                    root->left = cur;
                } else {
                    cur = insert(root->right, data);
                    root->right = cur;
               }

               return root;
           }
        }
/*The tree node has data, left child and right child 
class Node {
    int data;
    Node* left;
    Node* right;
};

*/
    int height(Node* root)
    {
        // Write your code here.

        // Solution 1
        // if (root == nullptr) return -1;
        // return 1 + std::max(height(root->left), height(root->right));

        // Solution 2 - BFS
        // using Height = int;
        // std::queue<std::pair<Node*, Height>> nodeAndHeightQueue;
        // nodeAndHeightQueue.push({root, 0});
        // while (true)
        // {
        //     auto currentNodeAndHeight = nodeAndHeightQueue.front();
        //     nodeAndHeightQueue.pop();
        //     if (currentNodeAndHeight.first->left != nullptr)
        //     {
        //         nodeAndHeightQueue.push({
        //                                     currentNodeAndHeight.first->left,
        //                                     currentNodeAndHeight.second + 1
        //                                 });
        //     }
        //     if (currentNodeAndHeight.first->right != nullptr)
        //     {
        //         nodeAndHeightQueue.push({
        //                                     currentNodeAndHeight.first->right,
        //                                     currentNodeAndHeight.second + 1
        //                                 });
        //     }

        //     if (nodeAndHeightQueue.empty()) return currentNodeAndHeight.second;
        // }

        // Solution 3 - DFS
        int maxHeight = 0;

        using Height = int;
        std::stack<std::pair<Node*, Height>> nodeAndHeightStack;
        nodeAndHeightStack.push({root, 0});
        while (!nodeAndHeightStack.empty())
        {
            auto currentNodeAndHeight = nodeAndHeightStack.top();
            nodeAndHeightStack.pop();
            if (currentNodeAndHeight.first->left)
            {
                nodeAndHeightStack.push({
                                            currentNodeAndHeight.first->left,
                                            currentNodeAndHeight.second + 1
                                        });
            }
            if (currentNodeAndHeight.first->right)
            {
                nodeAndHeightStack.push({
                                            currentNodeAndHeight.first->right,
                                            currentNodeAndHeight.second + 1
                                        });
            }
            maxHeight = std::max(maxHeight, currentNodeAndHeight.second);
        }
        return maxHeight;
    }

}; //End of Solution

--------------------------------------------------------------------

// Min Max Riddle

// Given an integer array of size n, find the maximum of the minimum(s) of every window size in the array.
// The window size varies from 1 to n.

// For example, given arr=[6,3,5,1,12], consider window sizes of 1 through 5. Windows of size 1 are
// (6) (3) (5) (1) (12). The maximum value of the minimum values of these windows is 12. Windows of siz
// 2 are (6,3),(3,5),(5,1),(1,12) and their minima are (3,3,1,1). The maximum of these values is 3.
// Continue this process through window size 5 to finally consider the entire array. All of the answers
// are 12,3,3,1,1.

// Sample Input 0
// 4
// 2 6 1 12
// Sample Output 0
// 12 2 1 1

// Sample Input 1
// 7
// 1 2 3 5 1 13 3
// Sample Output 1
// 13 3 2 1 1 1 1

// Sample Input 2
// 6
// 3 5 4 7 6 2
// Sample Output 2
// 7 6 4 4 3 2
// Explanation 2
// Here n=6 and arr=[3,5,4,7,6,2]
// win size  w_1 w_2 w_3 w_4 w_5 w_6 maximum of all windows
// 1         3   5   4   7   6   2   7
// 2         3   4   4   6   2       6
// 3         3   4   4   2           4
// 4         3   4   2               4
// 5         3   2                   3
// 6         2                       2

// Analysis ko (first solution ko) (using dynamic programming)
// 9
// 3
// 2
// 1
// 1
// 1
// 1
//  1 2 3 4 1 9 3
//   1 2 3 1 1 3
//    1 2 1 1 1
//     1 1 1 1
//      1 1 1
//       1 1
//        1

// 7
// 6
// 4
// 4
// 3
// 2
// 3 5 4 7 6 2
//  3 4 4 6 2
//   3 4 4 2
//    3 4 2
//     3 2
//      2

// Analysis ko (inspired by comment that uses stack)
// 15 6 15 7 4 1 5 2 15 15 6  16
// 0  1 2  3 4 5 6 7 8  9  10 11

// a  i v
// 15 0 1-
// 6  1 4-
// 15 2 1-
// 7  3 2-
// 4  4 5-
// 1  5 6
// 5  6 1-
// 2  7 2
// 15 8 2-
// 15 9 1-
// 6  0 3
// 16 1 1

// a  i v
// 15 0 1-
// 6  1 4-
// 15 2 1-
// 7  3 2-
// 4  4 5-
// 1  5 12-
// 5  6 1-
// 2  7 6-
// 15 8 2-
// 15 9 1-
// 6  0 4-
// 16 1 1-

// a  i v
// 5  6 1-
// 15 9 1-
// 15 0 1-
// 15 2 1-
// 16 1 1-
// 7  3 2-
// 15 8 2-
// 6  1 4-
// 6  0 4-
// 4  4 5-
// 2  7 6-
// 1  5 12-

#include <bits/stdc++.h>

using namespace std;

vector<string> split_string(string);

// Complete the riddle function below.
// Solution 1
// std::vector<long> riddle(std::vector<long> arr)
// {
//     // complete this function
//     std::vector<long> result;
//     result.reserve(arr.size());
//     for (int ctr = 0; ctr < arr.size(); ++ctr)
//     {
//         long maximum = std::numeric_limits<long>::min();

//         for (int mergeCtr = 0; mergeCtr < arr.size() - ctr; ++mergeCtr)
//         {
//             arr[mergeCtr] = (ctr == 0) ?
//                             arr[mergeCtr] :
//                             std::min(arr[mergeCtr], arr[mergeCtr + 1]);
//             maximum = std::max(maximum, arr[mergeCtr]);
//         }
//         result.push_back(maximum);
//     }
//     return result;
// }

// Solution 2
// std::vector<long> riddle(std::vector<long> arr)
// {
//     // complete this function
//     std::vector<long> result;
//     result.reserve(arr.size());

//     auto maximumArrayElement = *std::max_element(arr.begin(), arr.end());
//     result.push_back(maximumArrayElement);
//     for (int ctr = 1; ctr < arr.size(); ++ctr)
//     {
//         long maximum = std::numeric_limits<long>::min();

//         for (int mergeCtr = 0; mergeCtr < arr.size() - ctr; ++mergeCtr)
//         {
//             arr[mergeCtr] = std::min(arr[mergeCtr], arr[mergeCtr + 1]);
//             maximum = std::max(maximum, arr[mergeCtr]);
//         }
//         result.push_back(maximum);
//     }
//     return result;
// }



// Solution 3
std::vector<long> riddle(std::vector<long> arr)
{
    // complete this function
    if (arr.empty()) return {};

    std::map<long, long, std::greater<long>> numberAndMaxLeastWindowMap;
    std::stack<std::pair<long, long>> numberAndLeastWindowStack;
    numberAndMaxLeastWindowMap.insert({arr[0], 1});
    numberAndLeastWindowStack.push({arr[0], 1});

    arr.push_back(-1);
    for (unsigned index = 1; index < arr.size(); ++index)
    {
        long previousLeastWindow = 0;
        while (!numberAndLeastWindowStack.empty() &&
                arr[index] <= numberAndLeastWindowStack.top().first)
        {
            auto currentTop = numberAndLeastWindowStack.top();
            numberAndLeastWindowStack.pop();

            numberAndMaxLeastWindowMap[currentTop.first] =
                std::max(numberAndMaxLeastWindowMap[currentTop.first],
                        currentTop.second + previousLeastWindow);
            
            previousLeastWindow += currentTop.second;
        }
        numberAndLeastWindowStack.push({arr[index], previousLeastWindow + 1});
    }

    std::vector<long> result;
    result.reserve(arr.size() - 1);
    auto it = numberAndMaxLeastWindowMap.begin();
    for (int ctr = 1; ctr < arr.size(); ++ctr)
    {
        while (it->second < ctr) ++it;
        result.push_back(it->first);
    }
    return result;
}

int main()
{
    ofstream fout(getenv("OUTPUT_PATH"));

    int n;
    cin >> n;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    string arr_temp_temp;
    getline(cin, arr_temp_temp);

    vector<string> arr_temp = split_string(arr_temp_temp);

    vector<long> arr(n);

    for (int i = 0; i < n; i++) {
        long arr_item = stol(arr_temp[i]);

        arr[i] = arr_item;
    }

    vector<long> res = riddle(arr);

    for (int i = 0; i < res.size(); i++) {
        fout << res[i];

        if (i != res.size() - 1) {
            fout << " ";
        }
    }

    fout << "\n";

    fout.close();

    return 0;
}

vector<string> split_string(string input_string) {
    string::iterator new_end = unique(input_string.begin(), input_string.end(), [] (const char &x, const char &y) {
        return x == y and x == ' ';
    });

    input_string.erase(new_end, input_string.end());

    while (input_string[input_string.length() - 1] == ' ') {
        input_string.pop_back();
    }

    vector<string> splits;
    char delimiter = ' ';

    size_t i = 0;
    size_t pos = input_string.find(delimiter);

    while (pos != string::npos) {
        splits.push_back(input_string.substr(i, pos - i));

        i = pos + 1;
        pos = input_string.find(delimiter, i);
    }

    splits.push_back(input_string.substr(i, min(pos, input_string.length()) - i + 1));

    return splits;
}

// Debugger program to reduce the number input
// #include <bits/stdc++.h>
// int main()
// {
//     int factor = 1;
//     std::vector<long> a{789168277,694294362,532144299,20472621,316665904,59654039,685958445,
//         925819184,371690486,285650353,522515445,624800694,396417773,467681822,964079876,355847868,
//         424895284,50621903,728094833,535436067,221600465,832169804,641711594,518285605,235027997,
//         904664230,223080251,337085579,5125280,448775176,831453463,550142629,822686012,555190916,
//         911857735,144603739,751265137,274554418,450666269,984349810,716998518,949717950,313190920,
//         600769443,140712186,218387168,416515873,194487510,149671312,241556542,575727819,873823206};
//     while (std::any_of(a.begin(), a.end(), [](long b){return b >= 100;}))
//     {
//         std::set<long> aSorted{a.begin(), a.end()};
//         long min = *(aSorted.lower_bound(100));
//         for (auto b : a)
//         {
//             if (b >= 100) b = b - min + factor;
//         }
//         ++factor;
//     }
//     for (auto b : a)
//     {
//         std::cout << b << " ";
//     }

//     return 0;
// }

--------------------------------------------------------------------

// Roads and Libraries

// The Ruler of HackerLand believes that every citizen of the country should have access to a library.
// Unfortunately, HackerLand was hit by a tornado that destroyed all of its libraries and obstructed its
// roads! As you are the greatest programmer of HackerLand, the ruler wants your help to repair the roads
// and build some new libraries efficiently.

// HackerLand has n cities numbered from 1 to n. The cities are connected by m bidirectional roads. A
// citizen has access to a library if:
//   Their city contains a library.
//   They can travel by road from their city to a city containing a library.
// The following figure is a sample map of HackerLand where the dotted lines denote obstructed roads:
//   1---2
//   |\  |
//   | \ |
//   |  \|
//   7   3
//   5---6---8
//   4 has no connections
//   The cost of repairing any road is c_road dollars, and the cost to build a library in any city is
//   c_lib dollars. If in the above example c_road=2 and c_lib=3, we would build 5 roads at a cost of
//   5*2=10 and 2 libraries for a cost of 6. We don't need to rebuild one of the roads in the cycle
//   1---2---3---1.

// You are given q queries, where each query consists of a map of HackerLand and value of c_lib and c_road.
// For each query, find the minimum cost of making libraries accessible to all the citizens and print it
// on a new line.

// Sample Input
// 2
// 3 3 2 1
// 1 2
// 3 1
// 2 3
// 6 6 2 5
// 1 3
// 3 4
// 2 4
// 1 2
// 2 3
// 5 6
// Sample Output
// 4
// 12

#include <bits/stdc++.h>

using namespace std;

vector<string> split_string(string);

// Complete the roadsAndLibraries function below.
struct City
{
    City(
        const int idParam,
        bool isVisitedParam,
        const std::vector<std::shared_ptr<City>>& connectedParam) :
            id(idParam),
            isVisited(isVisitedParam),
            connected(connectedParam)
    {
    }

    int id;
    bool isVisited;
    std::vector<std::shared_ptr<City>> connected;
};

long roadsAndLibraries(int n, int c_lib, int c_road, vector<vector<int>> cities)
{
    // connect the cities
    //     store each unique city in a hashtable
    std::unordered_map<int, std::shared_ptr<City>> idAndCityMap;
    for (const auto& city : cities)
    {
        auto& city1 = idAndCityMap[city[0]];
        auto& city2 = idAndCityMap[city[1]];

        if (!city1) city1 = std::make_shared<City>(
                                city[0],
                                false,
                                std::vector<std::shared_ptr<City>>{});
        if (!city2) city2 = std::make_shared<City>(
                                city[1],
                                false,
                                std::vector<std::shared_ptr<City>>{});

        city1->connected.push_back(city2);
        city2->connected.push_back(city1);
    }

    // for each city in the hashtable
    //     traverse from city x to all posible cities
    //         a city should only be visited once
    //         mark it as visited and then delete it from the hashtable of cities
    //         add c_road to the total cost for each traversal
    //         once there are no more cities to be traversed, add c_lib to the total cost
    if (c_lib <= c_road) return static_cast<long>(n) * c_lib;

    long totalCost = (static_cast<long>(n) - idAndCityMap.size()) * c_lib;
    while (!idAndCityMap.empty())
    {
        auto startingIdAndCity = idAndCityMap.begin();
        startingIdAndCity->second->isVisited = true;
        idAndCityMap.erase(startingIdAndCity);

        long citiesCount = 0;
        std::queue<std::shared_ptr<City>> citiesQueue;
        citiesQueue.push(startingIdAndCity->second);
        while (!citiesQueue.empty())
        {
            ++citiesCount;
            auto city = citiesQueue.front();
            citiesQueue.pop();
            for (auto conn : city->connected)
            {
                if (conn->isVisited) continue;
                conn->isVisited = true;
                citiesQueue.push(conn);
                idAndCityMap.erase(conn->id);
            }
        }

        long roadCost = (citiesCount - 1) * c_road;
        totalCost += roadCost + c_lib;
    }

    return totalCost;
}

int main()
{
    ofstream fout(getenv("OUTPUT_PATH"));

    int q;
    cin >> q;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');

    for (int q_itr = 0; q_itr < q; q_itr++) {
        string nmC_libC_road_temp;
        getline(cin, nmC_libC_road_temp);

        vector<string> nmC_libC_road = split_string(nmC_libC_road_temp);

        int n = stoi(nmC_libC_road[0]);

        int m = stoi(nmC_libC_road[1]);

        int c_lib = stoi(nmC_libC_road[2]);

        int c_road = stoi(nmC_libC_road[3]);

        vector<vector<int>> cities(m);
        for (int i = 0; i < m; i++) {
            cities[i].resize(2);

            for (int j = 0; j < 2; j++) {
                cin >> cities[i][j];
            }

            cin.ignore(numeric_limits<streamsize>::max(), '\n');
        }

        long result = roadsAndLibraries(n, c_lib, c_road, cities);

        fout << result << "\n";
    }

    fout.close();

    return 0;
}

vector<string> split_string(string input_string) {
    string::iterator new_end = unique(input_string.begin(), input_string.end(), [] (const char &x, const char &y) {
        return x == y and x == ' ';
    });

    input_string.erase(new_end, input_string.end());

    while (input_string[input_string.length() - 1] == ' ') {
        input_string.pop_back();
    }

    vector<string> splits;
    char delimiter = ' ';

    size_t i = 0;
    size_t pos = input_string.find(delimiter);

    while (pos != string::npos) {
        splits.push_back(input_string.substr(i, pos - i));

        i = pos + 1;
        pos = input_string.find(delimiter, i);
    }

    splits.push_back(input_string.substr(i, min(pos, input_string.length()) - i + 1));

    return splits;
}

-------------------------------------------------------------------------------

C++

-------------------------------------------------------------------------------

// Recursion: Fibonacci Numbers

// The Fibonacci Sequence

// The Fibonacci sequence appears in nature all around us, in the arrangement of seeds in a sunflower
// and the spiral of a nautilus for example.

// The Fibonacci sequence begins with fibonacci(0) = 0 and fibonacci(1) = 1 as its first and second
// terms. After these first two elements, each subsequent element is equal to the sum of the previous
// two elements.

#include <iostream>

using namespace std;

int fibonacci(
    const int n,
    int& ctr,
    int values[])
{
    int indexToChange = ctr % 2;
    values[indexToChange] = values[0] + values[1];
    if (ctr == n) return values[indexToChange];
    else          return fibonacci(n, ++ctr, values);
}

int fibonacci(int n) {
    // Complete the function.
    if (n <= 1) return n;

    int values[2] = {0, 1};
    int startingCtr = 2;
    return fibonacci(n, startingCtr, values);
}

int main() {
    int n;
    cin >> n;
    cout << fibonacci(n);
    return 0;
}
