// Sock Merchant

// John works at a clothing store. He has a large pile of socks that he must pair by color for sale. Given an array of integers representing the color of each sock, determine how many pairs of socks with matching colors there are.

// For example, there are n=7 socks with colors ar = [1,2,1,2,1,3,2]. There is one pair of color 1 and one of color 2. There are three odd socks left, one of each color. The number of pairs is 2.

// Sample Input
// 9
// 10 20 20 10 10 30 50 10 20
// Sample Output
// 3

using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text.RegularExpressions;
using System.Text;
using System;

class Solution {

    // Complete the sockMerchant function below.
    static int sockMerchant(int n, int[] ar)
    {
        HashSet<int> arHashSet = new HashSet<int>();
        int count = 0;
        foreach (var sock in ar)
        {
            if (arHashSet.Contains(sock))
            {
                ++count;
                arHashSet.Remove(sock);
            }
            else
            {
                arHashSet.Add(sock);
            }
        }
        return count;
    }

    static void Main(string[] args) {
        TextWriter textWriter = new StreamWriter(@System.Environment.GetEnvironmentVariable("OUTPUT_PATH"), true);

        int n = Convert.ToInt32(Console.ReadLine());

        int[] ar = Array.ConvertAll(Console.ReadLine().Split(' '), arTemp => Convert.ToInt32(arTemp))
        ;
        int result = sockMerchant(n, ar);

        textWriter.WriteLine(result);

        textWriter.Flush();
        textWriter.Close();
    }
}

-------------------------------------------------------------------------------

// Counting Valleys

// Gary is an avid hiker. He tracks his hikes meticulously, paying close attention to small details like topography. During his last hike he took exactly  steps. For every step he took, he noted if it was an uphill, U, or a downhill, D step. Gary's hikes start and end at sea level and each step up or down represents a 1 unit change in altitude. We define the following terms:
// - A mountain is a sequence of consecutive steps above sea level, starting with a step up from sea level and ending with a step down to sea level.
// - A valley is a sequence of consecutive steps below sea level, starting with a step down from sea level and ending with a step up to sea level.

// Given Gary's sequence of up and down steps during his last hike, find and print the number of valleys he walked through.

// For example, if Gary's path is s = [DDUUUUDD], he first enters a valley 2 units deep. Then he climbs out an up onto a mountain 2 units high. Finally, he returns to sea level and ends his hike.

// Sample Input
// 8
// UDDDUDUU
// Sample Output
// 1
// Explanation
// If we represent _ as sea level, a step up as /, and a step down as \, Gary's hike can be drawn as:
// _/\      _
//    \    /
//     \/\/

using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text.RegularExpressions;
using System.Text;
using System;

class Solution {

    // Complete the countingValleys function below.
    static int countingValleys(int n, string s) {
        if (n == 0 || s.Length == 0) return 0;

        Dictionary<char, int> STEP_VALUE = new Dictionary<char, int>()
                                            {
                                                {'U', 1},
                                                {'D', -1},
                                            };
        int currentLevel = 0;
        int valleysCount = 0;
        foreach (var ch in s)
        {
            currentLevel += STEP_VALUE[ch];
            valleysCount += Convert.ToInt32(currentLevel == 0 && ch == 'U');
        }
        return valleysCount;

    }

    static void Main(string[] args) {
        TextWriter textWriter = new StreamWriter(@System.Environment.GetEnvironmentVariable("OUTPUT_PATH"), true);

        int n = Convert.ToInt32(Console.ReadLine());

        string s = Console.ReadLine();

        int result = countingValleys(n, s);

        textWriter.WriteLine(result);

        textWriter.Flush();
        textWriter.Close();
    }
}

-------------------------------------------------------------------------------

// Jumping on the Clouds

// Emma is playing a new mobile game that starts with consecutively numbered clouds. Some of the clouds are thunderheads and others are cumulus. She can jump on any cumulus cloud having a number that is equal to the number of the current cloud plus 1 or 2. She must avoid the thunderheads. Determine the minimum number of jumps it will take Emma to jump from her starting postion to the last cloud. It is always possible to win the game.

// For each game, Emma will get an array of clouds numbered 0 if they are safe or 1 if they must be avoided. For example, c=[0,1,0,0,0,1,0] indexed from 0...6. The number on each cloud is its index in the list so she must avoid the clouds at indexes 1 and 5. She could follow the following two paths: 0-2-4-6 or 0-2-3-4-6. The first path takes 3 jumps while the second takes 4.

// Sample Input 0
// 7
// 0 0 1 0 0 1 0
// Sample Output 0
// 4

// Sample Input 1
// 6
// 0 0 0 0 1 0
// Sample Output 1
// 3

using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text.RegularExpressions;
using System.Text;
using System;

class Solution {

    // Complete the jumpingOnClouds function below.
    static int jumpingOnClouds(int[] c)
    {
        int numberOfJumps = 0;
        int LAST_CLOUD = c.Length - 1;
        for (int ctr = 0; ctr < LAST_CLOUD; )
        {
            if (ctr + 2 >= LAST_CLOUD || c[ctr + 2] != 1) ctr += 2;
            else ctr += 1;
            ++numberOfJumps;
        }
        return numberOfJumps;
    }

    static void Main(string[] args) {
        TextWriter textWriter = new StreamWriter(@System.Environment.GetEnvironmentVariable("OUTPUT_PATH"), true);

        int n = Convert.ToInt32(Console.ReadLine());

        int[] c = Array.ConvertAll(Console.ReadLine().Split(' '), cTemp => Convert.ToInt32(cTemp))
        ;
        int result = jumpingOnClouds(c);

        textWriter.WriteLine(result);

        textWriter.Flush();
        textWriter.Close();
    }
}

-------------------------------------------------------------------------------

// Repeated String

// Lilah has a string, s, of lowercase English letters that she repeated infinitely many times.

// Given an integer, n, find and print the number of letter a's in the first n letters of Lilah's infinite string.

// For example, if the string s='abcac' and n=10, the substring we consider is abcacabcac, the first 10 characters of her infinite string. There are 4 occurrences of a in the substring.

// Sample Input 0
// aba
// 10
// Sample Output 0
// 7
// Explanation 0
// The first n=10 letters of the infinite string are abaabaabaa. Because there are 7 a's, we print 7 on a new line.

// Sample Input 1
// a
// 1000000000000
// Sample Output 1
// 1000000000000
// Explanation 1
// Because all of the first n=1000000000000 letters of the infinite string are a, we print 1000000000000 on a new line.

using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text.RegularExpressions;
using System.Text;
using System;

class Solution {

    // Complete the repeatedString function below.
    static long repeatedString(string s, long n)
    {
        long stringLength = s.Length;
        long fullRepeatingStringCountOfA = (n / stringLength) * s.Count(ch => ch == 'a');
        int stringRemainderLength = Convert.ToInt32(n % stringLength);
        string stringRemainder = s.Substring(0, stringRemainderLength);
        return fullRepeatingStringCountOfA + stringRemainder.Count(ch => ch == 'a');
    }

    static void Main(string[] args) {
        TextWriter textWriter = new StreamWriter(@System.Environment.GetEnvironmentVariable("OUTPUT_PATH"), true);

        string s = Console.ReadLine();

        long n = Convert.ToInt64(Console.ReadLine());

        long result = repeatedString(s, n);

        textWriter.WriteLine(result);

        textWriter.Flush();
        textWriter.Close();
    }
}

-------------------------------------------------------------------------------

// Find Merge Point of Two Lists

// This challenge is part of a tutorial track by MyCodeSchool

// Given pointers to the head nodes of 2 linked lists that merge together at some point, find the Node where the two lists merge. It is guaranteed that the two head Nodes will be different, and neither will be NULL.

// In the diagram below, the two lists converge at Node x:

// [List #1] a--->b--->c
//                      \
//                       x--->y--->z--->NULL
//                      /
//      [List #2] p--->q

// Complete the int findMergeNode(SinglyLinkedListNode* head1, SinglyLinkedListNode* head2) method so that it finds and returns the data value of the Node where the two lists merge.

// Test Case 0
//  1
//   \
//    2--->3--->NULL
//   /
//  1
// Test Case 1
// 1--->2
//       \
//        3--->Null
//       /
//      1
// Sample Output
// 2
// 3

using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text.RegularExpressions;
using System.Text;
using System;

class Solution {

    class SinglyLinkedListNode {
        public int data;
        public SinglyLinkedListNode next;

        public SinglyLinkedListNode(int nodeData) {
            this.data = nodeData;
            this.next = null;
        }
    }

    class SinglyLinkedList {
        public SinglyLinkedListNode head;
        public SinglyLinkedListNode tail;

        public SinglyLinkedList() {
            this.head = null;
            this.tail = null;
        }

        public void InsertNode(int nodeData) {
            SinglyLinkedListNode node = new SinglyLinkedListNode(nodeData);

            if (this.head == null) {
                this.head = node;
            } else {
                this.tail.next = node;
            }

            this.tail = node;
        }
    }

    static void PrintSinglyLinkedList(SinglyLinkedListNode node, string sep, TextWriter textWriter) {
        while (node != null) {
            textWriter.Write(node.data);

            node = node.next;

            if (node != null) {
                textWriter.Write(sep);
            }
        }
    }

    // Complete the findMergeNode function below.

    /*
     * For your reference:
     *
     * SinglyLinkedListNode {
     *     int data;
     *     SinglyLinkedListNode next;
     * }
     *
     */
    static int findMergeNode(SinglyLinkedListNode head1, SinglyLinkedListNode head2)
    {
        HashSet<SinglyLinkedListNode> nodeSet = new HashSet<SinglyLinkedListNode>();
        while (head1 != null || head2 != null)
        {
            if (head1 != null)
            {
                if (!nodeSet.Add(head1)) return head1.data;
                head1 = head1.next;
            }
            if (head2 != null)
            {
                if (!nodeSet.Add(head2)) return head2.data;
                head2 = head2.next;
            }
        }
        return -1;
    }

    static void Main(string[] args) {
        TextWriter textWriter = new StreamWriter(@System.Environment.GetEnvironmentVariable("OUTPUT_PATH"), true);

        int tests = Convert.ToInt32(Console.ReadLine());

        for (int testsItr = 0; testsItr < tests; testsItr++) {
            int index = Convert.ToInt32(Console.ReadLine());

            SinglyLinkedList llist1 = new SinglyLinkedList();

            int llist1Count = Convert.ToInt32(Console.ReadLine());

            for (int i = 0; i < llist1Count; i++) {
                int llist1Item = Convert.ToInt32(Console.ReadLine());
                llist1.InsertNode(llist1Item);
            }

            SinglyLinkedList llist2 = new SinglyLinkedList();

            int llist2Count = Convert.ToInt32(Console.ReadLine());

            for (int i = 0; i < llist2Count; i++) {
                int llist2Item = Convert.ToInt32(Console.ReadLine());
                llist2.InsertNode(llist2Item);
            }

            SinglyLinkedListNode ptr1 = llist1.head;
            SinglyLinkedListNode ptr2 = llist2.head;

            for (int i = 0; i < llist1Count; i++) {
                if (i < index) {
                    ptr1 = ptr1.next;
                }
            }

            for (int i = 0; i < llist2Count; i++) {
                if (i != llist2Count-1) {
                    ptr2 = ptr2.next;
                }
            }

            ptr2.next = ptr1;

            int result = findMergeNode(llist1.head, llist2.head);

            textWriter.WriteLine(result);
        }

        textWriter.Flush();
        textWriter.Close();
    }
}

-------------------------------------------------------------------------------

// Sherlock and the Valid String

// Sherlock considers a string to be valid if all characters of the string appear the same number of times. It is also valid if he can remove just 1 character at 1 index in the string, and the remaining characters will occur the same number of times. Given a string , determine if it is valid. If so, return YES, otherwise return NO.

// For example, if s=abc, it is a valid string because frequencies are {a:1, b:1, c:1}. So is s=abcc because we can remove one c and have 1 of each character in the remaining string. If s=abccc however, the string is not valid as we can only remove 1 occurrence of c. That would leave character frequencies of {a:1, b:1, c:2}.

// Sample Input 0
// aabbcd
// Sample Output 0
// NO

using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text.RegularExpressions;
using System.Text;
using System;

class Solution {

    // Complete the isValid function below.
    static string isValid(string s)
    {
        Dictionary<char, int> charAndCountDict = new Dictionary<char, int>();
        foreach (var ch in s)
        {
            if (!charAndCountDict.ContainsKey(ch))
            {
                charAndCountDict.Add(ch, 0);
            }
            ++charAndCountDict[ch];
        }

        if (charAndCountDict.Count == 1)
        {
            return "YES";
        }
        else if (charAndCountDict.Count == 2)
        {
            return Math.Abs(charAndCountDict.Values.ElementAt(0) -
                            charAndCountDict.Values.ElementAt(1))
                    <= 1 ?
                    "YES" :
                    "NO";
        }

        int repeatingCount = charAndCountDict.Values.ElementAt(0) ==
                            charAndCountDict.Values.ElementAt(1) ?
                                charAndCountDict.Values.ElementAt(0) :
                                charAndCountDict.Values.ElementAt(2);
        bool isOtherCountKnown = false;

        foreach (var currentCount in charAndCountDict.Values)
        {
            if (currentCount == repeatingCount) continue;
            if (isOtherCountKnown ||
                (currentCount != 1 && Math.Abs(currentCount - repeatingCount) != 1))
            {
                return "NO";
            }

            isOtherCountKnown = true;
        }
        return "YES";
    }

    static void Main(string[] args) {
        TextWriter textWriter = new StreamWriter(@System.Environment.GetEnvironmentVariable("OUTPUT_PATH"), true);

        string s = Console.ReadLine();

        string result = isValid(s);

        textWriter.WriteLine(result);

        textWriter.Flush();
        textWriter.Close();
    }
}

-------------------------------------------------------------------------------

// 2D Array - DS

// Given a 6x6 2D Array, arr:
// 1 1 1 0 0 0
// 0 1 0 0 0 0
// 1 1 1 0 0 0
// 0 0 0 0 0 0
// 0 0 0 0 0 0
// 0 0 0 0 0 0

// We define an hourglass in A to be a subset of values with indices falling in this pattern in arr's graphical representation:
// a b c
//   d
// e f g

// There are 16 hourglasses in arr, and an hourglass sum is the sum of an hourglass' values. Calculate the hourglass sum for every hourglass in arr, then print the maximum hourglass sum.

// For example, given the 2D array:
// -9 -9 -9  1 1 1
//  0 -9  0  4 3 2
// -9 -9 -9  1 2 3
//  0  0  8  6 6 0
//  0  0  0 -2 0 0
//  0  0  1  2 4 0
//  We calculate the following 16 hourglass values:
// -63, -34, -9, 12,
// -10, 0, 28, 23,
// -27, -11, -2, 10,
// 9, 17, 25, 18
// Our highest hourglass value is 28 from the hourglass:
// 0 4 3
//   1
// 8 6 6

// Sample Input
// 1 1 1 0 0 0
// 0 1 0 0 0 0
// 1 1 1 0 0 0
// 0 0 2 4 4 0
// 0 0 0 2 0 0
// 0 0 1 2 4 0
// Sample Output
// 19

using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text.RegularExpressions;
using System.Text;
using System;

class Solution {

    // Complete the hourglassSum function below.
    static int hourglassSum(int[][] arr)
    {
        int[] hourGlassesSums = new int[16];

        int topHourGlassCtr = 0;
        int midHourGlassCtr = 0;
        int botHourGlassCtr = 0;

        // int firstTopHourGlassLine = 0; // No need to specify
        int firstMidHourGlassLine = 1;
        int firstBotHourGlassLine = 2;

        int HOUR_GLASS_PER_LINE = 4;

        for (int line = 0; line < 6; ++line)
        {
            int currentThreeSum = arr[line][0] + arr[line][1] + arr[line][2];

            for (int hourGlassCtr = 0; hourGlassCtr < HOUR_GLASS_PER_LINE; ++hourGlassCtr)
            {
                if (hourGlassCtr > 0)
                {
                    currentThreeSum += arr[line][hourGlassCtr + 2];
                    currentThreeSum -= arr[line][hourGlassCtr - 1];
                }

                if (topHourGlassCtr < 16)
                {
                    hourGlassesSums[topHourGlassCtr++] += currentThreeSum;
                }
                if (line >= firstBotHourGlassLine && botHourGlassCtr < 16)
                {
                    hourGlassesSums[botHourGlassCtr++] += currentThreeSum;
                }
                if (line >= firstMidHourGlassLine && midHourGlassCtr < 16)
                {
                    hourGlassesSums[midHourGlassCtr++] += arr[line][hourGlassCtr + 1];
                }
            }
        }

        return hourGlassesSums.Max();
    }

    static void Main(string[] args) {
        TextWriter textWriter = new StreamWriter(@System.Environment.GetEnvironmentVariable("OUTPUT_PATH"), true);

        int[][] arr = new int[6][];

        for (int i = 0; i < 6; i++) {
            arr[i] = Array.ConvertAll(Console.ReadLine().Split(' '), arrTemp => Convert.ToInt32(arrTemp));
        }

        int result = hourglassSum(arr);

        textWriter.WriteLine(result);

        textWriter.Flush();
        textWriter.Close();
    }
}

-------------------------------------------------------------------------------

// Arrays: Left Rotation

// A left rotation operation on an array shifts each of the array's elements 1 unit to the left. For example, if 2 left rotations are performed on array [1,2,3,4,5], then the array would become [3,4,5,1,2].

// Given an array a of n integers and a number, d, perform d left rotations on the array. Return the updated array to be printed as a single line of space-separated integers.

// Sample Input
// 5 4
// 1 2 3 4 5
// Sample Output
// 5 1 2 3 4

using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text.RegularExpressions;
using System.Text;
using System;

class Solution {

    // Complete the rotLeft function below.
    static int[] rotLeft(int[] a, int d) {
        d %= a.Length;

        Queue buffer = new Queue();
        int currentIndex = 0;
        for (int ctr = d; ctr < a.Length; ++ctr)
        {
            buffer.Enqueue(a[currentIndex]);
            a[currentIndex++] = a[ctr];
        }
        while (currentIndex < a.Length)
        {
            buffer.Enqueue(a[currentIndex]);
            a[currentIndex++] = Convert.ToInt32(buffer.Dequeue());
        }
        return a;
    }

    static void Main(string[] args) {
        TextWriter textWriter = new StreamWriter(@System.Environment.GetEnvironmentVariable("OUTPUT_PATH"), true);

        string[] nd = Console.ReadLine().Split(' ');

        int n = Convert.ToInt32(nd[0]);

        int d = Convert.ToInt32(nd[1]);

        int[] a = Array.ConvertAll(Console.ReadLine().Split(' '), aTemp => Convert.ToInt32(aTemp))
        ;
        int[] result = rotLeft(a, d);

        textWriter.WriteLine(string.Join(" ", result));

        textWriter.Flush();
        textWriter.Close();
    }
}

-------------------------------------------------------------------------------

// New Year Chaos

// It's New Year's Day and everyone's in line for the Wonderland rollercoaster ride! There are a number of people queued up, and each person wears a sticker indicating their initial position in the queue. Initial positions increment by 1 from 1 at the front of the line to n at the back.

// Any person in the queue can bribe the person directly in front of them to swap positions. If two people swap positions, they still wear the same sticker denoting their original places in line. One person can bribe at most two others. For example, if n=8 and Person 5 bribes Person 4, the queue will look like this: 1,2,3,4,5,6,7,8.

// Fascinated by this chaotic queue, you decide you must know the minimum number of bribes that took place to get the queue into its current state!

// Sample Input
// 2
// 5
// 2 1 5 3 4
// 5
// 2 5 1 3 4
// Sample Output
// 3
// Too chaotic

using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text.RegularExpressions;
using System.Text;
using System;

class Solution {

    // Complete the minimumBribes function below.
    // solution 1 - too slow
    // static void minimumBribes(int[] q)
    // {
    //     var qList = q.ToList();

    //     int totalBribes = 0;
    //     for (int ctr = qList.Count - 1; ctr >= 0; --ctr)
    //     {
    //         int originalPerson = ctr + 1;
    //         int currentPosition = qList.IndexOf(originalPerson) + 1;
    //         int diff = originalPerson - currentPosition;

    //         if (diff > 2)
    //         {
    //             Console.WriteLine("Too chaotic");
    //             return;
    //         }
    //         totalBribes += diff;
    //         qList.Remove(originalPerson);
    //     }
    //     Console.WriteLine(totalBribes);
    // }

    // solution 2 - slow
    // static void minimumBribes(int[] q)
    // {
    //     // var qList = q.ToList();
    //     int totalBribes = 0;
    //     for (int ctr = q.Length - 1; ctr >= 0; --ctr)
    //     {
    //         if (q[ctr] > ctr + 2 + 1)
    //         {
    //             Console.WriteLine("Too chaotic");
    //             return;
    //         }
    //         // Where(elem => elem > q[ctr])
    //         for (int ctr2 = 0; ctr2 < ctr; ++ctr2)
    //         {
    //             if (q[ctr2] > q[ctr]) ++totalBribes;
    //         }
    //     }
    //     Console.WriteLine(totalBribes);
    // }

    static void minimumBribes(int[] q)
    {
        // var qList = q.ToList();
        int totalBribes = 0;
        for (int ctr = q.Length - 1; ctr >= 0; --ctr)
        {
            if (q[ctr] > ctr + 2 + 1)
            {
                Console.WriteLine("Too chaotic");
                return;
            }
            // Where(elem => elem > q[ctr])
            int maxForwardMovement = Math.Max(q[ctr] - 2 - 1, 0);
            for (int ctr2 = maxForwardMovement; ctr2 < ctr; ++ctr2)
            {
                if (q[ctr2] > q[ctr]) ++totalBribes;
            }
        }
        Console.WriteLine(totalBribes);
    }

    static void Main(string[] args) {
        int t = Convert.ToInt32(Console.ReadLine());

        for (int tItr = 0; tItr < t; tItr++) {
            int n = Convert.ToInt32(Console.ReadLine());

            int[] q = Array.ConvertAll(Console.ReadLine().Split(' '), qTemp => Convert.ToInt32(qTemp))
            ;
            minimumBribes(q);
        }
    }
}

-------------------------------------------------------------------------------

// Minimum Swaps 2

// You are given an unordered array consisting of consecutive integers [1, 2, 3, ..., n] without any duplicates. You are allowed to swap any two elements. You need to find the minimum number of swaps required to sort the array in ascending order.

// For example, given the array arr=[7,1,3,2,4,5,6] we perform the following steps:

// i   arr                         swap (indices)
// 0   [7, 1, 3, 2, 4, 5, 6]   swap (0,3)
// 1   [2, 1, 3, 7, 4, 5, 6]   swap (0,1)
// 2   [1, 2, 3, 7, 4, 5, 6]   swap (3,4)
// 3   [1, 2, 3, 4, 7, 5, 6]   swap (4,5)
// 4   [1, 2, 3, 4, 5, 7, 6]   swap (5,6)
// 5   [1, 2, 3, 4, 5, 6, 7]

// It took 5 swaps to sort the array.

// Sample Input 0
// 4
// 4 3 1 2
// Sample Output 0
// 3

using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text.RegularExpressions;
using System.Text;
using System;

class Solution {

    // Complete the minimumSwaps function below.
    // solution 1 - working ok
    // static int minimumSwaps(int[] arr)
    // {
    //     // var arrSorted = (int[])arr.Clone();
    //     // var arrSorted = arr.Clone().Cast<int>().ToArray();
    //     // var arrSorted = Array.ConvertAll<System.Int32, int>(arr.Clone(), elem => Convert.ToInt32(elem));
    //     // Console.WriteLine(arrSorted.GetType());

    //     // Array.Sort(arrSorted);
    //     int totalSwaps = 0;
    //     for (int ctr = 0; ctr < arr.Length; ++ctr)
    //     {
    //         while (arr[ctr] != ctr + 1)
    //         {
    //             int temp = arr[ctr];
    //             arr[ctr] = arr[temp - 1];
    //             arr[temp - 1] = temp;
    //             ++totalSwaps;
    //         }
    //     }
    //     return totalSwaps;// > 0 ? totalSwaps - 1 : 0;
    // }

    static int minimumSwaps(int[] arr)
    {
        Dictionary<int, int> arrDict = new Dictionary<int, int>();
        for (int ctr = 0; ctr < arr.Length; ++ctr)
        {
            arrDict.Add(arr[ctr], ctr);
        }
        int totalSwaps = 0;
        for (int ctr = 0; ctr < arr.Length; ++ctr)
        {
            int indexToSwap = arrDict[ctr + 1];
            if (indexToSwap == ctr) continue;

            arr[indexToSwap] = arr[ctr];
            arrDict[arr[ctr]] = indexToSwap;
            ++totalSwaps;
        }
        return totalSwaps;
    }

    static void Main(string[] args) {
        TextWriter textWriter = new StreamWriter(@System.Environment.GetEnvironmentVariable("OUTPUT_PATH"), true);

        int n = Convert.ToInt32(Console.ReadLine());

        int[] arr = Array.ConvertAll(Console.ReadLine().Split(' '), arrTemp => Convert.ToInt32(arrTemp))
        ;
        int res = minimumSwaps(arr);

        textWriter.WriteLine(res);

        textWriter.Flush();
        textWriter.Close();
    }
}

-------------------------------------------------------------------------------

// PermMissingElem

// An array A consisting of N different integers is given. The array contains integers in the range [1..(N + 1)], which means that exactly one element is missing.

// Your goal is to find that missing element.

// Write a function:

// class Solution { public int solution(int[] A); }

// that, given an array A, returns the value of the missing element.

// For example, given array A such that:

//   A[0] = 2
//   A[1] = 3
//   A[2] = 1
//   A[3] = 5
// the function should return 4, as it is the missing element.

// Write an efficient algorithm for the following assumptions:

// N is an integer within the range [0..100,000];
// the elements of A are all distinct;
// each element of array A is an integer within the range [1..(N + 1)].
// Copyright 2009–2019 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited.

using System;
// you can also use other imports, for example:
// using System.Collections.Generic;

// you can write to stdout for debugging purposes, e.g.
// Console.WriteLine("this is a debug message");

class Solution {
    public int solution(int[] A) {
        // write your code in C# 6.0 with .NET 4.5 (Mono)
        Array.Sort(A);
        for (int ctr = 0; ctr < A.Length; ++ctr)
        {
            if (A[ctr] != ctr + 1) return ctr + 1;
        }
        return A.Length + 1;
    }
}

-------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;

namespace eto
{

/*
3 using 1 2
1 1 1
1 2
2 1

4 using 1 2
1 1 1 1
1 1 2
1 2 1
2 1 1
2 2

5 using 1 2
1 1 1 1 1
1 1 1 2
1 1 2 1
1 2 1 1
1 2 2
2 1 1 1
2 1 2
2 2 1

6 using 1 2
1 1 1 1 1 1
1 1 1 1 2
1 1 1 2 1
1 1 2 1 1
1 1 2 2
1 2 1 1 1
1 2 1 2
1 2 2 1
2 1 1 1 1
2 1 1 2
2 1 2 1
2 2 1 1
2 2 2

6 using 1 3 5
1 1 1 1 1 1
1 1 1 3
1 1 3 1
1 3 1 1
1 5
3 1 1 1
3 3
5 1
*/

public class MainProgram
{
    static void Main(string[] args)
    {
        Console.WriteLine();
        (new MainProgram()).RealMain();
    }

    public void RealMain()
    {
        int[] allowedSteps = {1, 3, 5};//{1, 2};
        int stairsHeight = 4;//6;//Convert.ToInt32(Console.ReadLine());

        int initialHeight = 0;
        int waysCount = 0;

        countNumberOfWays(allowedSteps, stairsHeight, initialHeight, ref waysCount);
        Console.WriteLine("Number of ways to climb the stairs is " + waysCount);
    }

    private void countNumberOfWays(
        int[] allowedSteps,
        int stairsHeight,
        int currentHeight,
        ref int waysCount)
    {
        foreach (var step in allowedSteps)
        {
            int updatedHeight = currentHeight + step;
            if (updatedHeight == stairsHeight)
            {
                ++waysCount;
                return;
            }
            else if (updatedHeight > stairsHeight)
            {
                return;
            }
            else
            {
                countNumberOfWays(allowedSteps, stairsHeight, updatedHeight, ref waysCount);
            }
        }
    }
}

}

-------------------------------------------------------------------------------

/******************************************************************************

Welcome to GDB Online.
GDB online is an online compiler and debugger tool for C, C++, Python, Java, PHP, Ruby, Perl,
C#, VB, Swift, Pascal, Fortran, Haskell, Objective-C, Assembly, HTML, CSS, JS, SQLite, Prolog.
Code, Compile, Run and Debug online from anywhere in world.

*******************************************************************************/
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

interface ReachableEndChecker
{
    string name();
    void reachTheEnd(int[] numbers);
}

class BackwardsValidator : ReachableEndChecker
{
    public virtual string name()
    {
        return "[BackwardsValidator]";
    }

    public virtual void reachTheEnd(int[] numbers)
    {
        // bool[] reachableEnd = new bool[numbers.Length]; // default is false
        bool[] reachableEndArr = Enumerable.Repeat<bool>(false, numbers.Length).ToArray();

        for (int index = numbers.Length - 1; index >= 0; --index)
        {
            int maxReachableIndex = index + numbers[index];
            if (maxReachableIndex >= numbers.Length) reachableEndArr[index] = true;
            for (int reachedIndex = index + 1;
                reachedIndex < numbers.Length && reachedIndex <= maxReachableIndex;
                ++reachedIndex)
            {
                if (reachableEndArr[reachedIndex])
                {
                    reachableEndArr[index] = true;
                    break;
                }
            }
        }

        bool result = reachableEndArr.Length == 0 ? false : reachableEndArr[0];
        Console.Write("\n" + this.name() + " " + result);
        if (result)
        {
            Console.Write("\n" + name() + "\tPossible indexes path to end : 0 ");
            for (int index = 0, maxReachableIndex = 0; maxReachableIndex < numbers.Length;)
            {
                maxReachableIndex = index + numbers[index];
                for (int reachedIndex = maxReachableIndex;
                    reachedIndex < numbers.Length && reachedIndex > index;
                    --reachedIndex)
                {
                    if (reachableEndArr[reachedIndex])
                    {
                        Console.Write(reachedIndex + " ");
                        index = reachedIndex;
                        break;
                    }
                }
            }
            Console.Write("end");
        }
        else
        {
            Console.Write("\n" + name() + "\tPossible indexes path to end : None");
        }
    }
}

class DfsRecursion : ReachableEndChecker
{
    public virtual string name()
    {
        return "[DfsRecursion]";
    }

    public virtual void reachTheEnd(int[] numbers)
    {
        List<int> indexesInPath = new List<int>();
        bool result = dfs(numbers, 0, indexesInPath);

        Console.Write("\n" + name() + " " + result);
        Console.Write("\n" + name() + "\tPossible indexes path to end : ");
        if (result)
        {
            foreach (var index in indexesInPath) Console.Write(index + " ");
            Console.Write("end");
        }
        else
        {
            Console.Write("None");
        }
    }

    private bool dfs(
        int[] numbers,
        int currentIndex,
        List<int> indexesInPath)
    {
        indexesInPath.Add(currentIndex);
        int maxReachableIndex = currentIndex + numbers[currentIndex];
        if (maxReachableIndex >= numbers.Length)
        {
            return true;
        }
        for (int index = maxReachableIndex;
            index > currentIndex && index < numbers.Length;
            --index)
        {
            bool result = dfs(numbers, index, indexesInPath);
            if (result) return true;
        }
        indexesInPath.RemoveAt(indexesInPath.Count - 1);
        return false;
    }
}

// abstract class BfsGraphNodes : ReachableEndChecker
// {
//     public abstract string Name();
//     public abstract void reachTheEnd(int[] numbers);
// }

class BfsGraphNodes : ReachableEndChecker
// this finds the guaranteed shortest path unlike the others which just prioritizes
// the next longest step possible on every step thus failing on cases like [4, 2, 1, 9, 1, 1, 1]
{
    public virtual string name()
    {
        return "[BfsGraphNodes]";
    }

    public virtual void reachTheEnd(int[] numbers)
    {
        var nodeDict = createNodes(numbers);
        connectNodes(numbers, nodeDict);

        bool isPathFound = false;
        HashSet<int> visited = new HashSet<int>();

        Queue nodesQueue = new Queue();
        nodesQueue.Enqueue(nodeDict[0]);
        while (nodesQueue.Count > 0)
        {
            var currentNode = (Node<int>)nodesQueue.Dequeue();

            if (visited.Contains(currentNode.index)) continue;
            visited.Add(currentNode.index);

            currentNode.path.Add(currentNode);
            if (currentNode.index + currentNode.data >= numbers.Length)
            {
                isPathFound = true;
                Console.Write("\n" + name() + " " + isPathFound);
                Console.Write("\n" + name() + "\tPossible indexes path to end : ");
                foreach (var node in currentNode.path) Console.Write(node.index + " ");
                Console.Write("end");
                break;
            }
            foreach (var conn in currentNode.connected)
            {
                if (conn.path.Count != 0) continue;
                conn.path = new List<Node<int>>(currentNode.path);
                nodesQueue.Enqueue(conn);
            }
        }

        if (!isPathFound)
        {
            Console.Write("\n" + name() + " " + isPathFound);
            Console.Write("\n" + name() + "\tPossible indexes path to end : None");
        }
    }

    private Dictionary<int, Node<int>> createNodes(int[] numbers)
    {
        var nodeDict = new Dictionary<int, Node<int>>();
        for (int index = 0; index < numbers.Length; ++index)
        {
            var node = new Node<int>
                        {
                            index = index,
                            data = numbers[index],
                            connected = new List<Node<int>>(),
                            path = new List<Node<int>>()
                        };
            nodeDict.Add(index, node);
        }
        return nodeDict;
    }

    private void connectNodes(
        int[] numbers,
        Dictionary<int, Node<int>> nodeDict)
    {
        for (int index = 0; index < numbers.Length; ++index)
        {
            int maxReachableIndex = index + numbers[index];
            for (int reachedIndex = index + 1;
                reachedIndex < numbers.Length && reachedIndex <= maxReachableIndex;
                ++reachedIndex)
            {
                nodeDict[index].connected.Add(nodeDict[reachedIndex]);
            }
        }
        // Console.WriteLine();
        // foreach (var node in nodeDict)
        // {
        //     Console.WriteLine(node.Value.data);
        //     foreach (var conn in node.Value.connected)
        //     {
        //         Console.WriteLine("\t" + conn.index + ":" + conn.data);
        //     }
        // }
    }

    private class Node<DataType>
    {
        public int index;
        public DataType data;// { get; set; }
        public List<Node<DataType>> connected;// { get; set; }
        public List<Node<DataType>> path;
    }
}

class HelloWorld
{
  static void Main()
  {
    (new HelloWorld()).RealMain();
  }

  void RealMain()
  {
        ReachableEndChecker[] checkers =
            {
                new BackwardsValidator(),
                new DfsRecursion(),
                new BfsGraphNodes(),
            };

        List<List<int>> numbersList =
            new List<List<int>>
            {
                new List<int>{4, 3, 1, 3, 1, 0, 4},
                new List<int>{1, 0, 1, 0, 0, 1},
                new List<int>{3, 2, 2, 1, 0},
                new List<int>{3, 2, 3, 1, 0},
                new List<int>{6, 0, 3, 0, 2, 1, 0},
                new List<int>{6, 0, 3, 0, 3, 1, 0},
                new List<int>{4, 2, 1, 9, 1, 1, 1},
            };

        foreach (var numbers in numbersList)
        {
            Console.WriteLine();
            foreach (var number in numbers) Console.Write(number + " ");
            foreach (var checker  in checkers) checker.reachTheEnd(numbers.ToArray());
        }
  }
}

--------------------------------------------------------------------

// Count syllables

using System;
using System.Linq;

public class Program
{
    public static int NumberSyllables(string word)
    {
            var dashCount = word.ToCharArray().Where(ch => ch == '-').Count();
            return word.Length == 0 ?
                            0 :
                            dashCount + 1;
            // or simply // return word.Split('-').Length;
    }
}

--------------------------------------------------------------------

// Check if all are either uppercase or lowercase

using System.Text.RegularExpressions;

public class Program
{
    public static bool SameCase(string str)
    {
            var foundUpper = Regex.Match(str, "^[A-Z]+$");
            var foundLower = Regex.Match(str, "^[a-z]+$");
            return foundUpper.Success || foundLower.Success;
            // or simply // return Regex.IsMatch(str, "^([a-z]*|[A-Z]*)$");
            // or // return str.All(x => char.IsUpper(x)) || str.All(x =>char.IsLower(x));
            // or probably // return (str.Any(x => char.IsUpper(x)) && !str.Any(x => char.IsLower(x))) ||
            //                          (str.Any(x => char.IsLower(x)) && !str.Any(x => char.IsUpper(x)));
    }
}

--------------------------------------------------------------------

// Count vowels

using System.Collections.Generic;
using System.Linq;

public class Program 
{
    public static int CountVowels(string str) 
    {
      HashSet<char> VOWELS = new HashSet<char>
                                                            {
                                                                'A', 'E', 'I', 'O', 'U',
                                                                'a', 'e','i', 'o', 'u'
                                                            };
            // return str.Where(ch => VOWELS.Contains(ch)).Count();
            return str.Count(ch => VOWELS.Contains(ch));
            // or // string filter = "[aeiou]"; return Regex.Matches(str, filter).Count;
    }
}

--------------------------------------------------------------------

// Rotate array

// Given an unsorted array arr[] of size N, rotate it by D elements (clockwise). 

// Input:
// The first line of the input contains T denoting the number of testcases. First line of eacg test case contains two space separated elements, N denoting the size of the array and an integer D denoting the number size of the rotation. Subsequent line will be the N space separated array elements.

// Output:
// For each testcase, in a new line, output the rotated array.

// Constraints:
// 1 <= T <= 200
// 1 <= N <= 107
// 1 <= D <= N
// 0 <= arr[i] <= 105

// Example:
// Input:
// 2
// 5 2
// 1 2 3 4 5 
// 10 3
// 2 4 6 8 10 12 14 16 18 20

// Output:
// 3 4 5 1 2
// 8 10 12 14 16 18 20 2 4 6

// Explanation :
// Testcase 1: 1 2 3 4 5  when rotated by 2 elements, it becomes 3 4 5 1 2.

using System;
using System.Collections;

public class GFG
{
    static public void Main ()
    {
        int testCasesCount = int.Parse(Console.ReadLine());
        while (testCasesCount > 0)
        {
            int rotationCount = int.Parse(Console.ReadLine().Split()[1]);
            int[] arr = Array.ConvertAll(Console.ReadLine().Trim().Split(),
                                        elem => Convert.ToInt32(elem));
            rotationCount %= arr.Length;

            // useQueue(arr, rotationCount);
            useTempArr(arr, rotationCount);
            // changeInlineWithQueue((int[])arr.Clone(), rotationCount);
            // changeInlineWithoutExtraMemory((int[])arr.Clone(), rotationCount);
            --testCasesCount;
        }
    }

    static public void useQueue(int[] arr, int rotationCount)
    {
        Queue arrQueue = new Queue(arr);
        for (int ctr = 0; ctr < rotationCount; ++ctr)
        {
            var item = arrQueue.Dequeue();
            arrQueue.Enqueue(item);
        }
        int[] arrRotated = Array.ConvertAll(arrQueue.ToArray(), elem => (int)elem);
        foreach (var result in arrRotated) Console.Write($"{result} ");
        Console.WriteLine();
    }

    static public void useTempArr(int[] arr, int rotationCount)
    {
        int[] arrRotated = new int[arr.Length];
        int index = 0;
        for (int ctr = rotationCount; ctr < arr.Length; ++ctr)
        {
            arrRotated[index++] = arr[ctr];
        }
        for (int ctr = 0; ctr < rotationCount; ++ctr)
        {
            arrRotated[index++] = arr[ctr];
        }
        foreach (var result in arrRotated) Console.Write($"{result} ");
        Console.WriteLine();
    }

    static public void changeInlineWithQueue(int[] arr, int rotationCount)
    {
        Queue arrQueue = new Queue();
        int ctr = 0;
        for (; ctr + rotationCount < arr.Length; ++ctr)
        {
            arrQueue.Enqueue(arr[ctr]);
            arr[ctr] = arr[ctr + rotationCount];
        }
        for (; ctr < arr.Length; ++ctr)
        {
            arrQueue.Enqueue(arr[ctr]);
            arr[ctr] = (int)arrQueue.Dequeue();
        }
        foreach (var result in arr) Console.Write($"{result} ");
        Console.WriteLine();
    }

    static public void changeInlineWithoutExtraMemory(int[] arr, int rotationCount)
    {
        // this solution is wrong and is the most complicated among all but if correct would
        // be the most efficient in both time and space, O(n) in time while O(1) in space
        int slowIt = 0;
        int fastIt = rotationCount;
        while (fastIt + rotationCount - 1 < arr.Length)
        {
            for (int ctr = 0; ctr < rotationCount; ++ctr)
            {
                int temp = arr[fastIt];
                arr[fastIt++] = arr[slowIt];
                arr[slowIt++] = temp;
            }
        }
        while (fastIt < arr.Length && fastIt > slowIt)
        {
            int temp = arr[fastIt];
            arr[fastIt] = arr[fastIt - 1];
            arr[--fastIt] = temp;
        }
        foreach (var result in arr) Console.Write($"{result} ");
        Console.WriteLine();
    }
}

/*
hacked in Python

#code

for ctr in range(int(input())):
    N, D = map(int, input().split())
    D %= N
    arrElements = list(input().split())
    print(" ".join(arrElements[D:]), end = " ")
    print(" ".join(arrElements[:D]), end = "\n")

    # arrRotated = arrElements[D:]
    # arrRotated.extend(arrElements[:D])
    # or # arrRotated = arrElements[D:] + arrElements[:D]
    # print(" ".join(arrRotated))

*/

--------------------------------------------------------------------

// Kth smallest element

// Given an array arr[] and a number K where K is smaller than size of array, the task is to find the Kth smallest element in the given array. It is given that all array elements are distinct.

// Expected Time Complexity: O(n)

// Input:
// The first line of input contains an integer T, denoting the number of testcases. Then T test cases follow. Each test case consists of three lines. First line of each testcase contains an integer N denoting size of the array. Second line contains N space separated integer denoting elements of the array. Third line of the test case contains an integer K.

// Output:
// Corresponding to each test case, print the kth smallest element in a new line.

// Constraints:
// 1 <= T <= 100
// 1 <= N <= 105
// 1 <= arr[i] <= 105
// 1 <= K <= N

// Example:
// Input:
// 2
// 6
// 7 10 4 3 20 15
// 3
// 5
// 7 10 4 20 15
// 4

// Output:
// 7
// 15

// Explanation:
// Testcase 1: 3rd smallest element in the given array is 7.

using System;
public class GFG
{
    static public void Main ()
    {
        int testCasesCount = int.Parse(Console.ReadLine());
        while (testCasesCount > 0)
        {
            Console.ReadLine();

            int[] numbers = Array.ConvertAll(Console.ReadLine().Trim().Split(),
                                            elem => int.Parse(elem));
            Array.Sort(numbers);

            int targetIndex = int.Parse(Console.ReadLine()) - 1;

            Console.WriteLine(numbers[targetIndex]);
            --testCasesCount;
        }
    }
}

--------------------------------------------------------------------

// First negative integer in every window of size k

// Given an array and a positive integer k, find the first negative integer for each and every window(contiguous subarray) of size k.

// Input:
// The first line of input contains an integer T denoting the number of test cases. Then T test cases follow. Each test case contains an integer n denoting the size of the array. The next line contains n space separated integers forming the array. The last line contains the window size k.

// Output:
// Print the space separated negative integer starting from the first till the end for every window size k. If a window does not contain a negative integer , then print 0 for that window.

// Constraints:
// 1<=T<=10^5
// 1<=n<=10^5
// 1<=a[i]<=10^5
// 1<=k<=n

// Example:
// Input:
// 2
// 5
// -8 2 3 -6 10
// 2
// 8
// 12 -1 -7 8 -15 30 16 28
// 3

// Output:
// -8 0 -6 -6
// -1 -1 -7 -15 -15 0

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

public class GFG
{
    
    static public void Main ()
    {
        int testCasesCount = int.Parse(Console.ReadLine());
        while (testCasesCount > 0)
        {
            int numbersCount = Convert.ToInt32(Console.ReadLine());
            int[] numbers = Array.ConvertAll(Console.ReadLine().Trim().Split(),
                                            elem => Convert.ToInt32(elem));
            int window = Convert.ToInt32(Console.ReadLine());

            // Solution 1
            /*{
                Queue<int> orderedNumbersWindow = new Queue<int>(numbers.Take(window));

                int firstNegative = orderedNumbersWindow.FirstOrDefault(elem => elem < 0);
                Console.Write($"{firstNegative} ");

                for (int ctr = window; ctr < numbers.Length; ++ctr)
                {
                    orderedNumbersWindow.Dequeue();
                    orderedNumbersWindow.Enqueue(numbers[ctr]);
                    firstNegative = orderedNumbersWindow.FirstOrDefault(elem => elem < 0);
                    Console.Write($"{firstNegative} ");
                }
                Console.WriteLine();
            }*/

            // Solution 2
            {
                Queue<Tuple<int, int>> negativeNumbersAndMaxWindow = new Queue<Tuple<int, int>>();
                for (int ctr = 0; ctr < window; ++ctr)
                {
                    if (numbers[ctr] >= 0) continue;
                    negativeNumbersAndMaxWindow.Enqueue(Tuple.Create(numbers[ctr], ctr + window - 1));
                }

                if (negativeNumbersAndMaxWindow.Count > 0)
                {
                    Console.Write($"{negativeNumbersAndMaxWindow.Peek().Item1} ");
                }
                else
                {
                    Console.Write("0 ");
                }

                for (int ctr = window; ctr < numbers.Length; ++ctr)
                {
                    if (negativeNumbersAndMaxWindow.Count > 0 &&
                        negativeNumbersAndMaxWindow.Peek().Item2 < ctr)
                    {
                        negativeNumbersAndMaxWindow.Dequeue();
                    }
                    if (numbers[ctr] < 0)
                    {
                        negativeNumbersAndMaxWindow.Enqueue(Tuple.Create(numbers[ctr], ctr + window - 1));
                    }

                    if (negativeNumbersAndMaxWindow.Count > 0)
                    {
                        Console.Write($"{negativeNumbersAndMaxWindow.Peek().Item1} ");
                    }
                    else
                    {
                        Console.Write("0 ");
                    }
                }
                Console.WriteLine();
            }
            --testCasesCount;
        }
    }

// This implementation gets the smallest negative number per window, the smallest, not the first -_-
//  static public void Main ()
//  {
//      int testCasesCount = int.Parse(Console.ReadLine());
//      while (testCasesCount > 0)
//      {
//          int numbersCount = Convert.ToInt32(Console.ReadLine());
//          int[] numbers = Array.ConvertAll(Console.ReadLine().Trim().Split(),
//                                          elem => Convert.ToInt32(elem));
//          int window = Convert.ToInt32(Console.ReadLine());

//          SortedDictionary<int, int> sortedNumbersWindow = new SortedDictionary<int, int>();
//          foreach (var element in numbers.Take(window))
//          {
//              sortedNumbersWindow.Add(element, 1);
//          }

//          int lowestNumber = sortedNumbersWindow.Keys.ElementAt(0);
//          Console.Write($"{lowestNumber < 0 ? lowestNumber : 0} ");

//          for (int ctr = window; ctr < numbers.Length; ++ctr)
//          {
//            //  foreach (var a in sortedNumbersWindow) Console.Write($"{a.Key}_{a.Value} ");Console.WriteLine();
//            //  Console.WriteLine($"\tRemove {numbers[ctr - window]}");
//              if (--sortedNumbersWindow[numbers[ctr - window]] == 0)
//              {
//                  sortedNumbersWindow.Remove(numbers[ctr - window]);
//              }

//              if (sortedNumbersWindow.ContainsKey(numbers[ctr]))
//              {
//                  ++sortedNumbersWindow[numbers[ctr]];
//              }
//              else
//              {
//                  sortedNumbersWindow.Add(numbers[ctr], 1);
//              }

//              lowestNumber = sortedNumbersWindow.Keys.ElementAt(0);
//              Console.Write($"{lowestNumber < 0 ? lowestNumber : 0} ");
//          }
//          Console.WriteLine();
//          --testCasesCount;
//      }
//  }
}

--------------------------------------------------------------------

// Sorted matrix

// Given an n x n matrix, where every row and column is sorted in non-decreasing order. Print all elements of matrix in sorted order.

// Input:
// The first line of input contains an integer T denoting the number of test cases. Then T test cases follow. Each test case contains an integer n denoting the size of the matrix. Then the next line contains the n x n elements in row wise order.

// Output:
// Print the elements of the matrix in sorted order.

// Constraints:
// 1<=T<=100
// 1<=n<=100
// 1<=a[n][n]<=100

// Example:
// Input:
// 2
// 4
// 10 20 30 40 15 25 35 45 27 29 37 48 32 33 39 50
// 3
// 1 3 4 2 6 7 5 8 9

// Output:
// 10 15 20 25 27 29 30 32 33 35 37 39 40 45 48 50 
// 1 2 3 4 5 6 7 8 9

using System;
using System.Collections.Generic;

public class GFG
{
    // ReadKey (returns a character):
    //     reads only one single character from the standard input stream.
    //     Usually used when you're giving options to the user in the console to select from,
    //         such as select A, B or C.
    //         Another prominent example, Press Y or n to continue.
    // ReadLine (returns a string):
    //     reads only single line from the standard input stream.
    //     As an example, it can be used to ask the user enter their name or age.
    // Read (returns an int):
    //     reads only one single character from the standard input stream.
    //     Similar to ReadKey except that it returns an integer.

    static public void Main ()
    {
        // useSort();
        useTraversal();

        // var sortedElements = new SortedSet<MatrixElement>(
        //                         Comparer<MatrixElement>.Create(
        //                             (lhs, rhs) => lhs.val.CompareTo(rhs.val) == 0 ?
        //                                             -1 :
        //                                             lhs.val.CompareTo(rhs.val)));
        // sortedElements.Add(new MatrixElement{row = 0, col = 0, val = 1});
        // sortedElements.Add(new MatrixElement{row = 0, col = 1, val = 2});
        // sortedElements.Add(new MatrixElement{row = 0, col = 2, val = 3});
        // sortedElements.Add(new MatrixElement{row = 1, col = 0, val = 3});
        // sortedElements.Add(new MatrixElement{row = 1, col = 1, val = 5});
        // sortedElements.Add(new MatrixElement{row = 1, col = 2, val = 6});
        // foreach (var elem in sortedElements)
        // {
        //     Console.Write($"{elem.val} ");
        // }
    }

    static public void useSort()
    {
        int testCasesCount = int.Parse(Console.ReadLine());
        while (testCasesCount > 0)
        {
            int matrixDimension = int.Parse(Console.ReadLine());
            int[] arrayElements = Array.ConvertAll(Console.ReadLine().Trim().Split(),
                                                    elem => int.Parse(elem));

            int[][] matrix = new int[matrixDimension][];
            for (int row = 0, ctr = 0; row < matrixDimension; ++row)
            {
                matrix[row] = new int[matrixDimension];
                for (int col = 0; col < matrixDimension; ++col)
                {
                   matrix[row][col] = arrayElements[ctr++];
                }
            }

            var sortedElements = new SortedSet<MatrixElement>();
            for (int row = 0; row < matrixDimension; ++row)
            {
                for (int col = 0; col < matrixDimension; ++col)
                {
                    sortedElements.Add(new MatrixElement
                                        {
                                            row = row,
                                            col = col,
                                            val = matrix[row][col]
                                        });
                }
            }
            foreach (var elem in sortedElements)
            {
                Console.Write($"{elem.val} ");
            }
            Console.WriteLine();
           --testCasesCount;
        }
    }
    
    static public void useTraversal()
    {
        int testCasesCount = int.Parse(Console.ReadLine());
        while (testCasesCount > 0)
        {
            int matrixDimension = int.Parse(Console.ReadLine());
            int[] arrayElements = Array.ConvertAll(Console.ReadLine().Trim().Split(),
                                                    elem => int.Parse(elem));

            int[][] matrix = new int[matrixDimension][];
            for (int row = 0, ctr = 0; row < matrixDimension; ++row)
            {
                matrix[row] = new int[matrixDimension];
                for (int col = 0; col < matrixDimension; ++col)
                {
                   matrix[row][col] = arrayElements[ctr++];
                }
            }

            var sortedElements = new SortedSet<MatrixElement>(
                                    ); // uses IComparable::CompareTo
                                   // new MatrixElementComparer()); // uses IComparer::Compare
                                   // Comparer<MatrixElement>.Create( // uses this lambda, which becomes wrong for same values of val
                                   //     (lhs, rhs) => lhs.val.CompareTo(rhs.val)));
            sortedElements.Add(new MatrixElement{row = 0, col = 0, val = matrix[0][0]});
            while (sortedElements.Count > 0)
            {
                var lowest = sortedElements.Min;
                Console.Write($"{lowest.val} ");
                if (lowest.col + 1 < matrixDimension && matrix[lowest.row][lowest.col + 1] != 0)
                {
                    sortedElements.Add(new MatrixElement
                                        {
                                            row = lowest.row,
                                            col = lowest.col + 1,
                                            val = matrix[lowest.row][lowest.col + 1]
                                        });
                }
                if (lowest.row + 1 < matrixDimension && matrix[lowest.row + 1][lowest.col] != 0)
                {
                    sortedElements.Add(new MatrixElement
                                        {
                                            row = lowest.row + 1,
                                            col = lowest.col,
                                            val = matrix[lowest.row + 1][lowest.col]
                                        });
                }
                sortedElements.Remove(lowest);
            }
            Console.WriteLine();
           --testCasesCount;
        }
    }
}

class MatrixElement : IComparable
{
    public int row { get; set; }
    public int col { get; set; }
    public int val { get; set; }

    // public static bool operator<(MatrixElement lhs, MatrixElement rhs)
    // {
    //     return lhs.val < rhs.val;
    // }

    // public static bool operator>(MatrixElement lhs, MatrixElement rhs)
    // {
    //     return !(lhs < rhs) && lhs != rhs;
    // }

    public int CompareTo(object otherObject)
    {
        MatrixElement other = otherObject as MatrixElement; // or // MatrixElement other = (MatrixElement)otherObject;
        int valResult = this.val.CompareTo(other.val);
        if (valResult == 0)
        {
            int rowResult = this.row.CompareTo(other.row);
            if (rowResult == 0) return this.col.CompareTo(other.col);
            return rowResult;
        }
        return valResult;
    }
}

class MatrixElementComparer : IComparer<MatrixElement>
{
    public int Compare(MatrixElement lhs, MatrixElement rhs)
    {
        int valResult = lhs.val.CompareTo(rhs.val);
        if (valResult == 0)
        {
            int rowResult = lhs.row.CompareTo(rhs.row);
            if (rowResult == 0) return lhs.col.CompareTo(rhs.col);
            return rowResult;
        }
        return valResult;
    }
}

--------------------------------------------------------------------

// Palindromic Array    Submissions: 8597   Accuracy: 57.36%   Difficulty: Medium   Marks: 4

// Problems
// You are given an array A of size N. Your task is to find the minimum number of operations needed to convert the given array to 'Palindromic Array'.

// Palindromic Array:
// [23,15,23] is a ‘Palindromic Array’ but [2,0,1] is not.

// The only allowed operation is that you can merge two adjacent elements in the array and replace them with their sum.

// Input:
// The first line of input contains an integer T denoting the number of test cases.
// The first line of each test case is N, where N is the size of array.
// The second line of each test case contains N space separated integers which is the input for the array.

// Output:
// Output the minimum number of operations required to make the given array a palindromic array.

// Constraints:
// 1<=T<=100
// 1<=N<=100

// Example:
// Input:
// 2
// 5
// 3 2 3 3 5
// 4
// 5 3 3 4
// Output:
// 1
// 3

// Explanation:
// For Test Case 1: [3 2 3 3 5] after merging the 1st two elements 3 and 2, we get the array as [5 3 3 5] which is a palindrome, hence only 1 operation is needed.

// My solution turns out to be the exact same solution from the editorial of this problem!
using System;

public class GFG
{
    static public void Main ()
    {
        int testCasesCount = int.Parse(Console.ReadLine());
        while (testCasesCount > 0)
        {
            int numbersLength = int.Parse(Console.ReadLine());
            int[] numbers = Array.ConvertAll(Console.ReadLine().Trim().Split(), elem => int.Parse(elem));

            int operations = 0;
            int forwardIt = 0;
            int backwardIt = numbersLength - 1;
            while (forwardIt < backwardIt)
            {
                if (numbers[forwardIt] == numbers[backwardIt])
                {
                    ++forwardIt;
                    --backwardIt;
                }
                else if (forwardIt + 1 == backwardIt)
                {
                    ++operations;
                    break;
                }
                else
                {
                    int leftMoved = numbers[forwardIt] + numbers[forwardIt + 1];
                    int rightMoved = numbers[backwardIt] + numbers[backwardIt - 1];
                    if (leftMoved == rightMoved)
                    {
                        operations += 2;
                        forwardIt += 2;
                        backwardIt -= 2;
                    }
                    else if (leftMoved > rightMoved)
                    {
                        ++operations;
                        numbers[backwardIt] = 0;
                        numbers[--backwardIt] = rightMoved;
                    }
                    else // else if (leftMoved < rightMoved)
                    {
                        ++operations;
                        numbers[forwardIt] = 0;
                        numbers[++forwardIt] = leftMoved;
                    }
                }
            }

            Console.WriteLine(operations);
            --testCasesCount;
        }
    }
}

--------------------------------------------------------------------

// Count subsequences of type a^i b^j c^k

// Given a string s, the task is to count number of subsequences of the form aibjck, where i >= 1, j >=1 and k >= 1.

// Note: Two subsequences are considered different if the set of array indexes picked for the 2 subsequences are different.


// Examples:

// Input  : abbc
// Output : 3
// Subsequences are abc, abc and abbc

// Input  : abcabc
// Output : 7
// Subsequences are abc, abc, abbc, aabc
// abcc, abc and abc


// Input:
// The first line of input contains an integer T denoting the no of test cases. Then T test cases follow. Each test case contains a string s.

// Output:
// For each test case in a new line print the required output.

// Constraints:
// 1<=T<=100
// 1<=Length of string <=100

// Example:
// Input:
// 2
// abbc
// abcabc
// Output:
// 3
// 7

// aaaabc
// a   bc
//  a  bc
//   a bc
//    abc
// aa  bc
// a a bc
// a  abc
//  aa bc
//  a abc
//   aabc
// aaa bc
// aa abc
// a aabc
//  aaabc
// aaaabc

using System;
using System.Collections.Generic;
using System.Linq;

public class GFG
{
    static public void Main()
    {
       // useUnlimitedMemory();
       // useEnoughMemory();

        // from editorial
        int testCasesCount = int.Parse(Console.ReadLine());
        while (testCasesCount-- > 0)
        {
            string text = Console.ReadLine();
            int aCount = 0;
            int bCount = 0;
            int cCount = 0;
            foreach (var ch in text)
            {
                if (ch == 'a') aCount = (aCount * 2) + 1;
                else if (ch == 'b') bCount = (bCount * 2) + aCount;
                else if (ch == 'c') cCount = (cCount * 2) + bCount;
            }
            Console.WriteLine(cCount);
        }
    }

    static public void useEnoughMemory()
    {
        int testCasesCount = int.Parse(Console.ReadLine());
        while (testCasesCount-- > 0)
        {
            string text = Console.ReadLine();
            List<Node> rootNodes = new List<Node>();
            foreach (char ch in text)
            {
                foreach (Node root in rootNodes)
                {
                    Queue<Node> nodes = new Queue<Node>(); // BFS Queue, but could also be DFS Stack
                    nodes.Enqueue(root);
                    while (nodes.Count > 0)
                    {
                        var currentNode = nodes.Dequeue();
                        foreach (var conn in currentNode.connected) nodes.Enqueue(conn);

                        if (currentNode.data == ch || currentNode.data + 1 == ch)
                        {
                            currentNode.connected.Add(new Node(ch));
                        }
                    }
                }
                if (ch == 'a')
                {
                    rootNodes.Add(new Node(ch));
                }
            }
            int countOfLetterC = 0;
            foreach (Node root in rootNodes)
            {
                Stack<Node> nodes = new Stack<Node>(); // DFS Stack, but could also be BFS Queue
                nodes.Push(root);
                while (nodes.Count > 0)
                {
                    var currentNode = nodes.Pop();
                    if (currentNode.data == 'c') ++countOfLetterC;
                    foreach (var conn in currentNode.connected) nodes.Push(conn);
                }
            }
            Console.WriteLine(countOfLetterC);
        }
    }

    static public void useUnlimitedMemory()
    {
        int testCasesCount = int.Parse(Console.ReadLine());
        while (testCasesCount-- > 0)
        {
          //  Console.WriteLine("/tTC");
            string text = Console.ReadLine();
            List<List<char>> combinations = new List<List<char>>();
            foreach (char ch in text)
            {
                foreach (var currentCombination in combinations.ToList()) // just a clone
                {
                  //  foreach (var a in currentCombination) Console.Write(a); Console.WriteLine(" end");
                    if (currentCombination.Last() == ch || currentCombination.Last() + 1 == ch)
                    {
                        combinations.Add(new List<char>(currentCombination));
                        combinations.Last().Add(ch);
                    }
                }
                if (ch == 'a')
                {
                    combinations.Add(new List<char>(){ch});
                }
            }
            int totalCount = 0;
            foreach (var currentCombination in combinations)
            {
                if (currentCombination.Last() == 'c') ++totalCount;
            }
            Console.WriteLine(totalCount);
        }
    }
}

// This class will be used to create trie-like data structure
// What are the criteria on which to decide when a tree node should be a struct or a class?
// - i would go for class becuase you can pass node as reference but not on the struct which will be passed as a copy of original
//   and you would require a lot of manupulation on nodes so passing them as a reference sometime results in performance boostup.
public class Node
{
    public char data;
    public HashSet<Node> connected;

    public Node(char ch)
    {
        data = ch;
        connected = new HashSet<Node>();
    }
}

--------------------------------------------------------------------

// CamelCase Pattern Matching

// Given a dictionary of words where each word follows CamelCase notation, print all words in the dictionary that match with a given pattern consisting of uppercase characters only.

// CamelCase is the practice of writing compound words or phrases such that each word or abbreviation begins with a capital letter. Common examples include: “PowerPoint” and “WikiPedia”, “GeeksForGeeks”, “CodeBlocks”, etc.

// Input:
// The first line of input contains an integer T denoting the number of test cases. Then the description of T test cases follow. Each test case contains an integer n denoting the number of words in the dictionary. The next line contains the vector of strings in the dictionary. The last line contains the pattern.

// Output:
// Print all words in the dictionary that match with a given pattern consisting of uppercase characters only. If the pattern is not found, print "No match found" (without quotes).

// Constraints:
// 1<=T<=100
// 1<=n<=100
// 1<=length of string<=100
// 1<=length of patter<=length of string<=100

// Example:
// Input:
// 2
// 8
// Hi Hello HelloWorld HiTech HiGeek HiTechWorld HiTechCity HiTechLab
// HA
// 3
// WelcomeGeek WelcomeToGeeksForGeeks GeeksForGeeks
// WTG

// Output:
// No match found
// WelcomeToGeeksForGeeks

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

public class GFG
{
    static private String constructPattern(String toFind)
    {
        StringBuilder pattern = new StringBuilder("^");
        String smallChars = "[a-z]*";
        foreach (var ch in toFind)
        {
            pattern.Append(ch).Append(smallChars);
        }
        pattern.Append("[A-Za-z]*$");
        return pattern.ToString();
    }

    static public void Main ()
    {
        int testCasesCount = int.Parse(Console.ReadLine());
        while (testCasesCount-- > 0)
        {
            Console.ReadLine();
            var words = Console.ReadLine().Split();
            var toFind = Console.ReadLine();
            var pattern = constructPattern(toFind);

            List<String> matches = new List<String>();
            foreach (var word in words)
            {
                if (Regex.Match(word, pattern).Success) matches.Add(word);
            }

            // matches.Sort(); // Only sort by capital letters, leave input order as it is
            matches.Sort((lhs, rhs) =>
                            String.Concat(lhs.Where(ch => Char.IsUpper(ch))).CompareTo(
                            String.Concat(rhs.Where(ch => Char.IsUpper(ch)))));

            if (matches.Count > 0)
            {
                foreach (var match in matches) Console.Write($"{match} ");
            }
            else
            {
                Console.Write("No match found");
            }
            Console.WriteLine();
        }
    }
}
